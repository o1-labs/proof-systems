"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[2498],{3874(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"snarky/snarky-wrapper","title":"Snarky wrapper","description":"Snarky, as of today, is constructed as two parts:","source":"@site/docs/snarky/snarky-wrapper.md","sourceDirName":"snarky","slug":"/snarky/snarky-wrapper","permalink":"/proof-systems/snarky/snarky-wrapper","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/snarky/snarky-wrapper.md","tags":[],"version":"current","frontMatter":{}}');var s=t(4848),r=t(8453);const a={},o="Snarky wrapper",c={},u=[{value:"Public output",id:"public-output",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"snarky-wrapper",children:"Snarky wrapper"})}),"\n",(0,s.jsx)(n.p,{children:"Snarky, as of today, is constructed as two parts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"a snarky wrapper, which is explained in this document"}),"\n",(0,s.jsxs)(n.li,{children:["a backend underneath that wrapper, explained in the\n",(0,s.jsx)(n.a,{href:"/proof-systems/snarky/kimchi-backend",children:"kimchi backend section"})]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This separation exists for legacy reasons, and ideally we should merge the two\ninto a single library."})}),"\n",(0,s.jsxs)(n.p,{children:["The snarky wrapper mostly exists in ",(0,s.jsx)(n.code,{children:"checked_runner.rs"}),", and has the following\nstate:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"where\n    F: PrimeField,\n{\n    /// The constraint system used to build the circuit.\n    /// If not set, the constraint system is not built.\n    system: Option<SnarkyConstraintSystem<F>>,\n\n    /// The public input of the circuit used in witness generation.\n    // TODO: can we merge public_input and private_input?\n    public_input: Vec<F>,\n\n    // TODO: we could also just store `usize` here\n    pub(crate) public_output: Vec<FieldVar<F>>,\n\n    /// The private input of the circuit used in witness generation. Still not sure what that is, or why we care about this.\n    private_input: Vec<F>,\n\n    /// If set, the witness generation will check if the constraints are satisfied.\n    /// This is useful to simulate running the circuit and return an error if an assertion fails.\n    eval_constraints: bool,\n\n    /// The number of public inputs.\n    num_public_inputs: usize,\n\n    /// A counter used to track variables (this includes public inputs) as they're being created.\n    next_var: usize,\n\n    /// Indication that we're running the witness generation (as opposed to the circuit creation).\n    mode: Mode,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The wrapper is designed to be used in different ways, depending on the fields\nset."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Ideally, we would like to only run this once and obtain a result that's an\nimmutable compiled artifact. Currently, ",(0,s.jsx)(n.code,{children:"public_input"}),", ",(0,s.jsx)(n.code,{children:"private_input"}),",\n",(0,s.jsx)(n.code,{children:"eval_constraints"}),", ",(0,s.jsx)(n.code,{children:"next_var"}),", and ",(0,s.jsx)(n.code,{children:"mode"})," all need to be mutable. In the future\nthese should be passed as arguments to functions, and should not exist in the\nstate."]})}),"\n",(0,s.jsx)(n.h2,{id:"public-output",children:"Public output"}),"\n",(0,s.jsx)(n.p,{children:"The support for public output is implemented as kind of a hack."}),"\n",(0,s.jsx)(n.p,{children:"When the developer writes a circuit, they have to specify the type of the public\noutput."}),"\n",(0,s.jsx)(n.p,{children:"This allows the API to save enough room at the end of the public input, and\nstore the variables used in the public output in the state."}),"\n",(0,s.jsx)(n.p,{children:"When the API calls the circuit written by the developer, it expects the public\noutput (as a snarky type) to be returned by the function. The compilation or\nproving API that ends up calling that function, can thus obtain the variables of\nthe public output. With that in hand, the API can continue to write the circuit\nto enforce an equality constraint between these variables being returned and the\npublic output variable that it had previously stored in the state."}),"\n",(0,s.jsxs)(n.p,{children:["Essentially, the kimchi backend will turn this into as many wiring as there are\n",(0,s.jsx)(n.code,{children:"FieldVar"})," in the public output."]}),"\n",(0,s.jsxs)(n.p,{children:["During witness generation, we need a way to modify the witness once we know the\nvalues of the public output. As the public output ",(0,s.jsx)(n.code,{children:"FieldVar"}),"s were generated\nfrom the snarky wrapper (and not from the kimchi backend), the snarky wrapper\nshould know their values after running the given circuit."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);