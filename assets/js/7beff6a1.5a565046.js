"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[8211],{588(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"fundamentals/proof_systems","title":"Proof Systems Design Overview","description":"Many modern proof systems (and I think all that are in use) are constructed","source":"@site/docs/fundamentals/proof_systems.md","sourceDirName":"fundamentals","slug":"/fundamentals/proof_systems","permalink":"/proof-systems/fundamentals/proof_systems","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/fundamentals/proof_systems.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Full Protocol","permalink":"/proof-systems/fundamentals/zkbook_2pc/2pc"},"next":{"title":"zk-SNARKs","permalink":"/proof-systems/fundamentals/zkbook_plonk"}}');var i=t(4848),a=t(8453);const o={},r="Proof Systems Design Overview",l={},h=[];function c(e){const n={a:"a",annotation:"annotation",em:"em",h1:"h1",header:"header",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"proof-systems-design-overview",children:"Proof Systems Design Overview"})}),"\n",(0,i.jsx)(n.p,{children:"Many modern proof systems (and I think all that are in use) are constructed\naccording to the following recipe."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"You start out with a class of computations."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["You devise a way to ",(0,i.jsx)(n.em,{children:"arithmetize"})," those computations. That is, to express\nyour computation as a statement about polynomials."]}),"\n",(0,i.jsx)(n.p,{children:'More specifically, you describe what is often called an "algebraic\ninteractive oracle proof" (AIOP) that encodes your computation. An AIOP is a\nprotocol describing an interaction between a prover and a verifier, in which\nthe prover sends the verifier some "polynomial oracles" (basically a black\nbox function that given a point evaluates a polynomial at that point), the\nverifier sends the prover random challenges, and at the end, the verifier\nqueries the prover\'s polynomials at points of its choosing and makes a\ndecision as to whether it has been satisfied by the proof.'}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:['An AIOP is an imagined interaction between parties. It is an abstract\ndescription of the protocol that will be "compiled" into a SNARK. There are\nseveral "non-realistic" aspects about it. One is that the prover sends the\nverifier black-box polynomials that the verifier can evaluate. These\npolynomials have degree comparable to the size of the computation being\nverified. If we implemented these "polynomial oracles" by having the prover\nreally send the ',(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})," size polynomials (say by sending all their\ncoefficients), then we would not have a zk-SNARK at all, since the verifier\nwould have to read this linearly sized polynomial so we would lose\nsuccinctness, and the polynomials would not be black-box functions, so we may\nlose zero-knowledge."]}),"\n",(0,i.jsxs)(n.p,{children:["Instead, when we concretely instantiate the AIOP, we have the prover send\nconstant-sized, hiding ",(0,i.jsx)(n.em,{children:"polynomial commitments"}),". Then, in the phase of the\nAIOP where the verifier queries the polynomials, the prover sends an ",(0,i.jsx)(n.em,{children:"opening\nproof"})," for the polynomial commitments which the verifier can check, thus\nsimulating the activity of evaluating the prover's polynomials on your own."]}),"\n",(0,i.jsx)(n.p,{children:"So this is the next step of making a SNARK: instantiating the AIOP with a\npolynomial commitment scheme of one's choosing. There are several choices\nhere and these affect the properties of the SNARK you are constructing, as\nthe SNARK will inherit efficiency and setup properties of the polynomial\ncommitment scheme used."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"An AIOP describes an interactive protocol between the verifier and the\nprover. In reality, typically, we also want our proofs to be non-interactive."}),"\n",(0,i.jsxs)(n.p,{children:["This is accomplished by what is called the\n",(0,i.jsx)(n.a,{href:"../plonk/fiat_shamir",children:"Fiat-Shamir transformation"}),'. The basic idea is this:\nall that the verifier is doing is sampling random values to send to the\nprover. Instead, to generate a "random" value, the prover simulates the\nverifier by hashing its messages. The resulting hash is used as the "random"\nchallenge.']}),"\n",(0,i.jsx)(n.p,{children:"At this point we have a fully non-interactive proof. Let's review our steps."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Start with a computation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Translate the computation into a statement about polynomials and design a\ncorresponding AIOP."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Compile the AIOP into an interactive protocol by having the prover send\nhiding polynomial commitments instead of polynomial oracles."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Get rid of the verifier-interaction by replacing it with a hash function.\nI.e., apply the Fiat--Shamir transform."}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);