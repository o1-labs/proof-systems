"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[1933],{4620(e,t,a){a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"plonk/fiat_shamir","title":"Non-Interactivity via Fiat-Shamir","description":"So far we\'ve talked about an interactive protocol between a prover and a","source":"@site/docs/plonk/fiat_shamir.md","sourceDirName":"plonk","slug":"/plonk/fiat_shamir","permalink":"/proof-systems/plonk/fiat_shamir","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/plonk/fiat_shamir.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Lagrange basis in multiplicative subgroups","permalink":"/proof-systems/plonk/lagrange"},"next":{"title":"Plookup","permalink":"/proof-systems/plonk/plookup"}}');var i=a(4848),s=a(8453);const o={},r="Non-Interactivity via Fiat-Shamir",c={},l=[{value:"Public-coin protocols",id:"public-coin-protocols",level:2},{value:"Fiat-Shamir trick",id:"fiat-shamir-trick",level:2},{value:"Generalization of Fiat-Shamir",id:"generalization-of-fiat-shamir",level:2},{value:"In practice: a duplex construction as Merlin",id:"in-practice-a-duplex-construction-as-merlin",level:2}];function h(e){const t={a:"a",annotation:"annotation",h1:"h1",h2:"h2",header:"header",math:"math",mi:"mi",mrow:"mrow",p:"p",semantics:"semantics",span:"span",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"non-interactivity-via-fiat-shamir",children:"Non-Interactivity via Fiat-Shamir"})}),"\n",(0,i.jsx)(t.p,{children:"So far we've talked about an interactive protocol between a prover and a\nverifier. The zero-knowledge proof was also in the honest verifier\nzero-knowedlge (HVZK) model, which is problematic."}),"\n",(0,i.jsx)(t.p,{children:"In practice, we want to remove the interaction and have the prover produce a\nproof by themselves, that anyone can verify."}),"\n",(0,i.jsx)(t.h2,{id:"public-coin-protocols",children:"Public-coin protocols"}),"\n",(0,i.jsx)(t.p,{children:"public-coin protocols are protocols were the messages of the verifier are simply\nrandom messages. This is important as our technique to transform an interactive\nprotocol to a non-interactive protocol works on public-coin protocols."}),"\n",(0,i.jsx)(t.h2,{id:"fiat-shamir-trick",children:"Fiat-Shamir trick"}),"\n",(0,i.jsx)(t.p,{children:"The whole idea is to replace the verifier by a random oracle, which in practice\nis a hash function. Note that by doing this, we remove potential leaks that can\nhappen when the verifier acts dishonestly."}),"\n",(0,i.jsxs)(t.p,{children:["Initially the Fiat-Shamir transformation was only applied to sigma protocols,\nnamed after the greek letter ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsx)(t.mi,{mathvariant:"normal",children:"\u03a3"})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\Sigma"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(t.span,{className:"mord",children:"\u03a3"})]})})]})," due to its shape resembling the direction\nof messages (prover sends a commit to a verifier, verifier sends a challenge to\na prover, prover sends the final proof to a verifier). A ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsx)(t.mi,{children:"Z"})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"Z"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"})]})})]})," would have made\nmore sense but here we are."]}),"\n",(0,i.jsx)(t.h2,{id:"generalization-of-fiat-shamir",children:"Generalization of Fiat-Shamir"}),"\n",(0,i.jsx)(t.p,{children:"As our protocol has more than three moves, where every even move is a challenge\nfrom the verifier, we need to generalize Fiat-Shamir. This is simple: every\nverifier move can be replaced by a hash of the transcript (every message sent\nand received so far) to obtain a challenge."}),"\n",(0,i.jsx)(t.h2,{id:"in-practice-a-duplex-construction-as-merlin",children:"In practice: a duplex construction as Merlin"}),"\n",(0,i.jsxs)(t.p,{children:["While we use a hash function for that, a different construction called the\n",(0,i.jsx)(t.a,{href:"https://keccak.team/sponge_duplex.html",children:"duplex construction"})," is particularly\nuseful in such situations as they allow to continuously absorb the transcript\nand produce challenges, while automatically authenticating the fact that they\nproduced a challenge."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://merlin.cool/",children:"Merlin"})," is a standardization of such a construction using\nthe ",(0,i.jsx)(t.a,{href:"https://strobe.sourceforge.io/",children:"Strobe protocol framework"})," (a framework to\nmake use of a duplex construction). Note that the more recent\n",(0,i.jsx)(t.a,{href:"https://keccak.team/xoodyak.html",children:"Xoodyak"})," (part of NIST's lightweight\ncompetition) could have been used for this as well. Note also that Mina uses\nnone of these standards, instead it simply uses Poseidon (see section on\nposeidon)."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453(e,t,a){a.d(t,{R:()=>o,x:()=>r});var n=a(6540);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);