"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[3262],{236(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/files/pickles_structure_wrap-a9060c0d6aac8b7cec74d308b91f3f1b.svg"},2494(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/files/pickles_structure-1b18632aef1c825cf1b329da2ff24d83.drawio"},2851(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/files/pickles_structure_wrap_deferred_values-327d1d8f136e278946506014880e2653.svg"},3592(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/pickles_structure_wrap-a9060c0d6aac8b7cec74d308b91f3f1b.svg"},4687(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/pickles_structure_legend_1-d2f1d52020533f995a9539faca6f52db.svg"},7526(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/files/pickles_structure_step-0388a70aaf48067e7906836e3ff5df5a.svg"},8175(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/pickles_structure_wrap_deferred_values-327d1d8f136e278946506014880e2653.svg"},8453(e,t,s){s.d(t,{R:()=>r,x:()=>o});var n=s(6540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},9430(e,t,s){s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"pickles/diagrams","title":"Pickles Technical Diagrams","description":"This section contains a series of diagrams giving an overview of implementation","source":"@site/docs/pickles/diagrams.md","sourceDirName":"pickles","slug":"/pickles/diagrams","permalink":"/proof-systems/pickles/diagrams","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/pickles/diagrams.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Deferred Computation","permalink":"/proof-systems/pickles/deferred"},"next":{"title":"Poseidon hash function","permalink":"/proof-systems/specs/poseidon"}}');var a=s(4848),i=s(8453);const r={},o="Pickles Technical Diagrams",c={},d=[{value:"Wrap Computatiton and Deferred Values",id:"wrap-computatiton-and-deferred-values",level:3},{value:"Step Computation",id:"step-computation",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"pickles-technical-diagrams",children:"Pickles Technical Diagrams"})}),"\n",(0,a.jsxs)(t.p,{children:["This section contains a series of diagrams giving an overview of implementation\nof pickles, closely following the structures and abstractions in the code.\nHowever, they are very technical and are primarily intended for developer use.\nThe primary source of all the images in this section is\n",(0,a.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(2494).A+"",children:(0,a.jsx)(t.code,{children:"pickles_structure.drawio"})})," file, and if one edits\nit one must re-generate the ",(0,a.jsx)(t.code,{children:".svg"}),' renders by doing "export -> selection".']}),"\n",(0,a.jsx)(t.p,{children:"The legend of the diagrams is quite straightforward:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The black boxes are data structures that have names and labels following the\nimplementation.\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"MFNStep"}),"/",(0,a.jsx)(t.code,{children:"MFNWrap"})," is an abbreviation from ",(0,a.jsx)(t.code,{children:"MessagesForNextStep"})," and\n",(0,a.jsx)(t.code,{children:"MessagesForNextWrap"})," that is used for brevity. Most other datatypes are\nexactly the same as in the codebase."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.li,{children:"The blue boxes are computations. Sometimes, when the computation is trivial or\nonly vaguely indicated, it is denoted as a text sign directly on an arrow."}),"\n",(0,a.jsxs)(t.li,{children:["Arrows are blue by default and denote moving a piece of data from one place to\nanother with no (or very little) change. Light blue arrows are denoting\nwitness query that is implemented through the ",(0,a.jsx)(t.code,{children:"handler"}),' mechanism. The\n"chicken foot" connector means that this arrow accesses just one field in an\narray: such an arrow could connect e.g. a input field of type ',(0,a.jsx)(t.code,{children:"old_a: A"})," in a\nstructure ",(0,a.jsx)(t.code,{children:"Vec<(A,B)>"})," to an output ",(0,a.jsx)(t.code,{children:"new_a: A"}),", which just means that we are\ninside a ",(0,a.jsx)(t.code,{children:"for"})," loop and this computation is done for all the elements in the\nvector/array."]}),"\n",(0,a.jsx)(t.li,{children:"Colour of the field is sometimes introduced and denotes how many steps ago was\nthis piece of data created. The absence of the colour means either that (1)\nthe data structure contains different subfields of different origin, or that\n(2) it was not coloured but it could be. The colours are assigned according to\nthe following convention:"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:s(4687).A+""})}),"\n",(0,a.jsx)(t.h3,{id:"wrap-computatiton-and-deferred-values",children:"Wrap Computatiton and Deferred Values"}),"\n",(0,a.jsxs)(t.p,{children:["The following is the diagram that explains the Wrap computation. The left half\nof it corresponds to the ",(0,a.jsx)(t.code,{children:"wrap.ml"})," file and the general logic of proof creation,\nwhile the right part of it is ",(0,a.jsx)(t.code,{children:"wrap_main.ml"}),"/",(0,a.jsx)(t.code,{children:"wrap_verifier.ml"})," and explains\nin-circuit computation."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(236).A+"",children:[" ",(0,a.jsx)(t.img,{src:s(3592).A+""})," "]})}),"\n",(0,a.jsxs)(t.p,{children:["This diagram explains the ",(0,a.jsx)(t.code,{children:"deferred_values"})," computation which is in the heart of\n",(0,a.jsx)(t.code,{children:"wrap.ml"})," represented as a blue box in the middle of the left pane of the main\nWrap diagram. Deferred values for Wrap are computed as follows:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(2851).A+"",children:[" ",(0,a.jsx)(t.img,{src:s(8175).A+""})," "]})}),"\n",(0,a.jsx)(t.h3,{id:"step-computation",children:"Step Computation"}),"\n",(0,a.jsxs)(t.p,{children:["The following is the diagram that explains the Step computation, similarly to\nWrap. The left half of it corresponds to the general logic in ",(0,a.jsx)(t.code,{children:"step.ml"}),", and the\nright part of it is ",(0,a.jsx)(t.code,{children:"step_main.ml"})," and explains in-circuit computation. We\nprovide no ",(0,a.jsx)(t.code,{children:"deferred_values"})," computation diagram for Step, but it is very\nconceptually similar to the one already presented for Wrap."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(7526).A+"",children:[" ",(0,a.jsx)(t.img,{src:s(9482).A+""})," "]})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},9482(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/pickles_structure_step-0388a70aaf48067e7906836e3ff5df5a.svg"}}]);