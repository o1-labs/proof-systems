"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[2148],{5371(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"specs/poseidon","title":"Poseidon hash function","description":"Poseidon is a hash function that can efficiently run in a zk circuit. (See","source":"@site/docs/specs/poseidon.md","sourceDirName":"specs","slug":"/specs/poseidon","permalink":"/proof-systems/specs/poseidon","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/specs/poseidon.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Pickles Technical Diagrams","permalink":"/proof-systems/pickles/diagrams"},"next":{"title":"Kimchi Polynomial Commitment","permalink":"/proof-systems/specs/poly-commitment"}}');var o=s(4848),i=s(8453);const a={},r="Poseidon hash function",l={},d=[{value:"APIs",id:"apis",level:2},{value:"Base Sponge",id:"base-sponge",level:3},{value:"Scalar Sponge",id:"scalar-sponge",level:3},{value:"Algorithms",id:"algorithms",level:2},{value:"Permutation",id:"permutation",level:3},{value:"Sponge",id:"sponge",level:3},{value:"Instantiations",id:"instantiations",level:2},{value:"Poseidon-Fp",id:"poseidon-fp",level:3},{value:"Poseidon-Fq",id:"poseidon-fq",level:3},{value:"Test vectors",id:"test-vectors",level:2},{value:"Pointers to the OCaml code",id:"pointers-to-the-ocaml-code",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"poseidon-hash-function",children:"Poseidon hash function"})}),"\n",(0,o.jsxs)(n.p,{children:["Poseidon is a hash function that can efficiently run in a zk circuit. (See\n",(0,o.jsx)(n.a,{href:"https://www.poseidon-hash.info/",children:"poseidon-hash.info"}),") It is based on the\n",(0,o.jsx)(n.a,{href:"https://keccak.team/sponge_duplex.html#:~:text=A%20sponge%20function%20is%20a,or%20the%20retrieval%20of%20output.",children:"sponge function"}),",\nwith a state composed of field elements and a permutation based on field element\noperation (addition and exponentiation)."]}),"\n",(0,o.jsxs)(n.p,{children:["The permutation contains an S-box (exponentiation of a group element), adding\nconstants to the state, and matrix multiplication of the state (multiplications\nand additions) with an ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/MDS_matrix",children:"MDS matrix"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Since a field element is around 255-bit, a single field element is enough as the\ncapacity of the sponge to provide around 116-bit security."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["We might want to piggy back on the\n",(0,o.jsx)(n.a,{href:"https://github.com/C2SP/C2SP/pull/3",children:"zcash poseidon spec"})," at some point\n(perhaps by making this an extension of the zcash poseidon spec)."]})}),"\n",(0,o.jsx)(n.h2,{id:"apis",children:"APIs"}),"\n",(0,o.jsx)(n.p,{children:"We define a base sponge, and a scalar sponge. Both must be instantiated when\nverifying a proof (this is due to recursion-support baked in Kimchi)."}),"\n",(0,o.jsxs)(n.p,{children:["External users of kimchi (or pickles) are most likely to interact with a wrap\nproof (see the ",(0,o.jsx)(n.a,{href:"/proof-systems/specs/pickles",children:"pickles specification"}),"). As such, the sponges they\nneed to instantiate are most likely to be instantiated with:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Poseidon-Fp for base sponge"}),"\n",(0,o.jsx)(n.li,{children:"Poseidon-Fq for the scalar sponge"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"base-sponge",children:"Base Sponge"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"new(params) -> BaseSponge"}),". Creates a new base sponge."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.absorb(field_element)"}),". Absorbs a field element by calling the\nunderlying sponge ",(0,o.jsx)(n.code,{children:"absorb"})," function."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.absorb_point(point)"}),". Absorbs an elliptic curve point. If the\npoint is the point at infinity, absorb two zeros. Otherwise, absorb the x and\ny coordinates with two calls to ",(0,o.jsx)(n.code,{children:"absorb"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.absorb_scalar(field_element_of_scalar_field)"}),". Absorbs a scalar.\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If the scalar field is smaller than the base field (e.g. Fp is smaller than\nFq), then the scalar is casted to a field element of the base field and\nabsorbed via ",(0,o.jsx)(n.code,{children:"absorb"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Otherwise, the value is split between its least significant bit and the\nrest. Then both values are casted to field elements of the base field and\nabsorbed via ",(0,o.jsx)(n.code,{children:"absorb"})," (the high bits first, then the low bit)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.digest() -> field_element"}),". The ",(0,o.jsx)(n.code,{children:"squeeze"})," function of the\nunderlying sponge function is called and the first field element is returned."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.digest_scalar() -> field_element_of_scalar_field"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.challenge // TODO: specify"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"BaseSponge.challenge_fq // TODO: specify"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"scalar-sponge",children:"Scalar Sponge"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"new(params) -> ScalarSponge"}),"\n",(0,o.jsx)(n.li,{children:"ScalarSponge.absorb(scalar_field_element)"}),"\n",(0,o.jsx)(n.li,{children:"ScalarSponge.digest() -> scalar_field_element"}),"\n",(0,o.jsx)(n.li,{children:"ScalarSponge.challenge // TODO: specify"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"algorithms",children:"Algorithms"}),"\n",(0,o.jsx)(n.p,{children:"Note that every operation is done in the field of the sponge."}),"\n",(0,o.jsx)(n.p,{children:"In this section we define the high-level algorithm behind the permutation and\nthe sponge. The permutation is never used directly by users, it is used only by\nthe sponge function."}),"\n",(0,o.jsx)(n.h3,{id:"permutation",children:"Permutation"}),"\n",(0,o.jsx)(n.p,{children:"In pseudo-code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def sbox(field_element):\n    # modular exponentiation\n    return field_element^7\n\n# apply MDS matrix\ndef apply_mds(state):\n    n = [0, 0, 0]\n    n[0] = state[0] * mds[0][0] + state[1] * mds[0][1] + state[2] * mds[0][2]\n    n[1] = state[0] * mds[1][0] + state[1] * mds[1][1] + state[2] * mds[1][2]\n    n[2] = state[0] * mds[2][0] + state[1] * mds[2][1] + state[2] * mds[2][2]\n    return n\n\n# a round in the permutation\ndef apply_round(round, state):\n    # sbox\n    state[0] = sbox(state[0])\n    state[1] = sbox(state[1])\n    state[2] = sbox(state[2])\n\n    # apply MDS matrix\n    state = apply_mds(state)\n\n    # add round constant\n    state[0] += round_constants[round][0]\n    state[1] += round_constants[round][1]\n    state[2] += round_constants[round][2]\n\n# the permutation\ndef permutation(state):\n    round_offset = 0\n    if ARK_INITIAL:\n        constant = round_constants[0]\n        state[0] += constant[0]\n        state[1] += constant[1]\n        state[2] += constant[2]\n        round_offset = 1\n\n    for round in range(round_offset, FULL_ROUNDS + round_offset):\n        apply_round(round, state)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"sponge",children:"Sponge"}),"\n",(0,o.jsx)(n.p,{children:"In pseudo-code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'def new():\n    return {\n        "state": [0] * RATE, # `RATE` field elements set to 0\n        "mode": "absorbing",\n        "offset": 0,\n    }\n\ndef absorb(sponge, field_element):\n    # if we\'re changing mode, reset the offset\n    if sponge.mode == "squeezing":\n        sponge.mode = "absorbing"\n        sponge.offset = 0\n    # we reached the end of the rate, permute\n    elif sponge.offset == RATE:\n        sponge.state = permutation(sponge.state)\n        sponge.offset = 0\n\n    # absorb by adding to the state\n    sponge.state[sponge.offset] += field_element\n    sponge.offset += 1\n\ndef squeeze(sponge):\n    # permute when changing mode or when we already squeezed everything\n    if sponge.mode == "absorbing" or sponge.offset == RATE:\n        sponge.mode = "squeezing"\n        sponge.state = permutation(sponge.state)\n        sponge.offset = 0\n\n    result = sponge.state[sponge.offset]\n    sponge.offset += 1\n    return result\n'})}),"\n",(0,o.jsx)(n.h2,{id:"instantiations",children:"Instantiations"}),"\n",(0,o.jsxs)(n.p,{children:["We instantiate two versions of Poseidon, one for the field Fp, and one for the\nfield Fq (see the ",(0,o.jsx)(n.a,{href:"/proof-systems/specs/pasta",children:"pasta specification"}),")."]}),"\n",(0,o.jsx)(n.p,{children:"Both share the following sponge configuration:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"capacity 1"}),"\n",(0,o.jsx)(n.li,{children:"rate: 2"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"and the following permutation configuration:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"number of full rounds: 55"}),"\n",(0,o.jsx)(n.li,{children:"sbox: 7"}),"\n",(0,o.jsx)(n.li,{children:"ARK_INITIAL: false"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"poseidon-fp",children:"Poseidon-Fp"}),"\n",(0,o.jsxs)(n.p,{children:["You can find the MDS matrix and round constants we use in\n",(0,o.jsx)(n.a,{href:"https://github.com/o1-labs/proof-systems/tree/master/poseidon/src/pasta/fp_kimchi.rs",children:"/poseidon/src/pasta/fp_kimchi.rs"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"poseidon-fq",children:"Poseidon-Fq"}),"\n",(0,o.jsxs)(n.p,{children:["You can find the MDS matrix and round constants we use in\n",(0,o.jsx)(n.a,{href:"https://github.com/o1-labs/proof-systems/tree/master/poseidon/src/pasta/fq_kimchi.rs",children:"/poseidon/src/pasta/fp_kimchi.rs"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"test-vectors",children:"Test vectors"}),"\n",(0,o.jsxs)(n.p,{children:["We have test vectors contained in\n",(0,o.jsx)(n.a,{href:"https://github.com/o1-labs/proof-systems/tree/master/poseidon/tests/test_vectors/kimchi.json",children:"/poseidon/tests/test_vectors/kimchi.json"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"pointers-to-the-ocaml-code",children:"Pointers to the OCaml code"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["our ocaml implementation:\n",(0,o.jsx)(n.a,{href:"https://github.com/minaprotocol/mina/blob/develop/src/lib/random_oracle/random_oracle.mli",children:"https://github.com/minaprotocol/mina/blob/develop/src/lib/random_oracle/random_oracle.mli"})]}),"\n",(0,o.jsxs)(n.li,{children:["relies on random_oracle_input:\n",(0,o.jsx)(n.a,{href:"https://github.com/minaprotocol/mina/blob/develop/src/lib/random_oracle_input/random_oracle_input.ml",children:"https://github.com/minaprotocol/mina/blob/develop/src/lib/random_oracle_input/random_oracle_input.ml"})]}),"\n",(0,o.jsxs)(n.li,{children:["is instantiated with two types of fields:\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/minaprotocol/mina/blob/develop/src/nonconsensus/snark_params/snark_params_nonconsensus.ml",children:"https://github.com/minaprotocol/mina/blob/develop/src/nonconsensus/snark_params/snark_params_nonconsensus.ml"})}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>r});var t=s(6540);const o={},i=t.createContext(o);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);