"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[6709],{2714(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"snarky/vars","title":"Vars","description":"In this section we will introduce two types of variables:","source":"@site/docs/snarky/vars.md","sourceDirName":"snarky","slug":"/snarky/vars","permalink":"/proof-systems/snarky/vars","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/snarky/vars.md","tags":[],"version":"current","frontMatter":{}}');var i=t(4848),a=t(8453);const r={},l="Vars",o={},c=[{value:"Circuit vars",id:"circuit-vars",level:2},{value:"Constants",id:"constants",level:3},{value:"Non-constants",id:"non-constants",level:3},{value:"When do variables get constrained?",id:"when-do-variables-get-constrained",level:3},{value:"Snarky vars",id:"snarky-vars",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"vars",children:"Vars"})}),"\n",(0,i.jsx)(n.p,{children:"In this section we will introduce two types of variables:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Circuit vars, or ",(0,i.jsx)(n.code,{children:"FieldVar"}),"s, which are low-level variables representing field\nelements."]}),"\n",(0,i.jsx)(n.li,{children:"Snarky vars, which are high-level variables that user can use to create more\nmeaningful programs."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"circuit-vars",children:"Circuit vars"}),"\n",(0,i.jsx)(n.p,{children:"In snarky, we first define circuit variables (TODO: rename Field variable?)\nwhich represent field elements in a circuit. These circuit variables, or cvars,\ncan be represented differently in the system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum FieldVar<F>\nwhere\n    F: PrimeField,\n{\n    /// A constant.\n    Constant(F),\n\n    /// A variable that can be referred to via a `usize`.\n    Var(usize),\n\n    /// The addition of two other [FieldVar]s.\n    Add(Box<FieldVar<F>>, Box<FieldVar<F>>),\n\n    /// Scaling of a [FieldVar].\n    Scale(F, Box<FieldVar<F>>),\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["One can see a FieldVar as an AST, where two atoms exist: a ",(0,i.jsx)(n.code,{children:"Var(usize)"})," which\nrepresents a private input, and a ",(0,i.jsx)(n.code,{children:"Constant(F)"})," which represents a constant.\nAnything else represents combinations of these two atoms."]}),"\n",(0,i.jsx)(n.h3,{id:"constants",children:"Constants"}),"\n",(0,i.jsx)(n.p,{children:"Note that a circuit variable does not represent a value that has been\nconstrained in the circuit (yet). This is why we need to know if a cvar is a\nconstant, so that we can avoid constraining it too early. For example, the\nfollowing code does not encode 2 or 1 in the circuit, but will encode 3:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let x: FieldVar = state.exists(|_| 2) + state.exists(|_| 3);\nstate.assert_eq(x, y); // 3 and y will be encoded in the circuit\n"})}),"\n",(0,i.jsx)(n.p,{children:"whereas the following code will encode all variables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let x = y + y;\nlet one: FieldVar = state.exists(|_| 1);\nassert_eq(x, one);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"non-constants",children:"Non-constants"}),"\n",(0,i.jsxs)(n.p,{children:["Right after being created, a ",(0,i.jsx)(n.code,{children:"FieldVar"})," is not constrained yet, and needs to be\nconstrained by the application. That is unless the application wants the\n",(0,i.jsx)(n.code,{children:"FieldVar"})," to be a constant that will not need to be constrained (see previous\nexample) or because the application wants the ",(0,i.jsx)(n.code,{children:"FieldVar"}),' to be a random value\n(unlikely) (TODO: we should add a "rand" function for that).']}),"\n",(0,i.jsx)(n.p,{children:"In any case, a circuit variable which is not a constant has a value that is not\nknown yet at circuit-generation time. In some situations, we might not want to\nconstrain the"}),"\n",(0,i.jsx)(n.h3,{id:"when-do-variables-get-constrained",children:"When do variables get constrained?"}),"\n",(0,i.jsxs)(n.p,{children:["In general, a circuit variable only gets constrained by an assertion call like\n",(0,i.jsx)(n.code,{children:"assert"})," or ",(0,i.jsx)(n.code,{children:"assert_equals"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"When variables are added together, or scaled, they do not directly get\nconstrained. This is due to optimizations targeting R1CS (which we don't support\nanymore) that were implemented in the original snarky library, and that we have\nkept in snarky-rs."}),"\n",(0,i.jsx)(n.p,{children:"Imagine the following example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let y = x1 + x2 + x3 +.... ;\nlet z = y + 3;\nassert_eq(y, 6);\nassert_eq(z, 7);\n"})}),"\n",(0,i.jsx)(n.p,{children:"The first two lines will not create constraints, but simply create minimal ASTs\nthat track all of the additions."}),"\n",(0,i.jsx)(n.p,{children:"Both assert calls will then reduce the variables to a single circuit variable,\ncreating the same constraints twice."}),"\n",(0,i.jsxs)(n.p,{children:["For this reason, there's a function ",(0,i.jsx)(n.code,{children:"seal()"})," defined in pickles and snarkyjs.\n(TODO: more about ",(0,i.jsx)(n.code,{children:"seal()"}),", and why is it not in snarky?) (TODO: remove the R1CS\noptimization)"]}),"\n",(0,i.jsx)(n.h2,{id:"snarky-vars",children:"Snarky vars"}),"\n",(0,i.jsxs)(n.p,{children:["Handling ",(0,i.jsx)(n.code,{children:"FieldVar"}),"s can be cumbersome, as they can only represent a single\nfield element. We might want to represent values that are either in a smaller\nrange (e.g. ",(0,i.jsx)(n.a,{href:"/proof-systems/snarky/booleans",children:"booleans"}),") or that are made out of several\n",(0,i.jsx)(n.code,{children:"FieldVar"}),"s."]}),"\n",(0,i.jsx)(n.p,{children:"For this, snarky's API exposes the following trait, which allows users to define\ntheir own types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait SnarkyType<F>: Sized\nwhere\n    F: PrimeField,\n{\n    /// ?\n    type Auxiliary;\n\n    /// The equivalent type outside of the circuit.\n    type OutOfCircuit;\n\n    const SIZE_IN_FIELD_ELEMENTS: usize;\n\n    fn to_cvars(&self) -> (Vec<FieldVar<F>>, Self::Auxiliary);\n\n    fn from_cvars_unsafe(cvars: Vec<FieldVar<F>>, aux: Self::Auxiliary) -> Self;\n\n    fn check(&self, cs: &mut RunState<F>);\n\n    fn deserialize(&self) -> (Self::OutOfCircuit, Self::Auxiliary);\n\n    fn serialize(out_of_circuit: Self::OutOfCircuit, aux: Self::Auxiliary) -> Self;\n\n    fn constraint_system_auxiliary() -> Self::Auxiliary;\n\n    fn value_to_field_elements(x: &Self::OutOfCircuit) -> (Vec<F>, Self::Auxiliary);\n\n    fn value_of_field_elements(x: (Vec<F>, Self::Auxiliary)) -> Self::OutOfCircuit;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Such types are always handled as ",(0,i.jsx)(n.code,{children:"OutOfCircuit"})," types (e.g. ",(0,i.jsx)(n.code,{children:"bool"}),") by the\nusers, and as a type implementing ",(0,i.jsx)(n.code,{children:"SnarkyType"})," by snarky (e.g.\n",(0,i.jsx)(n.a,{href:"/proof-systems/snarky/booleans",children:(0,i.jsx)(n.code,{children:"Boolean"})}),"). Thus, the user can pass them to snarky in two ways:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"As public inputs"}),". In this case they will be serialized into field elements\nfor snarky before witness generation (via the ",(0,i.jsx)(n.code,{children:"value_to_field_elements()"}),"\nfunction)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"As private inputs"}),". In this case, they must be created using the ",(0,i.jsx)(n.code,{children:"compute()"}),"\nfunction with a closure returning an ",(0,i.jsx)(n.code,{children:"OutOfCircuit"})," value by the user. The call\nto ",(0,i.jsx)(n.code,{children:"compute()"})," will need to have some type hint, for snarky to understand what\n",(0,i.jsx)(n.code,{children:"SnarkyType"})," it is creating. This is because the relationship is currently only\none-way: a ",(0,i.jsx)(n.code,{children:"SnarkyType"})," knows what out-of-circuit type it relates to, but not\nthe other way is not true. (TODO: should we implement that though?)"]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"SnarkyType"})," always implements a ",(0,i.jsx)(n.code,{children:"check()"})," function, which is called by snarky\nwhen ",(0,i.jsx)(n.code,{children:"compute()"})," is called to create such a type. The ",(0,i.jsx)(n.code,{children:"check()"})," function is\nresponsible for creating the constraints that sanitize the newly-created\n",(0,i.jsx)(n.code,{children:"SnarkyType"})," (and its underlying ",(0,i.jsx)(n.code,{children:"FieldVar"}),"s). For example, creating a boolean\nwould make sure that the underlying ",(0,i.jsx)(n.code,{children:"FieldVar"})," is either 0 or 1."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);