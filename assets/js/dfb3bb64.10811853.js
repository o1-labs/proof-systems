"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[6222],{1428(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"snarky/kimchi-backend","title":"Kimchi Backend","description":"Underneath the snarky wrapper (in snarky/checked_runner.rs) lies what we used","source":"@site/docs/snarky/kimchi-backend.md","sourceDirName":"snarky","slug":"/snarky/kimchi-backend","permalink":"/proof-systems/snarky/kimchi-backend","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/snarky/kimchi-backend.md","tags":[],"version":"current","frontMatter":{}}');var s=t(4848),a=t(8453);const r={},o="Kimchi Backend",c={},l=[{value:"A circuit",id:"a-circuit",level:2},{value:"State",id:"state",level:2},{value:"Variables",id:"variables",level:2},{value:"Circuit generation",id:"circuit-generation",level:2},{value:"Finalization of the circuit.",id:"finalization-of-the-circuit",level:2},{value:"Witness generation",id:"witness-generation",level:2},{value:"Permutation",id:"permutation",level:2},{value:"Implementation details",id:"implementation-details",level:2},{value:"equivalence classes",id:"equivalence-classes",level:3},{value:"Union finds",id:"union-finds",level:3},{value:"Validation during witness generation",id:"validation-during-witness-generation",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"kimchi-backend",children:"Kimchi Backend"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://i.imgur.com/KmKU5Pl.jpg",alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["Underneath the snarky wrapper (in ",(0,s.jsx)(n.code,{children:"snarky/checked_runner.rs"}),") lies what we used\nto call the ",(0,s.jsx)(n.code,{children:"plonk_constraint_system"})," or ",(0,s.jsx)(n.code,{children:"kimchi_backend"})," in\n",(0,s.jsx)(n.code,{children:"snarky/constraint_systen.rs"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"It is good to note that we're planning on removing this abstract separation\nbetween the snarky wrapper and the constraint system."})}),"\n",(0,s.jsx)(n.p,{children:"The logic in the kimchi backend serves two purposes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Circuit generation"}),". It is the logic that adds gates to our list of gates\n(representing the circuit). For most of these gates, the variables used are\npassed to the backend by the snarky wrapper, but some of them are created by\nthe backend itself (see more in the ",(0,s.jsx)(n.a,{href:"#variables",children:"variables section"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Witness generation"}),". It is the logic that creates the witness"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"One can also perform two additional operations once the constraint system has\nbeen compiled:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Generate the prover and verifier index for the system."}),"\n",(0,s.jsx)(n.li,{children:"Get a hash of the constraint system (this includes the circuit, the number of\npublic input) (TODO: verify that this is true) (TODO: what else should be in\nthat hash? a version of snarky and a version of kimchi?)."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"a-circuit",children:"A circuit"}),"\n",(0,s.jsx)(n.p,{children:"A circuit is either being built, or has been constructed during a circuit\ngeneration phase:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"enum Circuit<F>\nwhere\n    F: PrimeField,\n{\n    /** A circuit still being written. */\n    Unfinalized(Vec<GateSpec<(), F>>),\n    /** Once finalized, a circuit is represented as a digest\n        and a list of gates that corresponds to the circuit.\n    */\n    Compiled([u8; 32], Vec<CircuitGate<F>>),\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"state",children:"State"}),"\n",(0,s.jsx)(n.p,{children:"The state of the kimchi backend looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"where\n    Field: PrimeField,\n{\n    /// A counter used to track variables\n    /// (similar to the one in the snarky wrapper)\n    next_internal_var: usize,\n\n    /// Instruction on how to compute each internal variable\n    /// (as a linear combination of other variables).\n    /// Used during witness generation.\n    internal_vars: HashMap<InternalVar, (Vec<(Field, V)>, Option<Field>)>,\n\n    /// The symbolic execution trace table.\n    /// Each cell is a variable that takes a value during witness generation.\n    /// (if not set, it will take the value 0).\n    rows: Vec<Vec<Option<V>>>,\n\n    /// The circuit once compiled\n    gates: Circuit<Field>,\n\n    /// The row to use the next time we add a constraint.\n    // TODO: I think we can delete this\n    next_row: usize,\n\n    /// The size of the public input\n    /// (which fills the first rows of our constraint system.\n    public_input_size: Option<usize>,\n\n    // omitted values...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,s.jsx)(n.p,{children:"In the backend, there's two types of variables:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"enum V {\n    /// An external variable\n    /// (generated by snarky, via [exists]).\n    External(usize),\n\n    /// An internal variable is generated to hold an intermediate value,\n    /// (e.g. in reducing linear combinations to single PLONK positions).\n    Internal(InternalVar),\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Internal variables are basically a ",(0,s.jsx)(n.code,{children:"usize"})," pointing to a hashmap in the state."]}),"\n",(0,s.jsx)(n.p,{children:"That hashmap tells you how to compute the internal variable during witness\ngeneration: it is always a linear combination of other variables (and a\nconstant)."}),"\n",(0,s.jsx)(n.h2,{id:"circuit-generation",children:"Circuit generation"}),"\n",(0,s.jsxs)(n.p,{children:["During circuit generation, the snarky wrapper will make calls to the\n",(0,s.jsx)(n.code,{children:"add_constraint()"})," or ",(0,s.jsx)(n.code,{children:"add_basic_snarky_constraint"})," function of the kimchi\nbackend, specifying what gate to use and what variables to use in that gate."]}),"\n",(0,s.jsxs)(n.p,{children:["At this point, the snarky wrapper might have some variables that are not yet\ntracked as such (with a counter). Rather, they are constants, or they are a\ncombination of other variables. You can see that as a small AST representing how\nto compute a variable. (See the ",(0,s.jsx)(n.a,{href:"/proof-systems/snarky/vars#circuit-vars",children:"variables section"})," for\nmore details)."]}),"\n",(0,s.jsxs)(n.p,{children:["For this reason, they can hide a number of operations that haven't been\nconstrained yet. It is the role of the ",(0,s.jsx)(n.code,{children:"add_constrain"})," logic to enforce that at\nthis point constants, as well as linear combinations or scalings of variables,\nare encoded in the circuit. This is done by adding enough generic gates (using\nthe ",(0,s.jsx)(n.code,{children:"reduce_lincom()"})," or ",(0,s.jsx)(n.code,{children:"reduce_to_var()"})," functions)."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This is a remnant of an optimization targeting R1CS (in which additions are for\nfree). An issue with this approach is the following: imagine that two circuit\nvariables are created from the same circuit variable, imagine also that the\noriginal circuit variable contained a long AST, then both variables might end up\ncreating the same constraints to convert that AST. Currently, snarkyjs and\npickles expose a ",(0,s.jsx)(n.code,{children:"seal()"})," function that allows you to reduce this issue, at the\ncost of some manual work and mental tracking on the developer. We should\nprobably get rid of this, while making sure that we can continue to optimize\ngeneric gates (in some cases you can merge two generic gates in one (TODO: give\nan example of where that can happen)). Another solution is to keep track of what\nwas reduced, and reuse previous reductions (similar to how we handle constants)."]})}),"\n",(0,s.jsx)(n.p,{children:'It is during this "reducing" step that internal variables (known only to the\nkimchi backend) are created.'}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The process is quite safe, as the kimchi backend cannot use the snarky wrapper\nvariables directly (which are of type ",(0,s.jsx)(n.code,{children:"FieldVar"}),"). Since the expected format\n(see the ",(0,s.jsx)(n.a,{href:"#variables",children:"variables section"})," is a number (of type ",(0,s.jsx)(n.code,{children:"usize"}),"), the only\nway to convert a non-tracked variable (constant, or scale, or linear\ncombination) is to reduce it (and in the process constraining its value)."]})}),"\n",(0,s.jsxs)(n.p,{children:["Depending on the gate being used, several constraints might be added via the\n",(0,s.jsx)(n.code,{children:"add_row()"})," function which does three things:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"figure out if there's any wiring to be done"}),"\n",(0,s.jsx)(n.li,{children:"add a gate to our list of gates (representing the circuit)"}),"\n",(0,s.jsxs)(n.li,{children:["add the variables to our ",(0,s.jsx)(n.em,{children:"symbolic"})," execution trace table (symbolic in the\nsense that nothing has values yet)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'This process happens as the circuit is "parsed" and the constraint functions of\nthe kimchi backend are called.'}),"\n",(0,s.jsx)(n.p,{children:"This does not lead to a finalized circuit, see the next section to see how that\nis done."}),"\n",(0,s.jsx)(n.p,{children:"(TODO: ideally this should happen in the same step)"}),"\n",(0,s.jsx)(n.h2,{id:"finalization-of-the-circuit",children:"Finalization of the circuit."}),"\n",(0,s.jsx)(n.p,{children:"So far we've only talked about adding specific constraints to the circuit, but\nnot about how public input are handled."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"finalization()"})," function of the kimchi backend does the following:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"add as many generic rows as there are public inputs."}),"\n",(0,s.jsx)(n.li,{children:"construct the permutation"}),"\n",(0,s.jsx)(n.li,{children:"computes a cache of the circuit (TODO: this is so unnecessary)"}),"\n",(0,s.jsx)(n.li,{children:"and other things that are not that important"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"witness-generation",children:"Witness generation"}),"\n",(0,s.jsxs)(n.p,{children:["Witness generation happens by taking the finalized state (in the\n",(0,s.jsx)(n.code,{children:"compute_witness()"})," function) with a callback that can be used to retrieve the\nvalues of external variables (public input and public output)."]}),"\n",(0,s.jsx)(n.p,{children:"The algorithm follows these steps using the symbolic execution table we built\nduring circuit generation:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"it initializes the execution trace table with zeros"}),"\n",(0,s.jsx)(n.li,{children:"go through the rows related to the public input and set the most-left column\nvalues to the ones obtained by the callback."}),"\n",(0,s.jsx)(n.li,{children:"go through the other rows and compute the value of the variables left in the\ntable"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Variables in step 3. should either:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["be absent (",(0,s.jsx)(n.code,{children:"None"}),") and evaluated to the default value 0"]}),"\n",(0,s.jsx)(n.li,{children:"point to an external variable, in which case the closure passed can be used to\nretrieve the value"}),"\n",(0,s.jsx)(n.li,{children:"be an internal variable, in which case the value is computed by evaluating the\nAST that was used to create it."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"permutation",children:"Permutation"}),"\n",(0,s.jsx)(n.p,{children:'The permutation is used to wire cells of the execution trace table\n(specifically, cells belonging to the first 7 columns). It is also known as\n"copy constraints".'}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"In snarky, the permutation is represented differently from kimchi, and thus\nneeds to be converted to the kimchi's format before a proof can be created.\nTODO: merge the representations"})}),"\n",(0,s.jsx)(n.p,{children:"We use the permutation in ingenious ways to optimize circuits. For example, we\nuse it to encode each constants once, and wire it to places where it is used.\nAnother example, is that we use it to assert equality between two cells."}),"\n",(0,s.jsx)(n.h2,{id:"implementation-details",children:"Implementation details"}),"\n",(0,s.jsx)(n.p,{children:"There's two aspect of the implementation of the permutation, the first one is a\nhashmap of equivalence classes, which is used to track all the positions of a\nvariable, the second one is making use of a union find data structure to link\nvariables that are equivalent (we'll talk about that after)."}),"\n",(0,s.jsx)(n.p,{children:"The two data structures are in the kimchi backend's state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct SnarkyConstraintSystem<Field>\nwhere\n    Field: PrimeField,\n{\n    equivalence_classes: HashMap<V, Vec<Position<Row>>>,\n    union_finds: disjoint_set::DisjointSet<V>,\n    // omitted fields...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"equivalence-classes",children:"equivalence classes"}),"\n",(0,s.jsx)(n.p,{children:"As said previously, during circuit generation a symbolic execution trace table\nis created. It should look a bit like this (if there were only 3 columns and 4\nrows):"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"center"}}),(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"0"}),(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"1"}),(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"2"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"v1"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"v1"}),(0,s.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"1"}),(0,s.jsx)(n.td,{style:{textAlign:"center"}}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"v2"}),(0,s.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"2"}),(0,s.jsx)(n.td,{style:{textAlign:"center"}}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"v2"}),(0,s.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"3"}),(0,s.jsx)(n.td,{style:{textAlign:"center"}}),(0,s.jsx)(n.td,{style:{textAlign:"center"}}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"v1"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["From that, it should be clear that all the cells containing the variable ",(0,s.jsx)(n.code,{children:"v1"}),"\nshould be connected, and all the cells containing the variable ",(0,s.jsx)(n.code,{children:"v2"})," should be as\nwell."]}),"\n",(0,s.jsxs)(n.p,{children:["The format that the permutation expects is a\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cyclic_permutation",children:"cycle"}),": a list of cells where\neach cell is linked to the next, the last one wrapping around and linking to the\nfirst one."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, a cycle for the ",(0,s.jsx)(n.code,{children:"v1"})," variable could be:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(0, 0) -> (0, 1)\n(0, 1) -> (3, 2)\n(3, 2) -> (0, 0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["During circuit generation, a hashmap (called ",(0,s.jsx)(n.code,{children:"equivalence_classes"}),") is used to\ntrack all the positions (row and column) of each variable."]}),"\n",(0,s.jsx)(n.p,{children:"During finalization, all the different cycles are created by looking at all the\nvariables existing in the hashmap."}),"\n",(0,s.jsx)(n.h3,{id:"union-finds",children:"Union finds"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, we know that two variables will have equivalent values due to an\n",(0,s.jsx)(n.code,{children:"assert_equal()"})," being called to link them. Since we link two variables\ntogether, they need to be part of the same cycle, and as such we need to be able\nto detect that to construct correct cycles."]}),"\n",(0,s.jsx)(n.p,{children:"To do this, we use a union find data structure, which allows us to easily find\nthe unions of equivalent variables."}),"\n",(0,s.jsxs)(n.p,{children:["When an ",(0,s.jsx)(n.code,{children:"assert_equal()"})," is called, we link the two variables together using the\n",(0,s.jsx)(n.code,{children:"union_finds"})," data structure."]}),"\n",(0,s.jsxs)(n.p,{children:["During finalization, when we create the cycles, we use the ",(0,s.jsx)(n.code,{children:"union_finds"})," data\nstructure to find the equivalent variables. We then create a new equivalence\nclasses hashmap to merge the keys (variables) that are in the same set. This is\ndone before using the equivalence classes hashmap to construct the cycles."]}),"\n",(0,s.jsx)(n.h2,{id:"validation-during-witness-generation",children:"Validation during witness generation"}),"\n",(0,s.jsx)(n.p,{children:"We want to make sure that the program runs to completion, with the given input,\nbefore we start computing the proof (which is expensive)."}),"\n",(0,s.jsx)(n.p,{children:"On top of that, we also want to tell the user what line in their circuit has\nrejected their input. Like a normal program."}),"\n",(0,s.jsxs)(n.p,{children:["This is configurable, via a ",(0,s.jsx)(n.code,{children:"eval_constraints"})," boolean in the state, and is set\nto ",(0,s.jsx)(n.code,{children:"true"})," by default."]}),"\n",(0,s.jsx)(n.p,{children:"To perform this validation, we do two things:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constants"}),". In functions that assert, we always check if we're dealing with\nconstants first. If we are dealing with constants, we don't create any\nconstraints, and we directly check if the computation is correct. For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub fn assert_equals(\n        &self,\n        state: &mut RunState<F>,\n        other: &FieldVar<F>,\n    ) -> SnarkyResult<()> {\n        match (self, other) {\n            (FieldVar::Constant(x), FieldVar::Constant(y)) => {\n                if x == y {\n                    Ok(())\n                } else {\n                    Err(/* ... */)\n                }\n            }\n            () => state.add_constraint(/* ... */)\n        }\n    }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Runtime values"}),'. During witness generation, actual values are passed to the\ncircuit and can also not pass an "asserting" function. In these cases, we\ndirectly check the computation via the gates.']}),"\n",(0,s.jsx)(n.p,{children:"What does it mean? For example, when we add a generic constraint during witness\ngeneration (which are backing a number of asserting functions), we check that\nthe actual values satisfy the generic gate equation."}),"\n",(0,s.jsx)(n.p,{children:'Note that not all gates are behind asserting functions, for example the Poseidon\ngate does not have "bad" inputs, and as such we don\'t do any checks on it. If\nfor some reason the inputs are bad, it means that the user did this on purpose,\nand the proof will fail.'})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);