"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[3116],{3192(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"kimchi/extended-lookup-tables","title":"Extended lookup tables","description":"This (old) RFC proposes an extension to our use of lookup tables using the","source":"@site/docs/kimchi/extended-lookup-tables.md","sourceDirName":"kimchi","slug":"/kimchi/extended-lookup-tables","permalink":"/proof-systems/kimchi/extended-lookup-tables","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/kimchi/extended-lookup-tables.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"$\\\\plookup$ in Kimchi","permalink":"/proof-systems/kimchi/lookup"},"next":{"title":"Custom Constraints","permalink":"/proof-systems/kimchi/custom_constraints"}}');var o=i(4848),s=i(8453);const a={},r="Extended lookup tables",d={},l=[{value:"Motivation",id:"motivation",level:2},{value:"Detailed design",id:"detailed-design",level:2},{value:"Combining multiple tables",id:"combining-multiple-tables",level:3},{value:"Sampling the <code>joint_combiner</code>",id:"sampling-the-joint_combiner",level:3},{value:"Representing the combined fixed table",id:"representing-the-combined-fixed-table",level:3},{value:"Representing the runtime table",id:"representing-the-runtime-table",level:3},{value:"Representing the side-loaded tables",id:"representing-the-side-loaded-tables",level:3},{value:"Position-independence of side-loaded tables",id:"position-independence-of-side-loaded-tables",level:3},{value:"Permutation argument for cheap array lookups",id:"permutation-argument-for-cheap-array-lookups",level:3},{value:"Full list of polynomials and constraints",id:"full-list-of-polynomials-and-constraints",level:3},{value:"Constants",id:"constants",level:4},{value:"Polynomials without per-proof evaluations",id:"polynomials-without-per-proof-evaluations",level:4},{value:"Polynomials with per-proof evaluations + openings",id:"polynomials-with-per-proof-evaluations--openings",level:4},{value:"Constraints",id:"constraints",level:4},{value:"Drawbacks",id:"drawbacks",level:2},{value:"Rationale and alternatives",id:"rationale-and-alternatives",level:2},{value:"Why is this design the best in the space of possible designs?",id:"why-is-this-design-the-best-in-the-space-of-possible-designs",level:3},{value:"What other designs have been considered and what is the rationale for not choosing them?",id:"what-other-designs-have-been-considered-and-what-is-the-rationale-for-not-choosing-them",level:3},{value:"What is the impact of not doing this?",id:"what-is-the-impact-of-not-doing-this",level:3},{value:"Prior art",id:"prior-art",level:2},{value:"Unresolved questions",id:"unresolved-questions",level:2},{value:"What parts of the design do you expect to resolve through the RFC process before this gets merged?",id:"what-parts-of-the-design-do-you-expect-to-resolve-through-the-rfc-process-before-this-gets-merged",level:3},{value:"What parts of the design do you expect to resolve through the implementation of this feature before merge?",id:"what-parts-of-the-design-do-you-expect-to-resolve-through-the-implementation-of-this-feature-before-merge",level:3},{value:"What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?",id:"what-related-issues-do-you-consider-out-of-scope-for-this-rfc-that-could-be-addressed-in-the-future-independently-of-the-solution-that-comes-out-of-this-rfc",level:3}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"extended-lookup-tables",children:"Extended lookup tables"})}),"\n",(0,o.jsx)(n.p,{children:"This (old) RFC proposes an extension to our use of lookup tables using the\nPLOOKUP multiset inclusion argument, so that values within lookup tables can be\nchosen after the constraint system for a circuit has been fixed."}),"\n",(0,o.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,o.jsx)(n.p,{children:"This extension should provide us with"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["array-style lookups (",(0,o.jsx)(n.code,{children:"arr[i]"}),", where ",(0,o.jsx)(n.code,{children:"arr"})," and ",(0,o.jsx)(n.code,{children:"i"})," are formed of values in the\nproof witness)."]}),"\n",(0,o.jsx)(n.li,{children:"the ability to load 'bytecode' using a proof-independent commitment."}),"\n",(0,o.jsx)(n.li,{children:"the ability to load tables of arbitrary data for use in the circuit, allowing\ne.g. the full data of a HTTPS transcript to be entered into a proof without\nusing some in-circuit commitment."}),"\n",(0,o.jsx)(n.li,{children:"the ability to expose tables of arbitrary in-circuit data, for re-use by other\nproofs."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These goals support 5 major use-cases:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["allow the verifier circuit to support 'custom' or user-specified gates\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"using array indexing, the use of constants and commitments/evaluations can\nbe determined by the verifier index, instead of being fixed by the\npermutation argument as currently."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"allow random-access lookups in arrays as a base-primitive for user programs"}),"\n",(0,o.jsxs)(n.li,{children:["allow circuits to use low-cost branching and other familiar programming\nprimitives\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"this depends on the development of a bytecode interpreter on top of the\nlookup-table primitives, where the values in the table represent the\nbytecode of the instructions."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["allow circuits to load and execute some 'user provided' bytecode\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"e.g. to run a small bytecode program provided in a transaction at\nblock-production time."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"allow zkOracles to load a full HTTPS transcript without using an expensive\nin-circuit commitment."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"detailed-design",children:"Detailed design"}),"\n",(0,o.jsx)(n.p,{children:"In order to support the desired goals, we first define 3 types of table:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"fixed tables"})," are tables declared as part of the constraint system, and are\nthe same for every proof of that circuit."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"runtime tables"})," are tables whose contents are determined at proving time,\nto be used for array accesses to data from the witness. Also called dynamic\ntables in other projects."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"side-loaded tables"})," are tables that are committed to in a proof-independent\nway, so that they may be reused across proofs and/or signed without knowledge\nof the specific proof, but may be different for each execution of the circuit."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["These distinct types of tables are a slight fiction: often it will be desirable\nto have some fixed part of runtime or side-loaded tables, e.g. to ensure that\nindexing is reliable. For example, a table representing an array of values\n",(0,o.jsx)(n.code,{children:"[x, y, z]"})," in the proof might be laid out as"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"value1"}),(0,o.jsx)(n.th,{children:"value2"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"0"}),(0,o.jsx)(n.td,{children:"?runtime"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"1"}),(0,o.jsx)(n.td,{children:"?runtime"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"2"}),(0,o.jsx)(n.td,{children:"?runtime"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["where the ",(0,o.jsx)(n.code,{children:"value1"})," entries are fixed in the constraint system. This ensure that\na malicious prover is not free to create multiple values with the same index,\nsuch as ",(0,o.jsx)(n.code,{children:"[(0,a), (0,x), (1,y), (2,z)]"}),", otherwise the value ",(0,o.jsx)(n.code,{children:"a"})," might be used\nwhere the value ",(0,o.jsx)(n.code,{children:"x"})," was intended."]}),"\n",(0,o.jsx)(n.h3,{id:"combining-multiple-tables",children:"Combining multiple tables"}),"\n",(0,o.jsx)(n.p,{children:"The current implementation only supports a single fixed table. In order to make\nmultiple tables available, we either need to run a separate PLOOKUP argument for\neach table, or to concatenate the tables to form an combined table and identify\nthe values from each table in such a way that the prover cannot use values from\nthe 'wrong' table."}),"\n",(0,o.jsxs)(n.p,{children:["We already solve a similar problem with 'vector' tables -- tables where a row\ncontains multiple values -- where we want to ensure that the prover used an\nentry ",(0,o.jsx)(n.code,{children:"(x, y, z)"})," from the table, and not some parts of different entries, or\nsome other value entirely. In order to do this, we generate a randomising field\nelement ",(0,o.jsx)(n.code,{children:"joint_combiner"}),", where the randomness depends on the circuit witness,\nand then compute ",(0,o.jsx)(n.code,{children:"x + y * joint_combiner + z * joint_combiner^2"}),". Notice that,\nif the prover wants to select some ",(0,o.jsx)(n.code,{children:"(a, b, c)"})," not in the table and claim that\nit in fact was, they are not able to use the knowledge of the ",(0,o.jsx)(n.code,{children:"joint_combiner"}),"\nto choose their ",(0,o.jsx)(n.code,{children:"(a, b, c)"}),", since the ",(0,o.jsx)(n.code,{children:"joint_combiner"})," will depend on those\nvalues ",(0,o.jsx)(n.code,{children:"a"}),", ",(0,o.jsx)(n.code,{children:"b"}),", and ",(0,o.jsx)(n.code,{children:"c"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"This is a standard technique for checking multiple equalities at once by\nchecking a single equality; to use it, we must simply ensure that the randomness\ndepends on all of the (non-constant) values in the equality."}),"\n",(0,o.jsxs)(n.p,{children:["We propose extending each table with an extra column, which we will call the\n",(0,o.jsx)(n.code,{children:"TableID"})," column, which associates a different number with each table. Since the\nsizes of all tables must be known at constraint system time, we can treat this\nas a fixed column. For example, this converts a lookup ",(0,o.jsx)(n.code,{children:"(a, b, c)"})," in the table\nwith ID ",(0,o.jsx)(n.code,{children:"1"})," into a lookup of ",(0,o.jsx)(n.code,{children:"(a, b, c, 1)"})," in the combined table, and ensures\nthat any value ",(0,o.jsx)(n.code,{children:"(x, y, z)"})," from table ID ",(0,o.jsx)(n.code,{children:"2"})," will not match that lookup, since\nits representative is ",(0,o.jsx)(n.code,{children:"(x, y, z, 2)"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["To avoid any interaction between the ",(0,o.jsx)(n.code,{children:"TableID"})," column and any other data in the\ntables, we use ",(0,o.jsx)(n.code,{children:"TableID * joint_combiner^max_joint_size"})," to mix in the\n",(0,o.jsx)(n.code,{children:"TableID"}),", where ",(0,o.jsx)(n.code,{children:"max_joint_size"})," is the maximum length of any lookup or table\nvalue. This also simplifies the 'joining' of the ",(0,o.jsx)(n.code,{children:"table_id"})," polynomial\ncommitment, since we can straightforwardly scale it by the constant\n",(0,o.jsx)(n.code,{children:"joint_combiner^max_joint_size"})," to find its contribution to every row in the\ncombined table."]}),"\n",(0,o.jsxs)(n.h3,{id:"sampling-the-joint_combiner",children:["Sampling the ",(0,o.jsx)(n.code,{children:"joint_combiner"})]}),"\n",(0,o.jsxs)(n.p,{children:["Currently, the ",(0,o.jsx)(n.code,{children:"joint_combiner"})," is sampled using randomness that depends on the\nwitness. However, where we have runtime or side-loaded tables, a malicious\nprover may be able to select values in those tables that abuse knowledge of\n",(0,o.jsx)(n.code,{children:"joint_combiner"})," to create collisions."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, the prover could create the appearance that there is a value\n",(0,o.jsx)(n.code,{children:"(x, y, z)"})," in the table with ID 1 by entering a single value ",(0,o.jsx)(n.code,{children:"a"})," into the table\nwith ID 2, by computing"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"a =   x\n    + y * joint_combiner\n    + z * joint_combiner^2\n    + -1 * joint_combiner^max_joint_size\n"})}),"\n",(0,o.jsx)(n.p,{children:"so that the combined contribution with its table ID becomes"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"a + 2 * joint_combiner^max_joint_size\n"})}),"\n",(0,o.jsxs)(n.p,{children:["and thus matches exactly the combined value from ",(0,o.jsx)(n.code,{children:"(x, y, z)"})," in the table with\nID 1:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"x + y * joint_combiner + z * joint_combiner^2 + 1 * joint_combiner^max_joint_size\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Thus, we need to ensure that the ",(0,o.jsx)(n.code,{children:"joint_combiner"})," depends on the values in\nruntime or side-loaded tables, so that the values in these tables cannot be\nchosen using knowledge of the ",(0,o.jsx)(n.code,{children:"joint_combiner"}),". To do this, we must use the\ncommitments to the values in these tables as part of the source of randomness\nfor ",(0,o.jsx)(n.code,{children:"joint_combiner"})," in the prover and verifier."]}),"\n",(0,o.jsx)(n.p,{children:"In particular, this means that we must have a commitment per column for each\ntype of table, so that the verifier can confirm the correct construction of the\ncombined table."}),"\n",(0,o.jsx)(n.p,{children:"As usual, we will use the 'transcript' of the proof so far -- including all of\nthese components -- as the seed for this randomness."}),"\n",(0,o.jsx)(n.h3,{id:"representing-the-combined-fixed-table",children:"Representing the combined fixed table"}),"\n",(0,o.jsx)(n.p,{children:"The fixed table can be constructed at constraint system generation time, by\nextending all of the constituent tables to the same width (i.e. number of\ncolumns), generating the appropriate table IDs array, and concatenating all of\nthe tables. Concretely:"}),"\n",(0,o.jsxs)(n.p,{children:["Let ",(0,o.jsx)(n.code,{children:"t[id][row][col]"})," be the ",(0,o.jsx)(n.code,{children:"col"}),"th element of the ",(0,o.jsx)(n.code,{children:"row"}),"th entry in the ",(0,o.jsx)(n.code,{children:"id"}),"th\nfixed table. Let ",(0,o.jsx)(n.code,{children:"W"})," be the maximum width of all of the ",(0,o.jsx)(n.code,{children:"t[id][row]"}),"s. For any\n",(0,o.jsx)(n.code,{children:"t[id][row]"})," whose width ",(0,o.jsx)(n.code,{children:"w"})," is less than ",(0,o.jsx)(n.code,{children:"W"}),", pad it to width ",(0,o.jsx)(n.code,{children:"W"})," by setting\n",(0,o.jsx)(n.code,{children:"t[id][row][col] = 0"})," for all ",(0,o.jsx)(n.code,{children:"w < col <= W"}),". Form the combined table by\nconcatenating all of these tables ",(0,o.jsx)(n.code,{children:"FixedTable = t[0] || t[1] || t[2] || ..."})," and\nstore in ",(0,o.jsx)(n.code,{children:"TableID"})," the table ID that the corresponding row came from. Then, for\nevery ",(0,o.jsx)(n.code,{children:"output_row"}),", we have"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"FixedTable[output_row][col] = t[id][row][col]`\nTableID[output_row] = id\nwhere output_row = len(t[0]) + len(t[1]) + ... + len(t[id-1]) + row\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This can be encoded as ",(0,o.jsx)(n.code,{children:"W+1"})," polynomials in the constraint system, which we will\nreference as ",(0,o.jsx)(n.code,{children:"FixedTable(col)"})," for ",(0,o.jsx)(n.code,{children:"0 <= col < W"})," and ",(0,o.jsx)(n.code,{children:"TableID"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For any unused entries, we use ",(0,o.jsx)(n.code,{children:"TableID = -1"}),", to avoid collisions with any\ntables."]}),"\n",(0,o.jsx)(n.h3,{id:"representing-the-runtime-table",children:"Representing the runtime table"}),"\n",(0,o.jsx)(n.p,{children:"The runtime table can be considered as a 'mask' that we apply to the fixed table\nto introduce proof-specific data at runtime."}),"\n",(0,o.jsxs)(n.p,{children:["We make the simplifying assumption that an entry in the runtime table has\nexactly 1 'fixed' entry, which can be used for indexing (or set to ",(0,o.jsx)(n.code,{children:"0"})," if\nunused), and that the table has a fixed width of ",(0,o.jsx)(n.code,{children:"X"}),". We can pad any narrower\nentries in the table to the full width ",(0,o.jsx)(n.code,{children:"X"})," in the same way as the fixed tables\nabove."]}),"\n",(0,o.jsxs)(n.p,{children:["We represent the masked values in the runtime table as ",(0,o.jsx)(n.code,{children:"RuntimeTable(i)"})," for\n",(0,o.jsx)(n.code,{children:"1 <= i < X"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["To specify whether a runtime table entry is applicable in the ",(0,o.jsx)(n.code,{children:"i"}),"th row, we use\na selector polynomial ",(0,o.jsx)(n.code,{children:"RuntimeTableSelector"}),". In order to reduce the polynomial\ndegree of later checks, we add a constraint to check that the runtime entry is\nthe zero vector wherever the selector is zero:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"RuntimeTableSelector * sum[i=1, X, RuntimeTable(i) * joint_combiner^i]\n = sum[i=1, X, RuntimeTable(i) * joint_combiner^i]\n"})}),"\n",(0,o.jsx)(n.p,{children:"This gives the combined entry of the fixed and runtime tables as"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"sum[i=0, W, FixedTable(i) * joint_combiner^i]\n+ sum[i=1, X, RuntimeTable(i) * joint_combiner^i]\n+ TableID * joint_combiner^max_joint_size\n"})}),"\n",(0,o.jsxs)(n.p,{children:["where we assume that ",(0,o.jsx)(n.code,{children:"RuntimeTableSelector * FixedTable(i) = 0"})," for ",(0,o.jsx)(n.code,{children:"1 <= i < W"}),"\nvia our simplifying assumption above. We compute this as a polynomial\n",(0,o.jsx)(n.code,{children:"FixedAndRuntimeTable"}),", giving its evaluations and openings as part of the\nproof, and asserting that each entry matches the above."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"RuntimeTableSelector"})," polynomial will be fixed at constraint system time,\nand we can avoid opening it. However, we must provide openings for\n",(0,o.jsx)(n.code,{children:"RuntimeTable(i)"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"joint_combiner"})," should be sampled using randomness that depends on the\nindividual ",(0,o.jsx)(n.code,{children:"RuntimeTable(i)"}),"s, to ensure that the runtime values cannot be\nchosen with prior knowledge ",(0,o.jsx)(n.code,{children:"joint_combiner"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"representing-the-side-loaded-tables",children:"Representing the side-loaded tables"}),"\n",(0,o.jsx)(n.p,{children:"The side-loaded tables can be considered as additional 'masks' that we apply to\nthe combined fixed and runtime table, to introduce this side-loaded data."}),"\n",(0,o.jsxs)(n.p,{children:["Again, we make the simplifying assumption that an entry from a side-loaded table\nhas exactly 1 'fixed' entry, which can be used for indexing (or set to ",(0,o.jsx)(n.code,{children:"0"})," if\nunused). We also assume that at most 1 side-loaded table contributes to each\nentry."]}),"\n",(0,o.jsxs)(n.p,{children:["In order to compute the lookup multiset inclusion argument, we also need the\ncombined table of all 3 table kinds, which we will call ",(0,o.jsx)(n.code,{children:"LookupTable"}),". We can\ncalculate the contribution of the side-loaded table for each lookup as"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"LookupTable - FixedAndRuntimeTable\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We will represent the polynomials for the side-loaded tables as\n",(0,o.jsx)(n.code,{children:"SideLoadedTable(i, j)"}),", where ",(0,o.jsx)(n.code,{children:"i"})," identifies the table, and ",(0,o.jsx)(n.code,{children:"j"})," identifies the\ncolumn within that table. We also include polynomials ",(0,o.jsx)(n.code,{children:"SideLoadedCombined(i)"})," in\nthe proof, along with their openings, where"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"SideLoadedCombined(i)\n  = sum[j=1, ?, SideLoadedTable(i, j) * joint_combiner^(j-1)]\n"})}),"\n",(0,o.jsx)(n.p,{children:"and check for consistency of the evaluations and openings when verifying the\nproof."}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"SideLoadedTable"})," polynomials are included in the proof, but we do so 'as\nif' they had been part of the verification index (ie. without any proof-specific\nopenings), so that they may be reused across multiple different proofs without\nmodification."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"joint_combiner"})," should be sampled using randomness that depends on the\nindividual ",(0,o.jsx)(n.code,{children:"SideLoadedTable(i,j)"}),"s, to ensure that the side-loaded values cannot\nbe chosen with prior knowledge ",(0,o.jsx)(n.code,{children:"joint_combiner"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["Note: it may be useful for the verifier to pass the ",(0,o.jsx)(n.code,{children:"SideLoadedTable(i,j)"}),"s as\npublic inputs to the proof, so that the circuit may assert that the table it had\nside-loaded was signed or otherwise correlated with a cryptographic commitment\nthat it had access to. The details of this are deliberately elided in this RFC,\nsince the principle and implementation are both fairly straightforward."]})}),"\n",(0,o.jsx)(n.h3,{id:"position-independence-of-side-loaded-tables",children:"Position-independence of side-loaded tables"}),"\n",(0,o.jsxs)(n.p,{children:["We want to ensure that side-loaded tables are maximally re-usable across\ndifferent proofs, even where the 'position' of the same side-loaded table in the\ncombined table may vary between proofs. For example, we could consider a\n'folding' circuit ",(0,o.jsx)(n.code,{children:"C"})," which takes 2 side-loaded tables ",(0,o.jsx)(n.code,{children:"t_in"})," and ",(0,o.jsx)(n.code,{children:"t_out"}),", where\nwe prove"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"C(t_0, t_1)\nC(t_1, t_2)\nC(t_2, t_3)\n...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["and the 'result' of the fold is the final ",(0,o.jsx)(n.code,{children:"t_n"}),". In each pair of executions in\nthe sequence, we find that ",(0,o.jsx)(n.code,{children:"t_i"})," is used as both ",(0,o.jsx)(n.code,{children:"t_in"})," and ",(0,o.jsx)(n.code,{children:"t_out"}),", but we\nwould like to expose the same table as the value for each."]}),"\n",(0,o.jsx)(n.p,{children:"To achieve this, we use a permutation argument to 'place' the values from each\nside-loaded table at the correct position in the final table. Recall that every\nvalue"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"LookupTable - FixedAndRuntimeTable\n"})}),"\n",(0,o.jsxs)(n.p,{children:["is either 0 (where no side-loaded table contributes a value) or the value of\nsome row in ",(0,o.jsx)(n.code,{children:"SideLoadedCombined(i) * joint_combiner"})," from the table ",(0,o.jsx)(n.code,{children:"i"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For the ",(0,o.jsx)(n.code,{children:"0"})," differences, we calculate a permutation between them all and the\nsingle constant ",(0,o.jsx)(n.code,{children:"0"}),", to ensure that ",(0,o.jsx)(n.code,{children:"LookupTable = FixedAndRuntimeTable"}),". For\nall other values, we set-up a permutation based upon the side-loaded table\nrelevant to each value."]}),"\n",(0,o.jsx)(n.p,{children:"Thus, we build the permutation accumulator"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"LookupPermutation\n * ((LookupTable - FixedAndRuntimeTable) * joint_combiner^(-1)\n     + gamma + beta * Sigma(7))\n * (SideLoadedCombined(0) + gamma + beta * Sigma(8))\n * (SideLoadedCombined(1) + gamma + beta * Sigma(9))\n * (SideLoadedCombined(2) + gamma + beta * Sigma(10))\n * (SideLoadedCombined(3) + gamma + beta * Sigma(11))\n =\n   LookupPermutation[prev]\n   * ((LookupTable - FixedAndRuntimeTable) * joint_combiner^(-1)\n       + gamma + x * beta * shift[7])\n   * (SideLoadedCombined(0) + gamma + x * beta * shift[8])\n   * (SideLoadedCombined(1) + gamma + x * beta * shift[9])\n   * (SideLoadedCombined(2) + gamma + x * beta * shift[10])\n   * (SideLoadedCombined(3) + gamma + x * beta * shift[11])\n"})}),"\n",(0,o.jsxs)(n.p,{children:["where ",(0,o.jsx)(n.code,{children:"shift[0..7]"})," is the existing ",(0,o.jsx)(n.code,{children:"shift"})," vector used for the witness\npermutation, and the additional values above are chosen so that ",(0,o.jsx)(n.code,{children:"shift[i] * w^j"}),"\nare distinct for all ",(0,o.jsx)(n.code,{children:"i"})," and ",(0,o.jsx)(n.code,{children:"j"}),", and ",(0,o.jsx)(n.code,{children:"Sigma(_)"})," are the columns representing\nthe permutation. We then assert that"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Lagrange(0)\n  * (LookupPermutation * (0 + gamma + beta * zero_sigma)\n    - (0 + gamma + beta * shift[len(shift)-1]))\n  = 0\n"})}),"\n",(0,o.jsxs)(n.p,{children:["to mix in the contributions for the constant ",(0,o.jsx)(n.code,{children:"0"})," value, and"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Lagrange(n-ZK_ROWS) * (LookupPermutation - 1) = 0\n"})}),"\n",(0,o.jsx)(n.p,{children:"to ensure that the permuted values cancel."}),"\n",(0,o.jsxs)(n.p,{children:["Note also that the permutation argument allows for interaction ",(0,o.jsx)(n.strong,{children:"between"}),"\ntables, as well as injection of values into the combined lookup table. As a\nresult, the permutation argument can be used to 'copy' parts of one table into\nanother, which is likely to be useful in examples like the 'fold' one above, if\nsome data is expected to be shared between ",(0,o.jsx)(n.code,{children:"t_in"})," and ",(0,o.jsx)(n.code,{children:"t_out"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"permutation-argument-for-cheap-array-lookups",children:"Permutation argument for cheap array lookups"}),"\n",(0,o.jsxs)(n.p,{children:["It would be useful to add data to the runtime table using the existing\npermutation arguments rather than using a lookup to 'store' data. In particular,\nthe polynomial degree limits the number of lookups available per row, but we are\nable to assert equalities on all 7 permuted witness columns using the existing\nargument. By combining the existing ",(0,o.jsx)(n.code,{children:"PermutationAggreg"})," with\n",(0,o.jsx)(n.code,{children:"LookupPermutation"}),", we can allow all of these values to interact."]}),"\n",(0,o.jsx)(n.p,{children:"Concretely, by involving the original aggregation and the first row of the\nruntime table, we can construct the permutation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"LookupPermutation\n * PermutationAggreg\n * ((LookupTable - FixedAndRuntimeTable) * joint_combiner^(-1)\n     + gamma + beta * Sigma(7))\n * (SideLoadedCombined(0) + gamma + beta * Sigma(8))\n * (SideLoadedCombined(1) + gamma + beta * Sigma(9))\n * (SideLoadedCombined(2) + gamma + beta * Sigma(10))\n * (SideLoadedCombined(3) + gamma + beta * Sigma(11))\n * (RuntimeTable(1) + gamma + beta * Sigma(12))\n =\n   LookupPermutation[prev]\n   * PermutationAggreg[prev]\n   * ((LookupTable - FixedAndRuntimeTable) * joint_combiner^(-1)\n       + gamma + x * beta * shift[7])\n   * (SideLoadedCombined(0) + gamma + x * beta * shift[8])\n   * (SideLoadedCombined(1) + gamma + x * beta * shift[9])\n   * (SideLoadedCombined(2) + gamma + x * beta * shift[10])\n   * (SideLoadedCombined(3) + gamma + x * beta * shift[11])\n   * (RuntimeTable(1) + gamma + x * beta * shift[12])\n"})}),"\n",(0,o.jsxs)(n.p,{children:["to allow interaction between any of the first 7 witness rows and the first row\nof the runtime table. Note that the witness rows can only interact with the\nside-loaded tables when they contain a single entry due to their use of\n",(0,o.jsx)(n.code,{children:"joint_combiner"})," for subsequent entries, which is sampled using randomness that\ndepends on this witness."]}),"\n",(0,o.jsx)(n.p,{children:"In order to check the combined permutation, we remove the final check from the\nexisting permutation argument and compute the combined check of both permutation\narguments:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Lagrange(n-ZK_ROWS) * (LookupPermutation * PermutationAggreg - 1) = 0\n"})}),"\n",(0,o.jsx)(n.h3,{id:"full-list-of-polynomials-and-constraints",children:"Full list of polynomials and constraints"}),"\n",(0,o.jsx)(n.h4,{id:"constants",children:"Constants"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"shift[0..14]"})," (",(0,o.jsx)(n.code,{children:"shift[0..7]"})," existing)"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"zero_sigma"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"joint_combiner"})," (existing)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"beta"})," (existing)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"gamma"})," (existing)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"max_joint_size"})," (existing, integer)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This results in 8 new constants."}),"\n",(0,o.jsx)(n.h4,{id:"polynomials-without-per-proof-evaluations",children:"Polynomials without per-proof evaluations"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"TableID"})," (verifier index)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"FixedTable(i)"})," (verifier index, existing)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"RuntimeTableSelector"})," (verifier index)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"SideLoadedTable(i, j)"})," (proof)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This results in 2 new polynomials + 1 new polynomial for each column of each\nside-loaded table."}),"\n",(0,o.jsx)(n.h4,{id:"polynomials-with-per-proof-evaluations--openings",children:"Polynomials with per-proof evaluations + openings"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"LookupTable"})," (existing)"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"RuntimeTable(i)"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"FixedAndRuntimeTable"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"PermutationAggreg"})," (existing)"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"LookupPermutation"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Sigma(i)"})," (existing for ",(0,o.jsx)(n.code,{children:"0 <= i < 7"}),", new for ",(0,o.jsx)(n.code,{children:"7 <= i < 13"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This results in 8 new polynomial evaluations + 1 new evaluation for each column\nof the runtime table."}),"\n",(0,o.jsx)(n.h4,{id:"constraints",children:"Constraints"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["permutation argument (existing, remove ",(0,o.jsx)(n.code,{children:"n-ZK_ROWS"})," check) (elided)"]}),"\n",(0,o.jsx)(n.li,{children:"lookup argument (existing) (elided)"}),"\n",(0,o.jsxs)(n.li,{children:["runtime-table consistency\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"RuntimeTableSelector * sum[i=1, X, RuntimeTable(i) * joint_combiner^i]\n = sum[i=1, X, RuntimeTable(i) * joint_combiner^i]\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["fixed and runtime table evaluation\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"FixedAndRuntimeTable\n  = sum[i=0, W, FixedTable(i) * joint_combiner^i]\n    + sum[i=1, X, RuntimeTable(i) * joint_combiner^i]\n    + TableID * joint_combiner^max_joint_size\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["lookup permutation argument\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"LookupPermutation\n * PermutationAggreg\n * ((LookupTable - FixedAndRuntimeTable) * joint_combiner^(-1)\n     + gamma + beta * Sigma(7))\n * (SideLoadedCombined(0) + gamma + beta * Sigma(8))\n * (SideLoadedCombined(1) + gamma + beta * Sigma(9))\n * (SideLoadedCombined(2) + gamma + beta * Sigma(10))\n * (SideLoadedCombined(3) + gamma + beta * Sigma(11))\n * (RuntimeTable(1) + gamma + beta * Sigma(12))\n =\n   LookupPermutation[prev]\n   * PermutationAggreg[prev]\n   * ((LookupTable - FixedAndRuntimeTable) * joint_combiner^(-1)\n       + gamma + x * beta * shift[7])\n   * (SideLoadedCombined(0) + gamma + x * beta * shift[8])\n   * (SideLoadedCombined(1) + gamma + x * beta * shift[9])\n   * (SideLoadedCombined(2) + gamma + x * beta * shift[10])\n   * (SideLoadedCombined(3) + gamma + x * beta * shift[11])\n   * (RuntimeTable(1) + gamma + x * beta * shift[12])\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["lookup permutation initializer\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Lagrange(0)\n  * (LookupPermutation * (0 + gamma + beta * zero_sigma)\n    - (0 + gamma + beta * shift[len(shift)-1]))\n  = 0\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["lookup permutation finalizer\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Lagrange(n-ZK_ROWS) * (LookupPermutation - 1) = 0\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This results in 5 new checks, and the removal of 1 old check."}),"\n",(0,o.jsx)(n.p,{children:"The lookup permutation argument (and its columns) can be elided when it is\nunused by either the side-loaded table or the runtime table. Similarly, the\nruntime table checks (and columns) can be omitted when there is no runtime\ntable."}),"\n",(0,o.jsx)(n.h2,{id:"drawbacks",children:"Drawbacks"}),"\n",(0,o.jsx)(n.p,{children:"This proposal increases the size of proofs, and increases the number of checks\nthat the verifier must perform, and thus the cost of the recusive verifier. This\nalso increases the complexity of the proof system."}),"\n",(0,o.jsx)(n.h2,{id:"rationale-and-alternatives",children:"Rationale and alternatives"}),"\n",(0,o.jsx)(n.h3,{id:"why-is-this-design-the-best-in-the-space-of-possible-designs",children:"Why is this design the best in the space of possible designs?"}),"\n",(0,o.jsxs)(n.p,{children:["This design combines the 3 different 'modes' of random access memory, roughly\napproximating ",(0,o.jsx)(n.code,{children:"ROM -> RAM"})," loading, ",(0,o.jsx)(n.code,{children:"disk -> RAM"})," loading, and ",(0,o.jsx)(n.code,{children:"RAM r/w"}),". This\ngives the maximum flexibility for circuit designers, and each primitive has uses\nfor projects that we are pursuing."]}),"\n",(0,o.jsx)(n.p,{children:"This design has been refined over several iterations to reduce the number of\ncomponents exposed in the proof and the amount of computation that the verifier\nrequires. The largest remaining parts represent the data itself and the method\nfor combining them, where simplifying assumptions have been made to minimize\ntheir impact while still satisfying the design constraints."}),"\n",(0,o.jsx)(n.h3,{id:"what-other-designs-have-been-considered-and-what-is-the-rationale-for-not-choosing-them",children:"What other designs have been considered and what is the rationale for not choosing them?"}),"\n",(0,o.jsx)(n.p,{children:"Other designs building upon the lookup primitive reduce on some subset of this\ndesign, or on relaxing a design constraint that would remove some useful /\nrequired functionality."}),"\n",(0,o.jsx)(n.h3,{id:"what-is-the-impact-of-not-doing-this",children:"What is the impact of not doing this?"}),"\n",(0,o.jsx)(n.p,{children:"We are currently unable to expose certain useful functionality to users of\nSnapps / SnarkyJS, and are missing the ability to use that same functionality\nfor important parts of the zkOracles ecosystem (such as parsing / scraping)."}),"\n",(0,o.jsx)(n.p,{children:"We also are currently forced to hard-code any constraints that we need for\nparticular uses in the verifier circuit, and users are unable to remove the\nparts they do not need and to replace them with other useful constraints that\ntheir circuits might benefit from."}),"\n",(0,o.jsx)(n.p,{children:"The Mina transaction model is unable to support a bytecode interpreter without\nthis or similar extensions."}),"\n",(0,o.jsx)(n.h2,{id:"prior-art",children:"Prior art"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"(Elided)"})}),"\n",(0,o.jsx)(n.h2,{id:"unresolved-questions",children:"Unresolved questions"}),"\n",(0,o.jsx)(n.h3,{id:"what-parts-of-the-design-do-you-expect-to-resolve-through-the-rfc-process-before-this-gets-merged",children:"What parts of the design do you expect to resolve through the RFC process before this gets merged?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The maximum number of tables / entries of each kind that we want to support in\nthe 'standard' protocol."}),"\n",(0,o.jsx)(n.li,{children:"Validation (or rejection) of the simplifying assumptions."}),"\n",(0,o.jsx)(n.li,{children:"Confirmation of the design constraints, or simplifications thereto."}),"\n",(0,o.jsx)(n.li,{children:"Necessity / utility of the permutation argument."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"what-parts-of-the-design-do-you-expect-to-resolve-through-the-implementation-of-this-feature-before-merge",children:"What parts of the design do you expect to resolve through the implementation of this feature before merge?"}),"\n",(0,o.jsx)(n.p,{children:"None, this RFC has been developed in part from an initial design and iteration\non implementations of parts of that design."}),"\n",(0,o.jsx)(n.h3,{id:"what-related-issues-do-you-consider-out-of-scope-for-this-rfc-that-could-be-addressed-in-the-future-independently-of-the-solution-that-comes-out-of-this-rfc",children:"What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Bytecode design and implementation details."}),"\n",(0,o.jsx)(n.li,{children:"Mina transaction interface for interacting with these features."}),"\n",(0,o.jsx)(n.li,{children:"Snarky / SnarkyJS interface for interacting with these features."}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);