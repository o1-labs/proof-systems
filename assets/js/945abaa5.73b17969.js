"use strict";(globalThis.webpackChunkmina_book=globalThis.webpackChunkmina_book||[]).push([[5251],{83(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"kimchi/arguments","title":"Arguments","description":"In the previous section we saw how we can prove that certain equations hold for","source":"@site/docs/kimchi/arguments.md","sourceDirName":"kimchi","slug":"/kimchi/arguments","permalink":"/proof-systems/kimchi/arguments","draft":false,"unlisted":false,"editUrl":"https://github.com/o1-labs/proof-systems/tree/master/book/docs/kimchi/arguments.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/proof-systems/kimchi/overview"},"next":{"title":"Understanding the implementation of the $f(\\\\zeta) = Z_H(\\\\zeta) t(\\\\zeta)$ check","permalink":"/proof-systems/kimchi/final_check"}}');var a=n(4848),i=n(8453);const r={},o="Arguments",c={},h=[];function l(e){const t={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",header:"header",img:"img",math:"math",mi:"mi",mn:"mn",mrow:"mrow",p:"p",semantics:"semantics",span:"span",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"arguments",children:"Arguments"})}),"\n",(0,a.jsx)(t.p,{children:"In the previous section we saw how we can prove that certain equations hold for\na given set of numbers very efficiently. What's left to understand is the\nmotivation behind these techniques. Why is it so important that we can perform\nthese operations and what do these equations represent in the real world?"}),"\n",(0,a.jsxs)(t.p,{children:["But first, let's recall the table that summarizes some important notation that\nwill be used extensively: ",(0,a.jsx)(t.img,{alt:"kimchi",src:n(4996).A+"",width:"2534",height:"472"})]}),"\n",(0,a.jsxs)(t.p,{children:["One of the first ideas that we must grasp is the notion of a ",(0,a.jsx)(t.strong,{children:"circuit"}),". A\ncircuit can be thought of as a set of gates with wires connections between them.\nThe simplest type of circuit that one could think of is a boolean circuit.\nBoolean circuits only have binary values: ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mn,{children:"1"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"1"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(t.span,{className:"mord",children:"1"})]})})]})," and ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mn,{children:"0"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"0"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(t.span,{className:"mord",children:"0"})]})})]}),", ",(0,a.jsx)(t.code,{children:"true"})," and ",(0,a.jsx)(t.code,{children:"false"}),". From\na very high level, boolean circuits are like an intricate network of pipes, and\nthe values could be seen as ",(0,a.jsx)(t.em,{children:"water"})," or ",(0,a.jsx)(t.em,{children:"no water"}),". Then, gates will be like\nstopcocks, making water flow or not between the pipes.\n",(0,a.jsx)(t.a,{href:"https://twitter.com/i/status/1188749430020698112",children:"This video"})," is a cool\nrepresentation of this idea. Then, each of these ",(0,a.jsx)(t.em,{children:"behaviours"})," will represent a\ngate (i.e. logic gates). One can have circuits that can perform more operations,\nfor instance arithmetic circuits. Here, the type of gates available will be\narithmetic operations (additions and multiplications) and wires could have\nnumeric values and we could perform any arbitrary computation."]}),"\n",(0,a.jsxs)(t.p,{children:["But if we loop the loop a bit more, we could come up with a single ",(0,a.jsx)(t.code,{children:"Generic"}),"\ngate that could represent any arithmetic operation at once. This thoughtful type\nof gate is the one gate whose concatenation is used in Plonk to describe any\nrelation. Apart from it's wires, these gates are tied to an array of\n",(0,a.jsx)(t.strong,{children:"coefficients"})," that help describe the functionality. But the problem of this\ngate is that it takes a large set of them to represent any meaningful function.\nSo instead, recent Plonk-like proof systems have appeared which use ",(0,a.jsx)(t.strong,{children:"custom\ngates"})," to represent repeatedly used functionalities more efficiently than as a\nseries of generic gates connected to each other. Kimchi is one of these\nprotocols. Currently, we give support to specific gates for the ",(0,a.jsx)(t.code,{children:"Poseidon"})," hash\nfunction, the ",(0,a.jsx)(t.code,{children:"CompleteAdd"})," operation for curve points, ",(0,a.jsx)(t.code,{children:"VarBaseMul"})," for\nvariable base multiplication, ",(0,a.jsx)(t.code,{children:"EndoMulScalar"})," for endomorphism variable base\nscalar multiplication, ",(0,a.jsx)(t.code,{children:"RangeCheck"})," for range checks and ",(0,a.jsx)(t.code,{children:"ForeignFieldMul"})," and\n",(0,a.jsx)(t.code,{children:"ForeignFieldAdd"})," for foreign field arithmetic. Nonetheless, we have plans to\nfurther support many other gates soon, possibly even ",(0,a.jsx)(t.code,{children:"Cairo"})," instructions."]}),"\n",(0,a.jsxs)(t.p,{children:["The circuit structure is known ahead of time, as this is part of the public\ninformation that is shared with the verifier. What is secret is what we call the\n",(0,a.jsx)(t.strong,{children:"witness"})," of the relation, which is the correct instantiation of the wires of\nthe circuit satisfying all of the checks. This means the verifier knows what\ntype of gate appears in each part of the circuit, and the coefficients that are\nattached to each of them."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"execution trace"})," refers to the state of all the wires throughout the\ncircuit, upon instantiation of the witness. It will be represented as a table\nwhere the rows correspond to each gate and the columns refer to the actual wires\nof the gate (a.k.a. ",(0,a.jsx)(t.strong,{children:"input and output registers"}),") and some auxiliary values\nneeded for the computation (a.k.a. ",(0,a.jsx)(t.strong,{children:"advice registers"}),"). The current\nimplementation of Kimchi considers a total of 15 columns with the first 7\ncolumns corresponding to I/O registers. Additionally, gates are allowed to\naccess the elements in the current row ",(0,a.jsx)(t.code,{children:"Curr"})," and the next ",(0,a.jsx)(t.code,{children:"Next"}),". The\npermutation argument acts on the I/O registers (meaning, it will check that the\ncells in the first 7 columns of the execution trace will be ",(0,a.jsx)(t.em,{children:"copied"})," correctly\nto their destination cells). For this reason, these checks are also known as\n",(0,a.jsx)(t.strong,{children:"copy constraints"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Going back to the main motivation of the scheme, recall that we wanted to check\nthat certain equations hold in a given set of numbers. Here's where this claim\nstarts to make sense. The total number of rows in the execution trace will give\nus a ",(0,a.jsx)(t.strong,{children:"domain"}),". That is, we define a mapping between each of the row indices of\nthe execution trace and the elements of a multiplicative group ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mi,{mathvariant:"double-struck",children:"G"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\mathbb{G}"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.6889em"}}),(0,a.jsx)(t.span,{className:"mord mathbb",children:"G"})]})})]})," with\nas many elements as rows in the table. Two things to note here. First, if no\nsuch group exists we can pad with zeroes. Second, any multiplicative group has a\ngenerator ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mi,{children:"g"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"g"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"})]})})]})," whose powers generate the whole group. Then we can assign to each\nrow a power of ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mi,{children:"g"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"g"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"g"})]})})]}),". Why do we want to do this? Because this will be the set over\nwhich we want to check our equations: we can transform a claim about the\nelements of a group to a claim like ",(0,a.jsx)(t.em,{children:'"these properties hold for each of the rows\nof this table"'}),". Interesting, right?"]})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},4996(e,t,n){n.d(t,{A:()=>s});const s=n.p+"assets/images/kimchi-22cf0f3404a6af31df6caef45685f834.png"},8453(e,t,n){n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);