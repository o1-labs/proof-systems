<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a circuit to achieve Incremental Verifiable Computation (IVC) based on a variant of the folding scheme described in the paper Nova. For the rest of the document, we do suppose that the curve is BN254."><title>ivc - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ivc" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0-nightly (d13a431a6 2025-06-09)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ivc/index.html">ivc</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#a-recap-of-the-nova-ivc-scheme" title="A recap of the Nova IVC scheme">A recap of the Nova IVC scheme</a></li><li><a href="#our-design" title="Our design">Our design</a></li><li><a href="#ivc-circuit-base-case" title="IVC circuit: base case">IVC circuit: base case</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>ivc</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ivc/lib.rs.html#1-224">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a circuit to achieve Incremental Verifiable
Computation (IVC) based on a variant of the folding scheme described in the
paper <a href="https://eprint.iacr.org/2021/370.pdf">Nova</a>. For the rest of the
document, we do suppose that the curve is BN254.</p>
<p>Note that in the rest of this document, we will mix the terms
“relaxation/relaxed” with “homogeneisation/homogeneous” polynomials. The
reason is explained in the [folding] library. The term “running relaxed
instance” can be rephrased as “an accumulator of evaluations of the
homogeneised polynomials describing the computation and commitments to them”.</p>
<h3 id="a-recap-of-the-nova-ivc-scheme"><a class="doc-anchor" href="#a-recap-of-the-nova-ivc-scheme">§</a>A recap of the Nova IVC scheme</h3>
<p>The <a href="https://eprint.iacr.org/2021/370.pdf">Nova paper</a> describes a IVC
scheme to be used by the folding scheme described in the same paper.</p>
<p>The IVC scheme uses different notations for different concepts:</p>
<ul>
<li><code>F</code> is the function to be computed. In our codebase, we call it the
“application circuit”.</li>
<li><code>F'</code> is the augmented function with the verifier computation. In our
codebase, we call it the “IVC circuit + APP circuit”, or also the “joint
circuit”.</li>
<li><code>U_i</code> is the accumulator of the function <code>F'</code> up to step <code>i</code>. For clarity,
we will sometimes use the notation <code>acc_i</code> to denote the accumulator. The
accumulator in the [folding] library is called the “left instance”. It is a
“running relaxed instance”.</li>
<li><code>u_i</code> is the current instance of the function <code>F'</code> to be folded into the
accumulator. In the [folding] library, it is called the “right instance”.</li>
<li><code>U_(i + 1)</code> is the accumulator of the function <code>F'</code> up to step <code>i + 1</code>,
i.e. the accumulation of <code>U_i</code> and <code>u_i</code>. In the [folding] library, it is
called the “output instance” or the “folded output”. The “folded output” and
the “left instance” should be seen as both accumulators, and the right
instance should be seen as the difference between both.</li>
</ul>
<p>The IVC scheme described in Fig 4 works as follow, for a given step <code>i</code>:</p>
<ul>
<li>In the circuit (or also called “the augmented function <code>F'</code>”), the prover
will compute a hash of the left instance <code>acc_i</code>. It is a way to “compress”
the information of the previous computation. It is described by the notation
<code>u_i.x ?= Hash(i, z0, zi, U_i)</code> in the Fig 4 on the left.
The value <code>u_i.x</code> is provided as a public input to the circuit. In the code,
we could summarize with the following pseudo code:<div class="example-wrap"><pre class="language-text"><code>left_commitments.into_iter().for_each(|comm| {
env.process_hash(comm, LeftCommitment)
})
env.assert_eq(env.output_left, env.hash_state[LeftCommitment])</code></pre></div></li>
<li>The prover will also compute the expected hash for the next iteration, by
computing the hash of the output instance <code>U_(i + 1)</code>. It is described by
the notation <code>u_(i + 1).x ?= Hash(i + 1, z0, zi, U_(i + 1))</code> in the Fig 4 on
the right. Note that <code>U_(i + 1)</code> will be, at step <code>i + 1</code>, the new left
input. The value of the hash computed at step <code>i</code> will be compared at step
<code>i + 1</code>. In the code, we could summarize with the following pseudo-code:<div class="example-wrap"><pre class="language-text"><code>output_commitments.into_iter().for_each(|comm| {
env.process_hash(comm, OutputCommitment)
})
env.assert_eq(env.output_left, env.hash_state[OutputCommitment])</code></pre></div></li>
</ul>
<p>The order of the execution is encoded in the fact the hash contains the
step <code>i</code> when we check the left input and <code>i + 1</code> when we compress the
folded output. The fact that the prover encodes the computation on the same
initial input is encoded by adding the initial value <code>z0</code> into the hash for
both hash computation.
Therefore, the Nova IVC scheme encodes a <strong>sequential</strong> and <strong>incremental</strong>
computation, which can be verified later using a SNARK on the accumulated
instance.</p>
<p>The job regarding the correct accumulation of the commitments and the
scalars are done in the middle square, i.e. <code>acc_(i + 1) = NIFS.V(acc_i, u_i)</code>. It performs foreign field elliptic curve additions and scalars
additions.</p>
<h3 id="our-design"><a class="doc-anchor" href="#our-design">§</a>Our design</h3>
<p>The circuit is implemented using the generic interpreter provided by the
crate [kimchi_msm].
The particularity of the implementation is that it doesn’t use a cycle of
curves, aims to be as generic as possible, defer the scalar
multiplications to compute them in bulk and rely on the Poseidon hash.
Our argument will be mostly based on the state of the hash after we
executed the whole computation.</p>
<p>The IVC circuit is divided into different sections/sets of constraints
described by multivariate polynomials, each
activated by (public) selectors that are defined at setup time.
The number of columns of the original computation defines the shape of the
circuit as it will define the values of the selectors.</p>
<p>First, the folding scheme we use is described in the crate
<a href="folding::expressions">folding</a> and is based on degree-3 polynomials.
We do suppose that each constraint are reduced to degree 2, and the third
degree is used to encode the aggregation of constraints.</p>
<p>In the <a href="https://eprint.iacr.org/2021/370.pdf">Nova paper</a>, to provide
incremental verifiable computation, the authors propose a folding scheme
where the verifier has to compute the followings:</p>
<div class="example-wrap"><pre class="language-text"><code>// Accumulation of the homogeneous value `u`:
u&#39;&#39; = u + r u&#39;
// Accumulation of all the PIOP challenges:
for each challenge c_i:
   c_i&#39;&#39; = c_i + r c_i&#39;
for each alpha_i (aggregation of constraints):
   alpha_i&#39;&#39; = alpha_i + r alpha_i&#39;
// Accumulation of the blinders for the commitment:
blinder&#39;&#39; = blinder + r + r^2 + r^3 blinder&#39;
// Accumulation of the error terms (scalar multiplication)
E = E1 + r T0 + r^2 T1 + r^3 E2
// Randomized accumulation of the instance commitments (scalar multiplication)
for i in 0..N_COLUMNS
   (C_i)_O = (C_i)_L + r (C_i)_R</code></pre></div>
<p>The accumulation of the challenges, the homogeneous value and the blinders
are done trivially as they are scalar field values.
After that, the verifier has to perform foreign field ellictic curve
additions and scalar multiplications <code>(r T0)</code>, <code>(r^2 T1)</code>, <code>(r^3 E2)</code> and
<code>(r (C_i)_R)</code> for each column.</p>
<p>First, we decide to defer the computations of
the scalar multiplications, and we reduce the verifier work to compute only
the foreign field elliptic curve additions. Therefore, the verifier has
access already to the
result of <code>r T0</code>, <code>r^2 T1</code>, <code>r^3 E2</code> and <code>r (C_i)_R</code>, and must only perform the
addition. We call the commitments <code>r T0</code> the “scaled” commitment to <code>T0</code>, and
the same for the others. The commitments <code>(C_i)_L</code>, <code>(C_i)_R</code> and <code>(C_i)_O</code> are
called the “instance commitments”.</p>
<p>To perform foreign field elliptic curve addition, we split the commitments
into 17 chunks of 15 bits and use additive lookups as described in
[kimchi_msm::logup]. These 17 chunks will be used later to compute the
scalar multiplications using a variant of the scheme described in <a href="https://github.com/o1-labs/rfcs/blob/main/0013-efficient-msms-for-non-native-pickles-verification.md">the MSM
RFC</a></p>
<p>The first component of our circuit is a hash function.
We decided to use the Poseidon hash function, and implemented a generic one
using the generic interpreter in <a href="poseidon_8_56_5_3_2/index.html" title="mod ivc::poseidon_8_56_5_3_2">crate::poseidon_8_56_5_3_2</a>. The Poseidon
instance we decided to go with is the traditional full/partial rounds. For a
security of 128 bits, a substitution box of 5 and a state of 3 elements, we
need 8 full rounds and 56 partial rounds for the scalar field BN254.
Therefore, we can “absorb” 2 field elements per row (the third element is
kept as a buffer in the Sponge construction).</p>
<p>The cost of a single Poseidon hash in terms of constraints is 432
constraints, and requires 435 columns, in addition to 192 round constants
considered as constants “selectors” in our constraints.
Note that having 432 constraints per Poseidon hash means that we must also
have 432 constraints to accumulate the challenges used to combine the
constraints. It is worth noting that these alphas are the same for all
poseidon hashes.
Combining constraints is done by using another selector, on a single row,
see below (TODO).
Note that the columns used by the poseidon hash must also be aggregated
while running the IVC.</p>
<p>The Poseidon hash is used to absorb all the instance commitments, the
challenges and the scaled commitments.
In our circuit, we first start by absorbing all the elliptic curve points. A
particularity is that we will use different Poseidon instances for each
“side” of the addition. For each point, we do assume (<em>at the moment</em>) that
each point is encoded as 2 field elements in the field of the circuit
(FIXME: there is negligeable probability that it wraps over, as the
coordinates are in the base field).
For a given set of coordinates <code>(x, y)</code>, and by supposing an initial state of
our permutation <code>(s0, s1, s2)</code>, we will compute on a single row the absorbtion
of <code>(x, y)</code>, which consists of updating the state <code>(s0, s1, s2)</code> to
<code>(s0 + x, s1 + y, s2)</code>.
For each side, we will initialize a new Poseidon state, and we will keep
absorbing each column of the circuit.</p>
<p>We end up with the following shape:</p>
<div class="example-wrap"><pre class="language-text"><code>| q_poseidon | s0 | s1 | s2 | s0 + x | s1 + y | ... | s0&#39; | s1&#39; | s2&#39; | side |</code></pre></div>
<p>where <code>(s0', s1', s2')</code> is the final state of the Poseidon permutation after
the execution of all the rounds, and <code>q_poseidon</code> will be a (public
selector) that will be set to <code>1</code> on the row that Poseidon will need to be
executed, <code>0</code> otherwise.</p>
<h3 id="ivc-circuit-base-case"><a class="doc-anchor" href="#ivc-circuit-base-case">§</a>IVC circuit: base case</h3>
<p>The base case of the IVC circuit is supported by multiplying each constraint
by a fold_iteration column. As it is <code>0</code> for the base case, the whole
circuit is “turned off”.
We do not want to keep this in the final version, and aim to replace it with
a method that does not increase the degree of the constraints by one. The
column value is also under-constrained for now.</p>
<p>The code for the base case is handled in
<a href="ivc/interpreter/fn.ivc_circuit_base_case.html" title="fn ivc::ivc::interpreter::ivc_circuit_base_case">crate::ivc::interpreter::ivc_circuit_base_case</a> and the corresponding
constraints are in <a href="ivc/constraints/fn.constrain_ivc.html" title="fn ivc::ivc::constraints::constrain_ivc">crate::ivc::constraints::constrain_ivc</a>. The fold
iteration column is set at each row by each process_* function in the
interpreter.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="expr_eval/index.html" title="mod ivc::expr_eval">expr_<wbr>eval</a></dt><dt><a class="mod" href="ivc/index.html" title="mod ivc::ivc">ivc</a></dt><dt><a class="mod" href="plonkish_lang/index.html" title="mod ivc::plonkish_lang">plonkish_<wbr>lang</a></dt><dt><a class="mod" href="poseidon_8_56_5_3_2/index.html" title="mod ivc::poseidon_8_56_5_3_2">poseidon_<wbr>8_<wbr>56_<wbr>5_<wbr>3_<wbr>2</a></dt><dd>Poseidon hash function with 8 full rounds, 56 partial rounds, sbox 5, a
state of 3 elements and constraints of degree 2
Specialised circuit for Poseidon where we have maximum degree 2 constraints.</dd><dt><a class="mod" href="poseidon_55_0_7_3_2/index.html" title="mod ivc::poseidon_55_0_7_3_2">poseidon_<wbr>55_<wbr>0_<wbr>7_<wbr>3_<wbr>2</a></dt><dd>Poseidon hash function with 55 full rounds, 0 partial rounds, sbox 7, a
state of 3 elements and constraints of degree 2
Specialised circuit for Poseidon where we have maximum degree 2 constraints.</dd><dt><a class="mod" href="poseidon_55_0_7_3_7/index.html" title="mod ivc::poseidon_55_0_7_3_7">poseidon_<wbr>55_<wbr>0_<wbr>7_<wbr>3_<wbr>7</a></dt><dd>Poseidon hash function with 55 full rounds, 0 partial rounds, sbox 7,
a state of 3 elements and constraints of degree 7</dd><dt><a class="mod" href="poseidon_params_55_0_7_3/index.html" title="mod ivc::poseidon_params_55_0_7_3">poseidon_<wbr>params_<wbr>55_<wbr>0_<wbr>7_<wbr>3</a></dt><dd>Poseidon parameters for 55 full rounds, 0 partial rounds, sbox 7, a state of
3 elements
Poseidon parameters that can be used by <a href="poseidon_55_0_7_3_2/index.html" title="mod ivc::poseidon_55_0_7_3_2">crate::poseidon_55_0_7_3_2</a> and
<a href="poseidon_55_0_7_3_7/index.html" title="mod ivc::poseidon_55_0_7_3_7">crate::poseidon_55_0_7_3_7</a> over the scalar field of BN254</dd><dt><a class="mod" href="prover/index.html" title="mod ivc::prover">prover</a></dt><dt><a class="mod" href="verifier/index.html" title="mod ivc::verifier">verifier</a></dt></dl></section></div></main></body></html>