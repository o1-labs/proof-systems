<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="When P = (xP,yP) and Q = (xQ,yQ) are not negative of each other, thus function ensures"><title>constrain_ec_addition in kimchi_msm::fec::interpreter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="kimchi_msm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../kimchi_msm/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../kimchi_msm/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In kimchi_msm::fec::interpreter</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../../index.html">kimchi_msm</a>::<wbr><a href="../index.html">fec</a>::<wbr><a href="index.html">interpreter</a>::<wbr><a class="fn" href="#">constrain_ec_addition</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/kimchi_msm/fec/interpreter.rs.html#199-408">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn constrain_ec_addition&lt;F: PrimeField, Ff: PrimeField, Env: <a class="trait" href="../../circuit_design/capabilities/trait.ColAccessCap.html" title="trait kimchi_msm::circuit_design::capabilities::ColAccessCap">ColAccessCap</a>&lt;F, <a class="enum" href="../columns/enum.FECColumn.html" title="enum kimchi_msm::fec::columns::FECColumn">FECColumn</a>&gt; + <a class="trait" href="../../circuit_design/capabilities/trait.LookupCap.html" title="trait kimchi_msm::circuit_design::capabilities::LookupCap">LookupCap</a>&lt;F, <a class="enum" href="../columns/enum.FECColumn.html" title="enum kimchi_msm::fec::columns::FECColumn">FECColumn</a>, <a class="enum" href="../lookups/enum.LookupTable.html" title="enum kimchi_msm::fec::lookups::LookupTable">LookupTable</a>&lt;Ff&gt;&gt;&gt;(
    env: <a class="primitive" href="https://doc.rust-lang.org/1.72.1/std/primitive.reference.html">&amp;mut Env</a>
)</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>When P = (xP,yP) and Q = (xQ,yQ) are not negative of each other, thus function ensures</p>
<p>P + Q = R where</p>
<p>s = (yP - yQ) / (xP - xQ)</p>
<p>xR = s^2 - xP - xQ and yR = -yP + s(xP - xR)</p>
<p>Equations that we check:</p>
<ol>
<li>s (xP - xQ) - (yP - yQ) - q_1 f =  0</li>
<li>xR - s^2 + xP + xQ - q_2 f = 0</li>
<li>yR + yP - s (xP - xR) - q_3 f = 0</li>
</ol>
<p>We will use several different “packing” format.</p>
<p>=== Limb equations</p>
<p>The standard (small limb) one, using 17 limbs of 15 bits each, is
mostly helpful for range-checking the element, because 15-bit
range checks are easy to perform. Additionally, this format is
helpful for checking that the value is ∈ [0,f), where f is a
foreign field modulus.</p>
<p>We will additionally use a “large limb” format, where each limb is
75 bits, so fitting exactly 5 small limbs. This format is
effective for trusted values that we do not need to range check.
Additionally, verifying equations on 75 bits is more effective in
terms of minimising constraints.</p>
<p>Regarding our /concrete limb/ equations, they are different from
the generic ones above in that they have carries. The carries are
stored in a third format. Let us illustrate the design on the
first equation of the three. Its concrete final form is as follows:</p>
<p>for i ∈ [0..2L-2]:
\sum_{j,k &lt; L | k+j = i} s_j (xP_k - xQ_k)
- ((yP_i - yQ_i) if i &lt; L else 0)
- q_1_sign * \sum_{j,k &lt; L | k+j = i} q_1_j f_k
- (c_i * 2^B if i &lt; 2L-2 else 0)
+ (c_{i-1} if i &gt; 0 else 0) = 0</p>
<p>First, note that the equation has turned into 2L-2 equations. This
is because the form of multiplication (and there are two
multiplications here, s*(xP-xQ) and q*f) implies quadratic number
of limb multiplications, but because our operations are modulo f,
every single element except for q in this equation is in the
field.</p>
<p>Instead of having one limb-multiplication per row (e.g.
q_1_5*f_6), which would lead to quadratic number of constraints,
and quadratic number of intermediate-representation columns, we
“batch” all multiplications for degree $i$ in one constraint as
above.</p>
<p>Second, note that the carries are non-uniform in the loop: for the
first limb, we only subtract c_0*2^B, while for the last limb we
only add the previous carry c_{2L-3}. This means that, as usual,
the number of carries is one less than the number of
limb-equations. In our case, every equation relies on 2L-2 “large”
carries.</p>
<p>Finally, small remark is that for simplicity we carry the sign of
q separately from its absolute value. Note that in the original
generic equation s (xP - xQ) - (yP - yQ) - q_1 f = 0 that holds
over the integers, the only value (except for f) that can actually
be outside of the field range [0,f-1) is q_1. In fact, while every
other value is strictly positive, q_1 can be actually negative.
Carrying its sign separately greatly simplifies modelling limbs at
the expense of just 3 extra columns per circuit. So q_1 limbs
actually contains the absolute value of q_1, while q_1_sign is in
{-1,1}.</p>
<p>=== Data layout</p>
<p>Now we are ready to present the data layout and to discuss the
representation modes.</p>
<p>Let
L := N_LIMBS_LARGE
S := N_LIMBS_SMALL</p>
<h3 id="variable----offset------length--------comment"><a href="#variable----offset------length--------comment">variable    offset      length        comment</a></h3><h3 id="xp---------0-----------------l----------always-trusted-not-range-checkedyp---------1l---------------l----------always-trusted-not-range-checkedxq---------2l---------------l----------always-trusted-not-range-checkedyq---------3l---------------l----------alawys-trusted-not-range-checkedf----------4l---------------l----------always-trusted-not-range-checkedxr---------5l---------------syr---------5l--1s---------ss----------5l--2s---------sq_1--------5l--3s---------sq_2--------5l--4s---------sq_3--------5l--5s---------sq_2_sign---5l--6s---------1q_1_sign---5l--6s--1-----1q_3_sign---5l--6s--2-----1carry_1----5l--6s--3-----2s2carry_2----5l--8s--5-----2s2carry_3----5l--10s--7----2s2"><a href="#xp---------0-----------------l----------always-trusted-not-range-checkedyp---------1l---------------l----------always-trusted-not-range-checkedxq---------2l---------------l----------always-trusted-not-range-checkedyq---------3l---------------l----------alawys-trusted-not-range-checkedf----------4l---------------l----------always-trusted-not-range-checkedxr---------5l---------------syr---------5l--1s---------ss----------5l--2s---------sq_1--------5l--3s---------sq_2--------5l--4s---------sq_3--------5l--5s---------sq_2_sign---5l--6s---------1q_1_sign---5l--6s--1-----1q_3_sign---5l--6s--2-----1carry_1----5l--6s--3-----2s2carry_2----5l--8s--5-----2s2carry_3----5l--10s--7----2s2">xP:         0                 L          Always trusted, not range checked
yP:         1<em>L               L          Always trusted, not range checked
xQ:         2</em>L               L          Always trusted, not range checked
yQ:         3<em>L               L          Alawys trusted, not range checked
f:          4</em>L               L          Always trusted, not range checked
xR:         5<em>L               S
yR:         5</em>L + 1<em>S         S
s:          5</em>L + 2<em>S         S
q_1:        5</em>L + 3<em>S         S
q_2:        5</em>L + 4<em>S         S
q_3:        5</em>L + 5<em>S         S
q_2_sign:   5</em>L + 6<em>S         1
q_1_sign:   5</em>L + 6<em>S + 1     1
q_3_sign:   5</em>L + 6<em>S + 2     1
carry_1:    5</em>L + 6<em>S + 3     2</em>S+2
carry_2:    5<em>L + 8</em>S + 5     2<em>S+2
carry_3:    5</em>L + 10<em>S + 7    2</em>S+2</a></h3>
<p>As we said before, all elements that are either S small limbs or 1
are for range-checking. The only unusual part here is that the
carries are represented in 2*S+2 limbs. Let us explain.</p>
<p>As we said, we need 2<em>L-2 carries, which in 6. Because our
operations contain not just one limb multiplication, but several
limb multiplication and extra additions, our carries will /not/
fit into 75 bits. But we can prove (below) that they always fit
into 79 limbs. Therefore, every large carry will be represented
not by 5 15-bit chunks, but by 6 15-bit chunks. This gives us 6
bits * 6 carries = 36 chunks, and every 6th chunk is 4 bits only.
This matches the 2</em>S+2 = 36, since S = 17.</p>
<p>Note however since 79-bit carry is signed, we will store it as a list of
[15 15 15 15 15 9]-bit limbs, where limbs are signed.
E.g. 15-bit limbs are in [-2^14, 2^14-1]. This allows us to use
14abs range checks.</p>
<p>=== Ranges</p>
<p>Carries for our three equations have the following generic range
form (inclusive over integers). Note that all three equations look
exactly the same for i &gt;= n <em>except</em> the carry from the previous
limbs.</p>
<p>Eq1.</p>
<ul>
<li>i ∈ [0,n-1]:  c1_i ∈ [-((i+1)<em>2^(b+1) - 2</em>i - 3),
(i+1)<em>2^(b+1) - 2</em>i - 3] (symmetric)</li>
<li>i ∈ [n,2n-2]: c1_i ∈ [-((2<em>n-i-1)<em>2^(b+1) - 2</em>(2</em>n-i) + 3),
(2<em>n-i-1)<em>2^(b+1) - 2</em>(2</em>n-i) + 3] (symmetric)</li>
</ul>
<p>Eq2.</p>
<ul>
<li>i ∈ [0,n-1]:  c2_i ∈ [-((i+1)<em>2^(b+1) - 2</em>i - 4),
if i == 0 2^b else (i+1)*2^b - i]</li>
<li>i ∈ [n,2n-2]: c2_i ∈ [-((2<em>n-i-1)<em>2^(b+1) - 2</em>(2</em>n-i) + 3),
(2<em>n-i-1)<em>2^(b+1) - 2</em>(2</em>n-i) + 3 - (if i == n { n-1 } else 0) ]</li>
</ul>
<p>Eq3.</p>
<ul>
<li>i ∈ [0,n-1]:  c3_i ∈ [-((i+1)<em>2^(b+1) - 2</em>i - 4),
(i+1)*2^b - i - 1]</li>
<li>i ∈ [n,2n-2]: c3_i ∈ [-((2<em>n-i-1)<em>2^(b+1) - 2</em>(2</em>n-i) + 3),
(2<em>n-i-1)<em>2^(b+1) - 2</em>(2</em>n-i) + 3 - (if i == n { n-1 } else 0) ]</li>
</ul>
<p>Absolute maximum values for all carries:
Eq1.</p>
<ul>
<li>Upper bound = -lower bound is achieved at i = n-1, n<em>2^(b+1) - 2</em>(n-1) - 3
<ul>
<li>(+-) 302231454903657293676535</li>
</ul>
</li>
</ul>
<p>Eq2 and Eq3:</p>
<ul>
<li>Upper bound is achieved at i = n, (n-1)<em>2^(b+1) - 2</em>n + 3 - n -1
<ul>
<li>226673591177742970257400</li>
</ul>
</li>
<li>Lower bound is achieved at i = n-1, n<em>2^(b+1) - 2</em>(n-1) - 4
<ul>
<li>(-) 302231454903657293676534</li>
</ul>
</li>
</ul>
<p>As we can see, the values are about 2*n=8 times bigger than 2^b,
so concretely 4 extra bits per carry will be enough. This implies
that we can /definitely/ fit a large carry into 6 small limbs,
since it has 15 “free” bits of which we will use 4 at most.</p>
<p>@volhovm: Soundness-wise I am not convinced that we need to
enforce these more precise ranges as compared to enforcing just 4
bit more for the highest limb. Even checking that highest limb is
15 bits could be quite sound.</p>
</div></details></section></div></main></body></html>