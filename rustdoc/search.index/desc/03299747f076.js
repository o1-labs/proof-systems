rd_("BcGeneric domain string argument typeCmAn alias for the intended usage of the expression type in \xe2\x80\xa6CkAn expression over /generic/ (not circuit-specific) columnsClType to represent a constraint on the individual columns \xe2\x80\xa6AhThe curve we commit into0EgLet <code>M</code> be the power of 2^64 nearest to <code>Self::MODULUS_BITS</code>. \xe2\x80\xa6C`t for 2^s * t = MODULUS - 1, and t coprime to 2.DbThe variable <code>u</code> used to make the polynomial homogenousCmThe parameter a is the coefficients of the elliptic curve \xe2\x80\xa6CnA list of functions/looked-up values. Invariant: for fixed \xe2\x80\xa60CnThe vector of group elements for committing to polynomials \xe2\x80\xa60BmA group element used for blinding commitments0kaggregation0CjThe multiplicity polynomials; by convention, this is a \xe2\x80\xa60CjThe coin folding combiner will be used to generate the \xe2\x80\xa6Cnpermutation polynomials (PERMUTS-1 evaluations because the \xe2\x80\xa6AfScalar field componentDdThe scalar <code>u</code> that is used to homogenize the polynomials00A`wire evaluationsAcwitness polynomialsBmGets w from <code>VerifierIndex</code> lazilyB`domain offset for zero-knowledgeCj<code>X / Z</code> projection of the affine <code>X</code>0lX-coordinateCj<code>Y / Z</code> projection of the affine <code>Y</code>0BgThe permutation aggregation polynomial.Agpermutation evaluationsAfpermutation polynomialDeProjective multiplicative inverse. Will be <code>0</code> only at \xe2\x80\xa60AjFunction arguments/resultsAjScalar field of the curve.0BeThe native field we are working with.ChFrame pointer/saved register. This is the same register.CmThe base field of the curve Used to encode the polynomial \xe2\x80\xa60nGlobal pointerBoIndex of high limb (in 3-limb foreign elements)AkCurrent instruction pointerBnIndex of low limb (in 3-limb foreign elements)CaIndex of middle limb (in 3-limb foreign elements)AjContains the success value000000BdFormat: <code>or rd, rs1, rs2</code>AhR2 = R^2 % Self::MODULUSBjContains the 24 round constants for KeccaknReturn addressoSaved registersmStack pointerAlTemporary/alternate registerkTemporariesnThread pointerAnReturns the allocation pointerAnconstraints system polynomialsAjevaluations over domain d4Ajevaluations over domain d8AiReturns the frame pointerolookup multiset000BdReturns the ID of the runtime table.mThe table ID.0mThe table id.Bivector of rounds of L &amp; R commitmentsBiVector of rounds of L &amp; R commitments1nlookup witness0CmDegree-2 variable encoding the OR of two variables, which \xe2\x80\xa6AkReturns the program counterCground constant that are relevant for this specific gateAdBase field componentAnA final folded commitment basemInitial inputmCurrent inputoAdd two values.hAdditionBeFormat: <code>add rd, rs1, rs2</code>BeFormat: <code>and rd, rs1, rs2</code>AlThe gadget defining the app.BgValues involved in Chi permutation stepCkConstants for each witness\xe2\x80\x99 index offsets and lengths \xe2\x80\xa6BeFormat: <code>div rd, rs1, rs2</code>ClAn environment is used to contain the state of a long \xe2\x80\x9c\xe2\x80\xa6BaA generic Index based environmentCbRepresents the environment for the logup argument.CgThe environment keeping the constraints between the \xe2\x80\xa6CiThis structure represents the environment the virtual \xe2\x80\xa6CkThis struct contains all that needs to be kept track of \xe2\x80\xa601AhContains the error value000000CcThe foreign field we are emulating (one of the two)kInvalid hexAlINV = -MODULUS^{-1} mod 2^64AlMultiplication of two valuesBeFormat: <code>mul rd, rs1, rs2</code>CkCreates the 5x5 table of rotation bits for Keccak modulo 64mA public gateBeFormat: <code>rem rd, rs1, rs2</code>CnThe SRS used by the polynomial commitment. The SRS is used \xe2\x80\xa6kSubtractionBeFormat: <code>sub rd, rs1, rs2</code>AdHelper to obtain twoBeFormat: <code>xor rd, rs1, rs2</code>CnThis module includes the AND gadget implementation and the \xe2\x80\xa6CnReturns the evaluations of a given column witness at omega \xe2\x80\xa6AkThe column of this variableDiReturns <code>x / y</code>, storing the results in <code>position</code>.BjReturns the destination of the instructionBbReturns bit-flag for 16th positionCeOutputs the final value of the pointers after the \xe2\x80\xa6Ajfinal computation pointersBaDisplay a JSON value as a string.CjInitialize a random input with a random value of given \xe2\x80\xa6CnIndex into a JSON array or map. A string index can be used \xe2\x80\xa6CgOutputs the initial value of the pointers after the \xe2\x80\xa6Aminitial computation registersCmThis module contains the implementation of the polynomial \xe2\x80\xa6ChThis crate provides a circuit to achieve Incremental \xe2\x80\xa6ClThis module implements the KZG protocol described in the \xe2\x80\xa6BhReturns the length of the runtime table.CeThe number of entries contained in the runtime table.B`Returns the length of the table.AmReturns the number of chunks.CeGet size of the full memory including dummy 0th entryCkHandy macro to return the filename and line number of a \xe2\x80\xa6CgReturn field element as byte, if it fits. Otherwise \xe2\x80\xa6CcApply a function to all the coefficients in the \xe2\x80\xa6nThe MDS matrixCfHelper to access maximum distance separable matrix \xe2\x80\xa6Ahstate of the computationAefull execution memoryDkInitializes a new foreign element from an absolute <code>BigUint</code> \xe2\x80\xa6CnCreates a new environment storing the structure, instances \xe2\x80\xa6CnCreates a new folding scheme for decomposable circuits. It \xe2\x80\xa6ClThis will create a context that allows for benchmarks of \xe2\x80\xa6BkCreates a new set of wires for a given row.AcCreates a new Wire.BgGenerates the shifts for a given domainAhCreates a new Fr-Sponge.AcCreates a new LogupCbCreates a new witness with <code>rows</code> rows.BfCreate a new empty random oracle inputCmCreate a new cryptographic sponge using arithmetic sponge \xe2\x80\xa6AeCreates a new sponge.BkCreate secret key from scalar field elementAfCreate a new signatureClCreates a new foreign element from an array containing N \xe2\x80\xa6CnStarts a new Keccak environment for a given hash index and \xe2\x80\xa6CfCreates a new RAMLookup from a mode, a table ID, a \xe2\x80\xa6CmCreates a JavaScript <code>Error</code> with a given message.ChCreate a new memory structure from a vector of field \xe2\x80\xa6CkCreates a new Cairo execution step from a step index, a \xe2\x80\xa6CiCreates a Cairo execution from the public information \xe2\x80\xa6B`Creates a new triple of pointersAjCreates a CairoInstructionBhCreates a CairoWord from a field elementCmThis module includes the definition of the NOT gadget and \xe2\x80\xa6CnDegree-1 variable encoding the negation of the input Note: \xe2\x80\xa6AfBuild the constant oneBmReturns a variable representing the value oneBlReturns the first operand of the instructionBmReturns the second operand of the instructionChPads the message with the 10*1 rule until reaching a \xe2\x80\xa6CiThis module contains a list of property tests for the \xe2\x80\xa6BcExponentiate a constant expression.BbRaise the value to the given powerCdRaise each evaluation to some power <code>pow</code>BeReturns the result of the instructionhROT gateBgThe row (Curr of Next) of this variableCaYou can use this module for serialization and \xe2\x80\xa6nSID polynomialAjpolynomial commitment keysBoGets srs from <code>VerifierIndex</code> lazily1cSRS0CbThe error terms of degree 1, see the top-level \xe2\x80\xa6CbThe error terms of degree 2, see the top-level \xe2\x80\xa6a2iValue twoBmReturns a variable representing the value twoA`type of the gatehXOR gateAkXOR pattern lookup selectorCmThis module includes the definition of the XOR gadget for \xe2\x80\xa6CmDegree-2 variable encoding the XOR of two variables which \xe2\x80\xa6C`Both challenges used in the permutation argumentCdThe first challenge used in the permutation argumentBoThe challenge to compute 1/(beta + lookupvalue)AjRepresents a JSON boolean.BfFormat: <code>divu rd, rs1, rs2</code>DfAn multi-variate polynomial over the base ring <code>C</code> with \xe2\x80\xa6CfGates in the PLONK constraint system. As gates are \xe2\x80\xa6BhValues involved in Iota permutation stepBfFormat: <code>mulh rd, rs1, rs2</code>AfA human readable name.0BoA dummy gadget, doing nothing. Use for padding.AmRepresents a JSON null value.AiSum a value to a constantBfFormat: <code>remu rd, rs1, rs2</code>CfDefine the side of the temporary accumulator. When \xe2\x80\xa6CbThis type refers to the two instances to be foldedCbUsed to encode the sign of a term in a polynomial.CjA term of a polynomial For instance, in the polynomial \xe2\x80\xa6ClWire documents the other cell that is wired to this one. \xe2\x80\xa6iZero gate0CaBoth challenges used in the permutation argument.BdThe challenge \xce\xb2 from the PLONK IOP.CeThe evaluation point used for the lookup polynomials.CmReturns an offset of 16 bits to its biased representation \xe2\x80\xa6lCaml helpersCeConvenience function for constructing cell variables.0CiA witness row is represented by an array of N witness \xe2\x80\xa600AePolynomial commitmentAgWitness for current rowA`current pointersA`A single column.Bfcoefficient for the group endomorphismAfendoscalar coefficientCkEvaluate the polynomial at the vector point <code>x</code>.00AoReturns the argument unchanged.000000000000000000000000000000000000000000000000000000000DjConvert 32-bit floating point number to <code>Value::Number</code>, or \xe2\x80\xa6DjConvert 64-bit floating point number to <code>Value::Number</code>, or \xe2\x80\xa6BlConvert boolean to <code>Value::Bool</code>.CjConvert <code>String</code> to <code>Value::String</code>.CcConvert string slice to <code>Value::String</code>.CkConvert copy-on-write string to <code>Value::String</code>.CjConvert <code>Number</code> to <code>Value::Number</code>.CmConvert map (with string keys) to <code>Value::Object</code>.ChConvert a <code>Vec</code> to <code>Value::Array</code>.BmConvert a slice to <code>Value::Array</code>.CdConvert <code>()</code> to <code>Value::Null</code>.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CgThis module implements Plonk constraint gate primitive.BcHash input and obtain result outputCkInitialize a witness based on layout and computed variablesCkSet the initial state based on domain separation string \xe2\x80\xa6BaCalls <code>U::from(self)</code>.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CoConstruct a <code>serde_json::Value</code> from a JSON literal.DgComputes <code>prod_{j != n} (1 - omega^j)</code> Assure we don\xe2\x80\x99t \xe2\x80\xa6DgReturn the value <code>prod_{j != 1} (1 - omega^j)</code>, used for \xe2\x80\xa6DhThe value <code>prod_{j != 1} (1 - omega^j)</code>, used for efficiently0DiThe value <code>prod_{j != 1} (1 - \xcf\x89^j)</code>, used for efficiently \xe2\x80\xa6CkTurns a non-hiding polynomial commitment into a hidding \xe2\x80\xa60CcThis modules implements some math helper functions.ClAn interpreter for the MIPS instruction set. This module \xe2\x80\xa6BoNumber encoding format (base-10 or hexadecimal)AdWitness for next rowAenext wire evaluations0Af(if any) next pointersCkCreate an opening proof for a batch of polynomials. The \xe2\x80\xa6kParameters:Eg<code>pows(d, x)</code> returns a vector containing the first <code>d</code> powers \xe2\x80\xa6AgGenerate random keypairAlGenerate a random secret keyAnRead element in memory addressCkCustom seed for test vector generation (32 bytes as hex \xe2\x80\xa6CdReturns the sign of the operation as a field elementFdSign <code>input</code> (see <code>Hashable</code>) using keypair <code>kp</code> and return the \xe2\x80\xa6CeEach chunk polynomial has degree <code>size-1</code>.0BcReturns the size of the instructionBnReturns the square root of self, if it exists.CjExecute a single step of the MIPS program. Returns the \xe2\x80\xa6CkEntrypoint for the interpreter. It executes one step of \xe2\x80\xa6lCurrent stepBmExecute a single step in the RISCV32i programEeTakes the value out of the <code>Value</code>, leaving a <code>Null</code> in its \xe2\x80\xa6CkRecursively print the expression, except for the cached \xe2\x80\xa6Aethis wire evaluations0Aistate auxiliary variablesCkProduces a <code>circuit.html</code> in the current folder.DdWire the cell at <code>col</code> to another cell (<code>to</code>).CkThe Cairo language works natively for field elements in \xe2\x80\xa6CbReturns the content of the word as a field elementAgBuild the constant zeroBnthis function creates \xe2\x80\x9cempty\xe2\x80\x9d circuit gateCiCreates a new foreign element representing the value zeroBnReturns a variable representing the value zeroBgEvaluation at the challenge point zeta.CeReturns the end of the circuit, which is used for \xe2\x80\xa6CjUpdate by 2 in call instructions or zero behaviour for \xe2\x80\xa6DcThe random values <code>\xce\xb1_{i}</code> used to aggregate constraintsBkA list of randomizer to combine expressionsAkUsed to combine constraintsBdThe challenge to combine constraintsAhRepresents a JSON array.gA cachekCarry limbsChA constant, the constructor contains the constant itselfCbThe target curve used by the polynomial commitmentDkRepresents a multivariate polynomial of degree less than <code>D</code> \xe2\x80\xa6nThe error termChThe error term introduced in the \xe2\x80\x9crelaxed\xe2\x80\x9d instance.CeErrors that can occur during the check of the witnessChA newtype that represents Serde errors as JavaScript \xe2\x80\xa6BdAll foreign field operations allowedAjFormat: <code>fence</code>CeThe second challenge used in the permutation argumentChThe challenge to combine tuple sum gamma^i lookupvalue_iCaThe variables of the initial circuit, without \xe2\x80\xa6CnGeneric structure to represent a (vector) lookup the table \xe2\x80\xa6BgFormat: <code>mulhu rd, rs1, rs2</code>BfTotal number of columns in this index.BiValues involved in PiRho permutation stepBkFIXME: a proof for the Nova recursive SNARKCiCurrent step performs a round of the permutation. The \xe2\x80\xa6CkVariants of Keccak steps available for the interpreter. \xe2\x80\xa6BiValues involved in Theta permutation stepAfindex of all registersBdThe challenge \xce\xb1 from the PLONK IOP.BmReturns flagset for allocation pointer updateCfThis module provides different helpers in creating \xe2\x80\xa6BkPoseidon parameters that can be used by \xe2\x80\xa6BjBuild the ConstraintSystem from a Builder.jCache itemAoVector of scalar field elementskCoefficientAnCoefficient value at index idxBbCrumb constraint for 2-bit value xBbConstrain to crumb (i.e. two bits)BhThis file defines a trait similar to \xe2\x80\xa6CfThis module contains a useful trait for recursion: \xe2\x80\xa6CmCreate a dummy signature, whose components are both equal \xe2\x80\xa6EhThe empty <code>CompressedPubKey</code> value that is used as <code>public_key</code>\xe2\x80\xa6CiProvides the coefficients for the curve endomorphism, \xe2\x80\xa60EgReturns 1 if <code>x</code> is equal to <code>y</code>, or 0 otherwise, storing the \xe2\x80\xa60CiThis module implements the <code>ProverError</code> type.CfTwo evaluations over a number of committed polynomialsCdForeign field multiplication pattern lookup selectorCnDefinition of some constants for easier readability of the \xe2\x80\xa6BdThe challenge \xce\xb3 from the PLONK IOP.mcircuit gatesCireturns the y-coordinate if x is a valid point on the \xe2\x80\xa6FaGiven variable <code>x</code> and position <code>ix</code>, it (hybrid) writes <code>x</code> \xe2\x80\xa6EeIndex into a <code>serde_json::Value</code> using the syntax <code>value[0]</code> orCgMap a column alias to the corresponding witness column.CjHandy function to quickly create an expression for a gate.AoThe index selector polynomials.C`Map the column alias to the actual column index.0CnMap the column alias to the actual column index. Note that \xe2\x80\xa60AjReturns the inner witness.CmReturns the 100 step input variables, which correspond to \xe2\x80\xa6ClThis function returns the current word instruction being \xe2\x80\xa6CbReturns the field element corresponding to the \xe2\x80\xa6Allimbs in little endian order0ClThis file will implement a logup argument to allow users \xe2\x80\xa6CmImplement a variant of the logarithmic derivative lookups \xe2\x80\xa6CkConverts the expression in OCaml code Recursively print \xe2\x80\xa6BjReturns flagset for program counter updateB`Borrow public key as curve pointnrecursion dataAfThe chunk polynomials.ClMultivariate polynomial dense representation using prime \xe2\x80\xa6CfThis module implements the data structures of a proof.B`batched commitment opening proofAcThe proof to verifyClGenerate a proof. All the information to make a proof is \xe2\x80\xa6CnMake a PlonKish proof for the given circuit. As inputs, we \xe2\x80\xa6CnThis method takes a witness and a vector of evaluations to \xe2\x80\xa6CnThis method takes an Instance and a commitment to zero and \xe2\x80\xa6101BkReset the environment to build the next row0ChFrom a vector of shifts, resets the underlying value \xe2\x80\xa6CdRestore the initial state that was set most recentlyCmReset the sponge back to its initial state (as if it were \xe2\x80\xa6CdReset the environment to handle the next instructionCmReturns a variable that encodes the current round number [\xe2\x80\xa6CbThis function \xe2\x80\x9cscales\xe2\x80\x9d (multiplies all the \xe2\x80\xa6CmThis function \xe2\x80\x9cscales\xe2\x80\x9d (multiplies) a polynomial with \xe2\x80\xa6CmThis module defines methods and structures for setting up \xe2\x80\xa6DfCompute the offset corresponding to the <code>CurrOrNext</code> value.Afwire coordinate shiftsCkFrom each quarter in sparse representation, it computes \xe2\x80\xa612CjUtility function for shifting poly along domain coordinateBoState of the current row in the execution traceAgThe state of the sponge00CnOutputs the total number of steps of the execution carried \xe2\x80\xa6Aetotal number of stepsDiReturns the lookup table used by the pattern, or <code>None</code> if \xe2\x80\xa6ChThe evaluations of the combined lookup table polynomial.AfUtils only for testingBnReturns a reference to the set of instructionsBoexecution trace as a vector of CairoInstructionCmThis module contains functions to work with prime numbers \xe2\x80\xa6CjEvaluate the given constant expression to a field element.0BeLinear combination of local-positionsCkReturns the number of columns, i.e. the width of the table.CjThis module implements Plonk circuit gate wires primitive.Cegate wiring (for each cell, what cell it is wired to)BcWrite u64 element in memory addressAcpre-computed zeta^nBiUpdate ap by adding a number of positionsAkUpdate ap by self incrementCjCombinators that will be used to fold the constraints, \xe2\x80\xa6ClThis type can be used to create a mapping between powers \xe2\x80\xa6CjThe generic type of column the environment can use. In \xe2\x80\xa6CeA type representing the variables involved in the \xe2\x80\xa6BjDescribe a generic indexed variable X_{i}.BhA specific gate did not verify correctlyCmCustom lookup table The index of the table is used as the \xe2\x80\xa6BaDestination refers to ap registerClDescribe the degree of a constraint. As described in the \xe2\x80\xa6CmThe different multiplicaive domain sizes that can be used \xe2\x80\xa6AlFormat: <code>fence.i</code>CjThis enum represents the different gadgets that can be \xe2\x80\xa6CbInterface for hashing <code>Hashable</code> inputsAfNaive Keccak structureAcThe lookup argumentCgAdditive lookups used in the MSM project based on LogupDk<code>MPrism</code> allows one to Something like a Prism, but for Maybe \xe2\x80\xa6CeGeneric trait to represent a multi-variate polynomialBhFormat: <code>mulhsu rd, rs1, rs2</code>AhNext instruction pointerCiRepresents a JSON number, whether integer or floating \xe2\x80\xa6BcFirst operand refers to ap registerBdSecond operand refers to ap registerBdSecond operand refers to fp registerAiRepresents a JSON object.AmUpdate pc by an absolute jumpBhUpdate pc by a conditional relative jumpAlUpdate pc by a relative jumpCaDefault increase of pc by adding instruction sizeClThe domain separation string to use in the hash. This is \xe2\x80\xa6jPublic keyBnThe number of rounds in the Keccak permutationBcThe result of a proof verification.nKeypair resultAaPublic key Result1BdResult alias using FieldHelpersErrorAbInvalid secret keyjSecret keyCkShifts represent the shifts required in the permutation \xe2\x80\xa6AlInterface for signed objectsCjSkip the given number of tokens if the feature is enabled.CiThe lens source type, i.e., the object containing the \xe2\x80\xa6DiRepresents a multivariate polynomial in <code>N</code> variables with \xe2\x80\xa6CmCryptographic sponge interface - for hashing an arbitrary \xe2\x80\xa6AhCurrent step is a spongeAiRepresents a JSON string.CkThe lens target type, i.e., the field to be accessed or \xe2\x80\xa6BjAbsorbs the field element into the sponge.C`Absorb an array of field elements <code>x</code>BcThe lookup aggregation polynomials.BoCommitment to the lookup aggregation polynomialCnThis module implements an abstraction to keep track of the \xe2\x80\xa6DkIf the <code>Value</code> is a number, represent it as f64 if possible. \xe2\x80\xa6DcIf the <code>Value</code> is an integer, represent it as i64 if \xe2\x80\xa6DfIf the <code>Value</code> is a String, returns the associated str. \xe2\x80\xa6DcIf the <code>Value</code> is an integer, represent it as u64 if \xe2\x80\xa6kReturns \xe2\x80\xa6CnReturns the minimum number of bits required to represent a \xe2\x80\xa6CiFor each row in the circuit, which lookup-constraints \xe2\x80\xa6CkModules mimicking the defined structures used by Cannon \xe2\x80\xa6AfThe chunk evaluations.AaGate coefficientsCfpublic selector polynomials that can used as handy \xe2\x80\xa6CmThis module defines the custom columns used in the Keccak \xe2\x80\xa6BhList all columns used by the interpreterCmCommits a polynomial, potentially splitting the result in \xe2\x80\xa6CjInitialize the environment for creating constraints of \xe2\x80\xa6EjInitializes the <code>ConstraintSystem&lt;F&gt;</code> on input <code>gates</code> and \xe2\x80\xa6BoCreate the <code>LookupConstraintSystem</code>.BhCreate the default lookup configuration.ChCreate a foreign field multiplication witness Input: \xe2\x80\xa6CjCreate a single range check witness Input: 88-bit value v0BgCreate witness cell with constant valueClCreate witness cell copied from bits [start, end) of the \xe2\x80\xa6CiCreate a witness cell copied from the witness cell at \xe2\x80\xa6CgCreate witness cell copied from the witness cell at \xe2\x80\xa6CjCreate witness cell assigned from a variable name a lengthCnCreate witness cell assigned from the bits [start, end) of \xe2\x80\xa6CaCreate witness cell assigned from a variable nameAlCreate a layout variable mapGbCreates 4 evaluation domains <code>d1</code> (of size <code>n</code>), <code>d2</code> (of size <code>2n</code>\xe2\x80\xa6CiThis function constructs prover\xe2\x80\x99s zk-proof from the \xe2\x80\xa6Cathis function compiles the index from constraintsCnCreate an environment for the prover to create a proof for \xe2\x80\xa6BiCreate a new empty-state witness builder.BiCreate an SRS of size <code>depth</code>.AoCreate a KZG proof. Parameters:AoReturn the degree of the columnCmReturn the degree of the expression. The degree of a cell \xe2\x80\xa60BeReturns the degree of the polynomial.00Cethe last evaluation of the Fq-Sponge in this protocolCjConsumes the sponge and returns the current digest, by \xe2\x80\xa6DkCompute the digest of the <code>VerifierIndex</code>, which can be used \xe2\x80\xa6AhObtain has result outputCbReturns a scalar field digest using the binary \xe2\x80\xa6DiReturns the digest of <code>self</code>. Note: this is implemented as \xe2\x80\xa6CoReturns <code>(x / y, x % y)</code>, storing the results in \xe2\x80\xa6Abevaluation domainsBgThe domains used in the PLONK argument.Aaevaluation domain11A`Double the valueCnExpands a quarter of a word into the sparse representation \xe2\x80\xa6ChExtend an existing witness with a single range check \xe2\x80\xa6AbOutput file formatCmThis module obtains the gates of a foreign field addition \xe2\x80\xa60A`Range check gateCfThis module provides the CryptoDigest trait, which \xe2\x80\xa6CkThis module includes some field helpers that are useful \xe2\x80\xa6CfInsert a variable and corresponding value into the \xe2\x80\xa6DbReturns true if the <code>Value</code> is a number that can be \xe2\x80\xa6EfReturns true if the <code>Value</code> is an integer between <code>i64::MIN</code> \xe2\x80\xa6AfParity of y-coordinateCmDegree-1 variable encoding whether the input is the value \xe2\x80\xa6ChReturns a degree-1 variable that encodes whether the \xe2\x80\xa6DiReturns true if the <code>Value</code> is an integer between zero and \xe2\x80\xa6AbKeccak hash moduleCaAn interpreter for an optimised version of KeccakfKimchiBaReturns the length of each table.CbThis module implement the lookup argument. See \xe2\x80\xa6DjSet up the lookup tables. If not invoked, it is <code>vec![]</code> by \xe2\x80\xa6AnLookup pattern lookup selectorAkLookup specific polynomialsBjCommitments related to the lookup argumentBiLook up (read) value from a lookup table.2CkThis module represents the Cairo memory, containing the \xe2\x80\xa6EhReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.EeReturns <code>(x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, storing the results in \xe2\x80\xa6DiThis module contains the definition of the <code>MVPoly</code> trait, \xe2\x80\xa6AbNegate: 2^T - selfBbReturns flagset for operation codeCnReturns the 100 step output variables, which correspond to \xe2\x80\xa6BlA prover for the folding/accumulation schemeCeThis module implements prover\xe2\x80\x99s zk-proof primitive.BdPublic key structures and algorithmsCjSet up the number of public inputs. If not invoked, it \xe2\x80\xa6Agnumber of public inputsAhpublic input polynomials1jPublic keyClGenerate a random number of correct lookups in the table \xe2\x80\xa60DgGenerate a random polynomial of maximum degree <code>max_degree</code>.00CiReduce linear combinations in the lookup entries to a \xe2\x80\xa6ChThis module represents a run of a Cairo program as a \xe2\x80\xa6BjBorrows secret key as scalar field elementBaSecret key structures and helpersjSecret keyBiShifts all the coefficients to the right.Acretrieve the shiftsClComputes the sorted lookup tables required by the lookup \xe2\x80\xa6BdThe sorted lookup table polynomials.CjCommitments to the sorted lookup table polynomial (may \xe2\x80\xa6ClReturns the expansion of the 4 dense decomposed quarters \xe2\x80\xa6CfSponge used to coin and absorb values and simulate \xe2\x80\xa6BbCompute the square a field elementB`Compute the square of this valueAfSquare each evaluationAgSRS for the first curveAhSRS for the second curveCnCommitments to the quotient polynomial. The value contains \xe2\x80\xa6BiThe commitment to the quotient polynomialBhThe fixed tables used in the Keccak gateAlDeserialize keypair into hexAoDeserialize public key into hexBjDeserialize compressed public key into hexAoDeserialize secret key into hexA`Serialize to hexBbAssign a unique ID, as a u32 valueBiReturn first 64 bits of the field elementCbThis implements the constraints of the Cairo gatesCjThis module contains the code that executes a compiled \xe2\x80\xa6AoConsume hash <code>input</code>CfThis function verifies the consistency of the wire \xe2\x80\xa6CeChecks that all the lookup constraints are satisfied.1EdVerify a proof <code>ProverProof</code> using a <code>VerifierIndex</code> and a \xe2\x80\xa6FcVerify that the signature <code>sig</code> on <code>input</code> (see <code>Hashable</code>) is \xe2\x80\xa6AhVerify the opening proofCkThis function verifies a batch of polynomial commitment \xe2\x80\xa6ClVerify a proof. Note that it only works for two elements \xe2\x80\xa6C`The commitments to the witness (execution trace)BlThe commitment to the permutation polynomialCmOrder of absorb steps in the computation depending on the \xe2\x80\xa6AcNumber of registersAhA key for a cached valueClA circuit is specified as a public input size and a list \xe2\x80\xa6BmTrait to connect a pair of cells in a circuitCeEC variable base scalar multiplication with group \xe2\x80\xa60CkThis trait defines a common arithmetic operations interfaceAgGeneric arithmetic gateBoImplementation of the <code>Generic</code> gate1AaKeypair structurenId for mainnetCeMaximum number of memory or register accesses per \xe2\x80\xa60AiThe modulus of the field.CjNumber of limbs representing one foreign field element \xe2\x80\xa6BaSecond operand is double indexingBaSecond operand is immediate valueBaOperation code is an assert-equalAjOperation code is a returnCdThis trait contains methods to obtain the offset \xe2\x80\xa6CkNumber of registers that can be wired (participating in \xe2\x80\xa6CdPosition of destination offset of 16 bits within \xe2\x80\xa6CfPosition of first operand offset of 16 bits within \xe2\x80\xa6CgPosition of second operand offset of 16 bits within \xe2\x80\xa6ChA running program that the (folding) interpreter has \xe2\x80\xa6AeResult is an additionAjResult is a multiplicationAjResult is a single operandAmRandom oracle input structureCgSchnorr signer context for the Mina signature algorithmCmYou can use SerdeAs with serde_with in order to serialize \xe2\x80\xa6AjVariants of Keccak spongesAcId for all testnetsCmA clone of the SRS struct that is used for serialization, \xe2\x80\xa6ClSince we don\xe2\x80\x99t have a specific type for the wires of a \xe2\x80\xa6ClFor PlonK, it will be the polynomials in evaluation form \xe2\x80\xa6CnThe witness columns used by a gate of the MSM circuits. It \xe2\x80\xa6CdThe type that represents the execution trace. It \xe2\x80\xa6CbReturns the destination address of the instructionCdReturns the first operand address of the instructionCeReturns the second operand address of the instructionDhIf the <code>Value</code> is a Boolean, returns the associated bool. \xe2\x80\xa6DhIf the <code>Value</code> is a Null, returns (). Returns None otherwise.EfExtract the bits from the variable <code>x</code> between <code>highest_bit</code> \xe2\x80\xa60CcBlinder used for the commitments to the cross termsChCreates a constraint to enforce that b is either 0 or 1.AdConstrain to booleanCmDefine the different structures required for the examples \xe2\x80\xa6CnThis module contains description of the additional columns \xe2\x80\xa6CeIVC circuit layout - Top level documentation outdatedCjThe column layout will be as follow, supposing a state \xe2\x80\xa6CmCombine two objects \xe2\x80\x98a\xe2\x80\x99 and \xe2\x80\x98b\xe2\x80\x99 into a new object \xe2\x80\xa6CjCombine two relaxed instances into a new relaxed instance.B`Compose field limbs into BigUintAjCompose limbs into BigUintCmComposes a vector of 4 dense quarters into the dense full \xe2\x80\xa6CnThe final decider, i.e. the SNARK used on the accumulation \xe2\x80\xa6ClInitialize the environment for creating Expr constraints \xe2\x80\xa6BoReturns an instance with all features disabled.CmCreates a default proof instance. Note that such an empty \xe2\x80\xa6CnThis function creates an instance of a default CairoContext\xe2\x80\xa6CgReturns the (x,q)-th term of ThetaDenseC, as a variableBnReturns the (y,x,q)-th variable of PiRhoDenseEClThis module describes the evaluation domains that can be \xe2\x80\xa6BhReturns flagset for destination registerCdProvides a full list of entries for the given table.0BoVector of values inside each entry of the table1111C`Executes a Cairo step from the current registersCdThis library implements basic components to fold \xe2\x80\xa6BkCreates a new set of wires for a given row.ClInitializes a new foreign element from a set of bytes in \xe2\x80\xa6BoThis module implements the double generic gate.CnMutably index into a JSON array or map. A string index can \xe2\x80\xa6ClObtains an SRS for a specific curve from disk. Panics if \xe2\x80\xa6CnThe index of the latest allocated variable in the circuit. \xe2\x80\xa6AeInverse of a variable00DcReturns true if the <code>Value</code> is a Null. Returns false \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6BaKeypair structures and algorithmsCjConvenience function for constructing expressions from \xe2\x80\xa60A`Create a literalCgReturns the layout of the lookups used by this pattern.ClInstantiations of Logups for the MSM project Instantiate \xe2\x80\xa6CdInstantiation of the lookups for the VM project. \xe2\x80\xa6BkVariables that are looked up in the circuitCjCreates all possible lookups to the Keccak constraints \xe2\x80\xa6CmThis function computes the next program counter Panics if \xe2\x80\xa6CgReturns the destination offset in biased representationCiReturns the first operand offset in biased representationCjReturns the second operand offset in biased representationBjReturns flagset for first operand registerBkReturns flagset for second operand registerAbThe opening proof.CmThis type and logic only exists for the OCaml side. As we \xe2\x80\xa6Bgthe challenges produced in the protocolBmThis function runs the random oracle argumentgOracles0CkThis module defines Property-based tests for the SRS trait.CmPickles flavor of the o1vm. This is the pickles flavor of \xe2\x80\xa6BcLooks up a value by a JSON Pointer.CeCreates a new lazy value that is already initialized.CnReturns the product of all the field elements belonging to \xe2\x80\xa6CbReads one value when <code>if_is_true</code> is 1.BaReturns flagset for result logicsBmRandom oracle input structures and algorithmsAcRun the applicationBbRun an iteration of the IVC schemeDiSet up the runtime tables. If not invoked, it is <code>None</code> by \xe2\x80\xa6CbOptional commitment to concatenated runtime tablesCnThis module implements Plonk prover polynomial evaluations \xe2\x80\xa6AmMina Schnorr signature schemeBnThis function computes the destination addressC`This function computes the first operand addressCiThis function computes the second operand address and \xe2\x80\xa6CiThis function computes the value of the result of the \xe2\x80\xa6BaSqueeze an output from the spongeCmReturns the (y,x,q)-th input of the theta algorithm, as a \xe2\x80\xa6DdReturns the <code>idx</code>-th output of a round step as a variableAaSerialize to bitsDkWrites a <code>VerifierIndex</code> to a file, potentially appending it \xe2\x80\xa6e2^powlPower of twoBmReturns a variable representing the value 2^xCkThe witness of the current instance of the circuit. The \xe2\x80\xa6CfThis is the original witness, without quadraticizationAgWitness cell (row, col)lWitness rowsCgThis module computes the witness of a foreign field \xe2\x80\xa6C`Foreign field multiplication witness computationAoRange check witness computationBeApply the <code>witness</code> value.AjKeccak witness computationCiHelper function to quickly create an expression for a \xe2\x80\xa6AnThe witness column polynomialsCmThe witness columns that the environment is working with. \xe2\x80\xa6CnThe witness column polynomials. Includes relation columns, \xe2\x80\xa6CfThis file contains the witness for the Keccak hash \xe2\x80\xa6BkThe full state of the Keccak gate (witness)CmThe witness column polynomials. Includes relation columns \xe2\x80\xa6BaThe number of zero-knowledge rowsCgthe number of randomized rows to achieve zero knowledgeCdThe interface for a minimal argument implementation.ClSelector for blocks. Inner usize is \xe2\x88\x88 [0,#blocks). The \xe2\x80\xa6BiFormat: <code>beq rs1, rs2, offset</code>CkThe number of bits that can be reliably stored. (Should \xe2\x80\xa6A`Handy re-exportsBbA constant value in our expressionBoLook up the value from the given fixed table IDBmWitness cell copied from another witness cellBjResult of a folding expression evaluation.CnThis trait contains methods that decompose a field element \xe2\x80\xa60DgAbstracts a sponge operating on a base field <code>Fq</code> of the \xe2\x80\xa6CnAbstracts a sponge that operates on the scalar field of an \xe2\x80\xa6CjThe different types of gates the system supports. Note \xe2\x80\xa6ClHandy re-exports The different types of gates the system \xe2\x80\xa6AnInterface for hashable objectsDdIdentity <code>MPrism</code> from any type <code>T</code> to itself.ClFor Plonk, it will be the commitments to the polynomials \xe2\x80\xa6BgFormat: <code>lb rd, offset(rs1)</code>BgFormat: <code>lh rd, offset(rs1)</code>BgFormat: <code>lw rd, offset(rs1)</code>CmNumber of alphas needed for the IVC circuit, equal is the \xe2\x80\xa6B`Number of blocks in the circuit.AhOperation code is a callCnThis trait contains functions to obtain the Cairo pointers \xe2\x80\xa6CfRepresent a polynomial commitment when the type is \xe2\x80\xa6AiPoseidon permutation gateCnImplementation of the Poseidon gate Poseidon quotient poly \xe2\x80\xa61AgPoseidon hasher contextBmA position can be seen as an indexed variable0CjAn element of the Keccak state is 64 bits. However, we \xe2\x80\xa6CfColumns related to the relation encoded in the circuitCfRepresent a dynamic selector, in the case of using \xe2\x80\xa6C`A \xe2\x80\x9cvirtual\xe2\x80\x9d selector that can be used to \xe2\x80\xa6ClThe variable should be seen as a certain object that can \xe2\x80\xa6ChA type representing a variable which can appear in a \xe2\x80\xa6DkAbsorbs a base field point, that is a pair of <code>Fq</code> elements. \xe2\x80\xa6CjAllocate a new variable in the circuit for the current rowCeThe application size, i.e. the number of rows per \xe2\x80\xa6CkAn argument is simply a number of constraints, which we \xe2\x80\xa6ChArkworks types This module contains wrapper types to \xe2\x80\xa6DiIf the <code>Value</code> is an Array, returns the associated vector. \xe2\x80\xa6CkA blinding factor used to hide the polynomial, if necessary0CmFrom a canonical expanded state, obtain the corresponding \xe2\x80\xa6CkConvenience function for constructing constant expressions.0AaCreate a constantCiConstant value (see ConstantExpr for supported constants)CbConvenience function to create a constant as Expr.BgTurns a constant value into a variable.BjCreates a variable from a constant integerAhReturns the current row.00CaThis function is bound to be stable soon. See \xe2\x80\xa6BlEvaluate an expression into a field element.ChEvaluate an expression as a field element against an \xe2\x80\xa601BnEvaluate an RPN expression to a field element.Bievaluate witness polynomials over domainsBnEvaluate the combined value of a joint-lookup.CiEvaluate the linear combination specifying the lookup \xe2\x80\xa61ClEvaluate the combined value of a joint-lookup, resolving \xe2\x80\xa6ChGiven the evaluations form of a polynomial, directly \xe2\x80\xa6ChExtra columns added by quadraticization to lower the \xe2\x80\xa6CjCommitments to the extra columns added by quadraticizationCjReturns bit-flag for allocation counter update being a \xe2\x80\xa60CkReturns bit-flag for destination register as <code>F</code>CmReturns bit-flag for first operand register as <code>F</code>CfReturns bit-flag for allocation pointer for second \xe2\x80\xa6DhReturns bit-flag for frame pointer for second register as <code>F</code>CnReturns bit-flag for program counter update being absolute \xe2\x80\xa6CeReturns bit-flag for program counter update being \xe2\x80\xa6CnReturns bit-flag for program counter update being relative \xe2\x80\xa6CbThe features enabled for this lookup configurationBgDeserialize keypair from secret key hexAoDeserialize public key from hexBjDeserialize compressed public key from hexAoDeserialize secret key from hexCjCreates a BigUint from an hexadecimal string in big endianBbDeserialize from little-endian hexAhBuild a value from a u32BlThe evaluation f(zeta) - t(zeta) * Z_H(zeta)CkEvaluation of Z_H(\xce\xb6) (t_0(X) + \xce\xb6^n t_1(X) + \xe2\x80\xa6) at \xce\xb6\xcf\x89.BoRequired evaluation for Maller\xe2\x80\x99s optimizationCnThe full SRS is the one used by the prover. Can be seen as \xe2\x80\xa6Cgcreates a set of test vectors Uses a custom seed if \xe2\x80\xa6CnFollows approach of SvdW06 to construct a \xe2\x80\x9cnear injection\xe2\x80\xa6CiInitialize a witness row based on layout and computed \xe2\x80\xa6AfThe original instance.DeReturns true if the <code>Value</code> is an Array. Returns false \xe2\x80\xa6ChReturns <code>true</code> if the runtime table is empty.EeReturns <code>true</code> if the lookup table is empty, <code>false</code> otherwise.CeReturns <code>true</code> if the commitment is empty.ClReturns whether the memory is empty (either length 0, or \xe2\x80\xa6AlAll tables are fixed tables.CmIdentify fixed and RAMLookups with a boolean. This can be \xe2\x80\xa61111ClNaive implementation checking if n is prime You can also \xe2\x80\xa6CnCheck if a number is prime using the list of prime numbers \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6DgReturns a <code>LegendreSymbol</code>, which indicates whether this \xe2\x80\xa6ChReturns a degree-1 variable that encodes whether the \xe2\x80\xa6CnEC variable base scalar multiplication selector polynomial \xe2\x80\xa6AkProgresses to the next row.BmProgress to the computations on the next row.11CmReturns the number of XOR rows needed for inputs of usize \xe2\x80\xa6ClA collection of utility functions and constants that can \xe2\x80\xa6CdA single lookup constraint is a vector of lookup \xe2\x80\xa6CnComputes the poseidon hash of several field elements. Uses \xe2\x80\xa6CkThis module implements the Poseidon constraint polynomials.AdMina Poseidon hasherCgThis module implements Poseidon Hash Function primitiveClPoseidon This file defines wrapper for the Poseidon hash \xe2\x80\xa6BcYou can import this module like \xe2\x80\xa6Cbposeidon constraint selector polynomial commitmentClOutputs the state into dense quarters of 16-bits each in \xe2\x80\xa6AmReads one value from a table.CnRegisters a new ArgumentType, associating it with a number \xe2\x80\xa6oRot commitmentsCksimilar to Self::col, but folding may ask for a dynamic \xe2\x80\xa6ClReturns the selector of the current step in standardized \xe2\x80\xa6BoReturns the (i,y,x,q)-th variable of ChiShiftsBBoReturns the (i,x,q)-th variable of ThetaShiftsCCaReturns the (i,y,x,q)-th variable of PiRhoShiftsECnThe ID for the table associated with this lookup. Positive \xe2\x80\xa600BdTable ID corresponding to this tableBfSerialize random oracle input to bytesAnDeserialize keypair into bytesBaDeserialize public key into bytesBlDeserialize compressed public key into bytesBaDeserialize secret key into bytesAbSerialize to bytesBhAssign a unique ID to the lookup tables.BgConvert BigUint into PrimeField elementBdConvert to 3 limbs of LIMB_BITS eachBlConvert limbs from field elements to BigUintCkReturns the variable corresponding to a given column alias.BnA verifier for the folding/accumulation schemeCbThis module implements zk-proof batch verifier \xe2\x80\xa6CcWrites one value when <code>if_is_true</code> is 1.oXor commitmentsCnPad with zeroes and then add 3 random elements in the last \xe2\x80\xa6AgBase field element typeBiFormat: <code>bne rs1, rs2, offset</code>CeA data structure to store a current step of Cairo \xe2\x80\xa6ClA Cairo word for the runner. Some words are instructions \xe2\x80\xa6CnThe type of an abstract challenge that can be found in the \xe2\x80\xa6CcA challenge used by the PIOP or the folding scheme.DfThe collection of constants required to evaluate an <code>Expr</code>.ChA trait extending CommitmentCurve for endomorphisms. \xe2\x80\xa6BlColumns used by the FEC Addition subcircuit.AoColumn indexer for MSM columns.DiA multiplicative generator of the field. <code>Self::GENERATOR</code> \xe2\x80\xa6CmRepresents an error found when verifying a witness with a \xe2\x80\xa6Cn<code>GateWires</code> document the wiring of a gate. More \xe2\x80\xa6CfHash identifier to distinguish inside the syscalls \xe2\x80\xa6ChWitness cell assigned from an indexable variable See \xe2\x80\xa6B`Represents any valid JSON value.CkThis struct contains all that needs to be kept track of \xe2\x80\xa6BfLimb length for foreign field elementsBhA thread-safe, lazily-initialized value.BfCapability for invoking table lookups.AeNumber of Cairo flagsCiTotal number of columns in the serialization circuit, \xe2\x80\xa6BgMina network (or blockchain) identifierCiBit position of the beginning of the flags in a Cairo \xe2\x80\xa6CnAll [1..136] values of possible padding lengths, the value \xe2\x80\xa6A`Public key errorAmStruct containing a RAMLookupCjThis represents the internal state of the virtual machine.0ClThe number of field elements used to represent the whole \xe2\x80\xa6AbInvalid secret keyAcSignature structureCkSkip the given number of tokens if the feature is disabled.ChHash step identifier to distinguish inside interstep \xe2\x80\xa6BfAn iterator over the variants of StepsBhFormat: <code>sb rs2, offset(rs1)</code>BhFormat: <code>sh rs2, offset(rs1)</code>BhFormat: <code>sw rs2, offset(rs1)</code>ClStructure which could be storing useful information like \xe2\x80\xa6CkLayout variables mapping - these values are substituted \xe2\x80\xa6CdAbsorb an element of the base field into the sponge.ClAbsorbs a base field element. This operation is the most \xe2\x80\xa6DiAbsorbs an element of the scalar field <code>Fr</code> \xe2\x80\x94 it is done \xe2\x80\xa6EfIf the <code>Value</code> is a Number, returns the associated <code>Number</code>. \xe2\x80\xa6DgIf the <code>Value</code> is an Object, returns the associated Map. \xe2\x80\xa6Cnfunction to avoid optimizations by the compiler taken from \xe2\x80\xa6DhA macro similar to <code>vec![$elem; $size]</code> which returns a boxedBjReturns ceil(log2(d)) but panics if d = 0.ClObtains a given challenge from the expanded instance for \xe2\x80\xa6CoCreates a <code>ScalarChallenge</code> by squeezing the sponge.CkSqueeze out a challenge in the scalar field. Implemented byiConstantsAhConstant values required00CgAdds one KeccakConstraint to the environment if the \xe2\x80\xa6EgChecks the constraint <code>tag</code> by checking that the input <code>x</code> is \xe2\x80\xa6CmTakes a dense u64 word and decomposes it into a vector of \xe2\x80\xa6CkReturns a base field digest by squeezing the underlying \xe2\x80\xa6mDomain for FpmDomain for FqChendoscalar multiplication selector polynomial commitmentCfThe error vector, introduced when homogenizing the \xe2\x80\xa6CdA challenge to aggregate multiple evaluation points.CiEvaluate an expression as a field element against the \xe2\x80\xa60ClReturns bit-flag for immediate value for second register \xe2\x80\xa6DfReturns bit-flag for operation being an assert-equal as <code>F</code>CoReturns bit-flag for operation being a return as <code>F</code>DgReturns bit-flag for addition operation in right side as <code>F</code>CjReturns bit-flag for multiplication operation in right \xe2\x80\xa6BoA sponge that acts on the base field of a curveAeDeserialize from bitsClBuild a value from an expression. This method aims to be \xe2\x80\xa6DjDeserializes a <code>VerifierIndex</code> from a file, given a pointer \xe2\x80\xa6DiReturns the lookup pattern used by a <code>GateType</code> on a given \xe2\x80\xa6DiCreate a <code>Value::Array</code> by collecting an iterator of array \xe2\x80\xa6DdCreate a <code>Value::Object</code> by collecting an iterator of \xe2\x80\xa6DfReturns the lookup table associated to a <code>GateLookupTable</code>.D`Write into a <code>serde_json::Value</code> using the syntax \xe2\x80\xa6CjInitialize a witness cell based on layout and computed \xe2\x80\xa6BhIterate over the columns in the circuit.BeIterate over the instruction variants0ClReturns a variable that encodes whether the current step \xe2\x80\xa6BfChecks if a value is in a given table.000DeReturns true if the <code>Value</code> is a Number. Returns false \xe2\x80\xa6DfReturns true if the <code>Value</code> is an Object. Returns false \xe2\x80\xa6ClSELECTOR OPERATIONS /// Returns a degree-2 variable that \xe2\x80\xa6DeReturns true if the <code>Value</code> is a String. Returns false \xe2\x80\xa6B`Converts the expression in LaTeX0ClThere is an optimization in PLONK called \xe2\x80\x9clinearization\xe2\x80\xa60ChMultiplies the chunks of a polynomial with powers of \xe2\x80\xa68ChOptional coefficient that can be multiplied with the \xe2\x80\xa6EdReturns <code>((x * y) &gt;&gt; 32, (x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, \xe2\x80\xa6DdReturns the <code>idx</code>-th new state expanded quarter, as a \xe2\x80\xa6CmReturns the numerator corresponding to this lookup in the \xe2\x80\xa6BeConverts the expression in OCaml code0DdReturns the <code>idx</code>-th old state expanded quarter, as a \xe2\x80\xa6Cgpermutation linearization poly contribution computationCbpermutation quotient poly contribution computationAc\xcf\x95^i,   i \xe2\x88\x88 [N+1]Bf1-st Lagrange evaluated over domain.d8ClA challenge to combine polynomials. Powers of this point \xe2\x80\xa6AhThe RAM lookup argument.BaAll the registers used by the ISACgAn interpreter for the RISC-V 32IM instruction set, \xe2\x80\xa6BeThe lookup-type selector polynomials.B`Serialize the ROInput into bytesCmYou can use this to serialize an arkworks type with serde \xe2\x80\xa6BoMina signature structure and associated helpersCeThe sponges will be used to simulate the verifier \xe2\x80\xa6DiTable IDs for the lookup values. This may be <code>None</code> if all \xe2\x80\xa60DkReturns 1 if <code>x</code> is 0, or 0 otherwise, storing the result in \xe2\x80\xa60CmElements to absorbed in IVC, in the same order as done in \xe2\x80\xa6CmThis method returns the scalars and commitments that must \xe2\x80\xa6C`Return the elements to be absorbed by the spongeCaReturns the elements to be absorbed by the spongeBbDeserialize secret key into base58ChFlatten the column \xe2\x80\x9calias\xe2\x80\x9d into the integer-like \xe2\x80\xa6AhAlias for to_field_limbsCiSerialize random oracle input to vector of base field \xe2\x80\xa6CcReturn a field element in hexadecimal in big endianBkCompile an expression to an RPN expression.0D`Return <code>pos</code>-th 16-bit chunk as another field elementeUtilsBlMacro to simplify mapping of layout variable0AlWrites one value to a table.ClReturns the output of an absorb sponge, which is the XOR \xe2\x80\xa6AlReturns the XOR lookup tableAbBitwise operationsn1 hash per rowCgBlock index inside the hash to enumerate preimage bytesCmAll values that can be stored in a byte (amortized table, \xe2\x80\xa6eCairo0ClA structure to store program counter, allocation pointer \xe2\x80\xa6Ck3 88-bit inputs. For the row #i this represents the IPA \xe2\x80\xa6CgCommitment round challenges (endo mapped) and their \xe2\x80\xa6ClPrevious coefficient C_j, this one is looked up. For the \xe2\x80\xa6AnInvalid constraint with numberChAll the names for constraints involved in the Keccak \xe2\x80\xa6CnA row accessible from a given row, corresponds to the fact \xe2\x80\xa6CgHandy re-exports A row accessible from a given row, \xe2\x80\xa6CkA fixed selector column that gives one the current row, \xe2\x80\xa6CcImplementation of the <code>EndosclMul</code> gate.CkContains the evaluation of a polynomial commitment at a \xe2\x80\xa6Ckextra nodes created by folding, should not be passed to \xe2\x80\xa6ChDescribe a folding environment. The type parameters are:CiInternal expression used for folding. A \xe2\x80\x9cfolding\xe2\x80\x9d \xe2\x80\xa6AnNumber of gates in this gadgetBgAn iterator over the variants of GadgetCbNumber of desired limbs for foreign field elementsBkDescribes the desired lookup configuration.ChEnum representing the two different modes of a RAMLookupCdThe maximum degree of the polynomial that can be \xe2\x80\xa6BbThe maximum degree of a constraintCaThe number of columns in the poseidon permutationCkNumber of columns in the test circuits, including fixed \xe2\x80\xa6BnNumber of fixed selectors for the IVC circuit.CdNumber of fixed selectors for serialization circuit.CiRepresents a curve that has a static name attached to it.CkDefine a structured reference string (i.e. SRS) for the \xe2\x80\xa6BiThe number of field elements in the stateBnErrors that can arise when preparing the setupCgEnabled if the table width is at least the given numberAdTest column indexer.BfEC variable base scalar multiplication0CbImplementation of the <code>VarbaseMul</code> gateAcInvalid wire columnCkAdds a given Lookup to the environment if the condition \xe2\x80\xa6Althe computed powers of alphaB`Append a 32-bit unsigned integerB`Append a 64-bit unsigned integerCnObtains the representation of some constants as a literal. \xe2\x80\xa6CnAuto clone macro - Helps make constraints more readable by \xe2\x80\xa60ClFlagged as unsafe as it does require an additional range \xe2\x80\xa60CmReturns the bits between [highest_bit, lowest_bit] of the \xe2\x80\xa6DkA macro similar to <code>vec![vec![$elem; $size1]; $size2]</code> which \xe2\x80\xa6CiOn input a vector of 16-bit dense quarters, outputs a \xe2\x80\xa6CkWhile folding, we must keep track of the challenges the \xe2\x80\xa6AhChallenges from the IOP.00DhSame as <code>prechallenges</code>, but maps scalar challenges using \xe2\x80\xa6AmCapture the trace/checkpoint.CkThis module will be used by the prover to evaluate at a \xe2\x80\xa6CkThis module implements Dlog-based polynomial commitment \xe2\x80\xa6CjThe commitment of the polynomial being evaluated. Note \xe2\x80\xa6BeCompute the x^5 of the given variableCkCreate one rotation Right now it only creates a Generic \xe2\x80\xa6DiReturns <code>x / y</code>, storing the results in <code>position</code>.AkA module to load ELF files.CbThis module implements short Weierstrass curve \xe2\x80\xa6DkExtends an AND gadget for <code>bytes</code> length. The full operation \xe2\x80\xa6CkExtend one rotation Right now it only creates a Generic \xe2\x80\xa6BnExtends the rot rows to the full witness InputCmReturns bit-flag for operation being a call as <code>F</code>BiDeserialize keypair from secret key bytesBaDeserialize public key from bytesBlDeserialize compressed public key from bytesBaDeserialize secret key from bytesAfDeserialize from bytesClInitializes a new foreign element from an element in the \xe2\x80\xa6CjApply a full round of the permutation. A full round is \xe2\x80\xa6BjReturns the alphas values for the instanceClThis function allows us to retrieve the powers of alpha, \xe2\x80\xa6CkReturn the evaluation of the given column, over the domain.CkThis method is exported in the WebAssembly to check the \xe2\x80\xa6BdReturns the hash index as a variableCjThe index of the latest allocated public inputs in the \xe2\x80\xa6DkReturns a variable that encodes whether the <code>idx</code>-th byte of \xe2\x80\xa6CjCOmpute the inner product of two slices of field elements.AoConversion into vector of bytesCiTransforms the current RAMLookup into an equivalent LogupBcConvert public key into curve pointDfReturns true if the <code>Value</code> is a Boolean. Returns false \xe2\x80\xa6CmDegree-2 variable encoding whether the input is a boolean \xe2\x80\xa6CiDegree-2 variable encoding whether the first input is \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6DkThis is a polyfill of the <code>LazyLock</code> type in the std library \xe2\x80\xa6CmOptional coefficient that can be multiplied with the left \xe2\x80\xa6AnAdds a lookup to the Pad tableDiReturns <code>x % y</code>, storing the results in <code>position</code>.4CnNext row in the execution trace. It is useful when we deal \xe2\x80\xa6ChNullifies the Witness and Constraint environments by \xe2\x80\xa6CmNumber of blocks to be absorbed on input a given preimage \xe2\x80\xa6DiReturns <code>x or y</code>, storing the result in <code>position</code>.0CiThis function returns a vector of field elements that \xe2\x80\xa6CiReturns a variable that encodes the bytelength of the \xe2\x80\xa6DhReturns a variable that encodes the <code>idx</code>-th chunk of the \xe2\x80\xa6AeParameter type to useBfParse a hex string into a 32-byte seedDjThe <code>Marlin_plonk_stubs</code> crate exports some functionalities \xe2\x80\xa6CmThe Marlin_plonk_stubs crate exports some functionalities \xe2\x80\xa6CjThis module implements Plonk prover polynomials primitive.AjProgram state for curve E1AjProgram state for curve E2fCurves0ChReturns the (x)-th term of ThetaQuotientC, as a variableCaReturns the (y,x,q)-th variable of PiRhoQuotientEEgReturn the result of shifting <code>x</code> by <code>by</code>, storing the result \xe2\x80\xa60CaReturns the (i,y,x,q)-th variable of ChiShiftsSumAlpermutation commitment arrayBdReturns the step index as a variableDfReturns the lookup table associated to a <code>GateLookupTable</code>.CjCircuit generator function for A_0 * B_0 - const, with \xe2\x80\xa6BdSerialize field element to a BigUintCiObtains the big integer representation of the foreign \xe2\x80\xa6BdSerialization to random oracle inputCfReturns a variable that encodes the value 2^pad_lengthCkThis module implements short Weierstrass curve variable \xe2\x80\xa6DiEvaluation at <code>zeta . omega</code>, the product of the challenge \xe2\x80\xa6BhAn iterator over the variants of AbsorbsCgThe argument environment is used to specify how the \xe2\x80\xa6Bi2*17 15-bit limbs (two base field points)CiCoeffifient which is indexing a bucket. Used for both \xe2\x80\xa6cu_LCdThis trait contains helper functions for boolean \xe2\x80\xa6CbThe number of constraints created by the argument.BoNumber of constraints produced by the argument.BkNumber of constraints produced by the gate.1CdThis data structure stores the memory of the programAkA single gate in a circuit.CkThe resulting coefficient C_i = C_{i - 2^{ceil(log i) - \xe2\x80\xa6DgEnvironment capability similar to <code>ColAccessCap</code> but for \xe2\x80\xa6CgAbstract columns (or variables of our multi-variate \xe2\x80\xa6ClColumn aliases used by the Keccak circuit. The number of \xe2\x80\xa6BcComplete EC addition in Affine formDcImplementation of the <code>CompleteAdd</code> gate It uses the \xe2\x80\xa61CkDomain size for the MSM project, equal to the BN254 SRS \xe2\x80\xa6CnThe collection of polynomials (all in evaluation form) and \xe2\x80\xa6CiPolynomial represented by its evaluations over a domain DCkThe feature flags that can be used to enable or disable \xe2\x80\xa6CiLens used to convert between IVC columns and Poseidon \xe2\x80\xa6CcA list of instruction/gadget implemented in the \xe2\x80\xa6ClThis trait includes functionalities needed to obtain the \xe2\x80\xa6CjA spec for checking that the given vector belongs to a \xe2\x80\xa6AoFormat: <code>jal rd,imm</code>BnThe number of columns the Keccak circuit uses.CkRepresents additional information that a curve needs in \xe2\x80\xa6CgRepresents an error found when computing the lookup \xe2\x80\xa6CeRepresents the proof of the lookup argument It is \xe2\x80\xa6CjA table of values that can be used for a lookup, along \xe2\x80\xa60CjEnumeration of concrete lookup tables used in FEC circuit.CiEnumeration of concrete lookup tables used in lookups \xe2\x80\xa6CaEnumeration of concrete lookup tables used in \xe2\x80\xa6CmRepresents one line of the execution trace of the virtual \xe2\x80\xa6BnNumber of fixed selectors in the test circuit.BdAll the witness columns used in MIPSBhOperation code is a jump or an incrementBeFormat: <code>ori rd, rs1, imm</code>AhThe permutation argumentCkFor efficiency of evaluation, we compile expressions to \xe2\x80\xa6BkErrors that can arise when creating a proof000AlThe index used by the proverCnThe proof that the prover creates from a ProverIndex and a \xe2\x80\xa6AaPublic key errorsBhHelper to generate random field elementskRange check0nx \xe2\x88\x88 [0, 2^4]CnDual-column table of all values in the range [0, 2^16) and \xe2\x80\xa6BnThe number of columns the Sponge circuit uses.CjThe order in a row in which we store states before and \xe2\x80\xa6AiScalar field element typeCnContains vectors of scalars in small limb representations. \xe2\x80\xa6mKeypair errorBeFormat: <code>slt rd, rs1, rs2</code>BhAn iterator over the variants of SpongesDiLet <code>N</code> be the size of the multiplicative group defined by \xe2\x80\xa6BcTwo to the power of the limb lengthBlErrors that can arise when verifying a proofCmWitness cell interface. By default, the witness cell is a \xe2\x80\xa6AdInvalid x-coordinateDkReturns <code>x + y</code> and the overflow bit, storing the results in \xe2\x80\xa60CmComputes the aggregation polynomial for maximum n lookups \xe2\x80\xa6DiReturns <code>x or y</code>, storing the result in <code>position</code>.0AcAppend a single bitB`Assert that the variable is zeroAoAsserts that the value is zero.CmConjunction of the bits of two BigUint inputs for a given \xe2\x80\xa6CkNegate the bits of a Self input If it provides a larger \xe2\x80\xa6BaBitwise XOR of two BigUint inputsBeReturns the block index as a variableDjReturns a variable that encodes the <code>idx</code>-th block of bytes \xe2\x80\xa6EaCheck that the witness values in <code>x</code> and <code>y</code> are equal; \xe2\x80\xa60CkChunk of consecutive coefficients in an interval [from, to)BbThe coefficient column polynomialsAfCombine where x1 = oneCdAll the polynomial commitments required in the proofCjThis module implements Plonk circuit constraint primitive.AnA number of useful constraintsCiReturns the set of constraints required to prove this \xe2\x80\xa6C`Specifies the lookup constraints as expressions.CfReturns the constraints related to the runtime tables.AnAn indexed set of constraints.CiThis module contains the constraints for one Keccak step.BiConstraints that are added to the circuitCfCreates all 879 constraints/checks to the environment:CbCurrent processing row. Used to build the witness.AeDeclare traces group.BoReturns the (x,q)-th variable of ThetaDenseRotCCaReturns the (y,x,q)-th variable of PiRhoDenseRotEBmDeserialize a <code>ROInput</code> from bytesCiYou can use this to deserialize an arkworks type with \xe2\x80\xa6CeReturn the domain size of the individual evaluations.CnDegree-2 variable encoding whether at least one of the two \xe2\x80\xa6CmThis module contains the definition and implementation of \xe2\x80\xa6ClCompute the polynomial corresponding to this expression, \xe2\x80\xa6000CnActual values w_i of the witness columns. \xe2\x80\x9cEvaluations\xe2\x80\x9d\xe2\x80\xa6CiThis adds a few utility functions for the Evaluations \xe2\x80\xa6CkContains an evaluation table. For instance, for vanilla \xe2\x80\xa6CkA list of evaluations, each supposed to correspond to a \xe2\x80\xa6CiExpands a u64 word into a vector of 4 sparse u64 quartersCmImplement a library to represent expressions/multivariate \xe2\x80\xa6BaFetch an input of the applicationDkReturns a vector of pad bytes flags as variables, with <code>idx</code> \xe2\x80\xa6ltest helpersBeDeserialize base58 encoded secret keyClCOLUMN OPERATIONS /// This function returns the composed \xe2\x80\xa6ChA GateVector: this is used to represent a list of gates.CmVectors A GateVector: this is used to represent a list of \xe2\x80\xa6BaGenerate the <code>witness</code>DbGenerates the <code>witness_curr</code> values for a series of \xe2\x80\xa6ClObtain the Mina address corresponding to the keypair\xe2\x80\x99s \xe2\x80\xa6CkReturn the blinder that can be used while committing to \xe2\x80\xa6CkReturns the blinder value. It is the same as the one of \xe2\x80\xa6AmGet size of the public memoryDhInstantiates the ranges with an actual field element <code>alpha</code>.CmThis module contains the implementation of the IVC scheme \xe2\x80\xa6CkImplement an interpreter for a specific instance of the \xe2\x80\xa600CkThis module defines the Keccak interpreter in charge of \xe2\x80\xa6CkThis module implement an interpreter for the RISCV32 IM \xe2\x80\xa6BlConvert secret key into scalar field elementCdReturn true if the no extra columns are added by \xe2\x80\xa6CjInstantiates the IVC circuit for folding. L is relaxed \xe2\x80\xa6CaConverts a value to its index in the fixed table.0CjReturns None if the table is runtime (and thus mapping \xe2\x80\xa6111CiImplements a tool to visualize a circuit as an HTML page.AoAdds a lookup to the Byte tableBkInformation about the specific lookups used0BgAdds a lookup to the RangeCheck16 tableCkSame as SRS::mask except that you can pass the blinders \xe2\x80\xa6DgThe maximum length of an element of <code>kinds</code>. This can be \xe2\x80\xa60kMina hasherkMina signerClReturns a variable that encodes whether the current step \xe2\x80\xa6DjReturns <code>x nor y</code>, storing the result in <code>position</code>.0BhOutput file path, use \xe2\x80\x9c-\xe2\x80\x9d for stdoutBnpermutation aggregation polynomial computationCjThis module implements permutation constraint polynomials.CmThe permutation module contains the function implementing \xe2\x80\xa6Adr\xc2\xb7\xcf\x95^i, i \xe2\x88\x88 [N+1]fProofsClLooks up a value by a JSON Pointer and returns a mutable \xe2\x80\xa6DhSet the memory value at address <code>addr</code> to <code>value</code>.0Dfgenerates a vector of <code>length</code> field elements using the \xe2\x80\xa6BcRange check pattern lookup selectorAaRange check tableAgRange check gate moduleBcReads value from a column position.C`Returns the (x,q)-th variable of ThetaRemainderCCbReturns the (y,x,q)-th variable of PiRhoRemainderECnOptional coefficient that can be multiplied with the right \xe2\x80\xa6CnSet the value of a pointer. This method is exported in the \xe2\x80\xa6EgReturn the result of shifting <code>x</code> by <code>by</code>, storing the result \xe2\x80\xa60DiGiven a variable <code>x</code>, this function extends it to a signed \xe2\x80\xa60DaReturns the <code>idx</code>-th byte of the sponge, as a variableBmStandardizes a Keccak step to a common opcodeDiReturns <code>x + y</code> and the underflow bit, storing the results \xe2\x80\xa60Bffixed tables pre-existing the protocolAeTake captured traces.AbAlias for to_limbsm2^{LIMB_BITS}0e2^{B}CjThis function updates the next step of the environment \xe2\x80\xa6CeReturns the 20 variables corresponding to ThetaDenseCCfReturns the 100 variables corresponding to PiRhoDenseEChVerifier of the folding scheme; returns a new folded \xe2\x80\xa6CeEnvironment for the witness (includes multiplicities)DjReturns <code>x xor y</code>, storing the result in <code>position</code>.0BfFormat: <code>addi rd, rs1, imm</code>BfFormat: <code>andi rd, rs1, imm</code>CkArgument environment data for constraints of field elementsCjA constraint type represents a polynomial that will be \xe2\x80\xa6CgThis trait contains helper functions for arithmetic \xe2\x80\xa6jConstant rBeScalar coeff #1, powers of Phi, phi^iA`2*4 75-bit limbs022CgA structure to store auxiliary variables throughout \xe2\x80\xa6CjThis struct stores the needed information to run a programA`Handy re-exportsCmEnvironment capability for accessing and reading columns. \xe2\x80\xa6B`Witness cell with constant valueCnDefine the constant terms an expression can use. It can be \xe2\x80\xa6CeWitness cell copied from bits of another witness cellCmThis trait can be implemented on any type that implements \xe2\x80\xa6C`Extra expressions that can be created by foldingCdFlags for optional features in the constraint systemClField element helpers Unless otherwise stated everything \xe2\x80\xa6CbA trait that defines parameters for a prime field.mKeypair errorCaBitsize of the foreign field limb representation.CmThis trait contains helper functions for the lookups used \xe2\x80\xa6CkRepresents a witness of one instance of the lookup argumentBfM extension instructions Following \xe2\x80\xa6DfThe number of bits needed to represent the <code>Self::MODULUS</code>.AmSign of the quotient, one bitAmFixed table, x \xe2\x88\x88 [0, 2^15].ox \xe2\x88\x88 [0, 2^15]00CbA runtime table. Runtime tables must match the \xe2\x80\xa6CaThe minimal number of columns required for the VMAcWidth of the spongeAfInvalid secret key hexCnLook up a single value in a lookup table. The value may be \xe2\x80\xa6CgSingle-column table of 2^16 entries with the sparse \xe2\x80\xa6CdSub environment with a lens that is mapping columns.CjSub environment with a lens that is mapping lookup tables.CkWitness cell assigned from a variable See Variables for \xe2\x80\xa6BhEvaluations of the wires and permutationCbThe table ID associated with the XOR lookup table.BfFormat: <code>xori rd, rs1, imm</code>CjAbsorb the last committed program state in the correct \xe2\x80\xa60DhAdd the monomial <code>coeff * x_1^{e_1} * ... * x_N^{e_N}</code> to thelAppend bytesAkAppend a base field elementDiIf the <code>Value</code> is an Array, returns the associated mutable \xe2\x80\xa6BgAssert that the two variables are equalEaAssert that the values <code>x</code> and <code>y</code> are equal, and add a \xe2\x80\xa60CiThis function verifies the batch of zk-proofs proofs: \xe2\x80\xa6CkDefines the height of each block in the IVC circuit. As \xe2\x80\xa6CmSqueeze out a base field challenge. This operation is the \xe2\x80\xa6AlForeign field addition gate.AlForeign field multiplicationAagate coefficientsAgcoefficient polynomialsClCommit to the program state and updating the environment \xe2\x80\xa60Aglo + mi * 2^{LIMB_BITS}CcThis module implements a complete EC addition gate.DiCreates a FFAdd witness (including <code>ForeignFieldAdd</code> rows, \xe2\x80\xa6ChCreate a multi range check witness from three 88-bit \xe2\x80\xa6A`Produces a proofCeCreates a Rot64 gadget to rotate a word It will need:CmA placeholder value that is known to appear in the lookup \xe2\x80\xa6C`Returns the (x,q)-th variable of ThetaExpandRotCCbReturns the (y,x,q)-th variable of PiRhoExpandRotECiOn input a 200-byte vector, generates a vector of 100 \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6DgFetch the memory value at address <code>addr</code> and store it in \xe2\x80\xa60CkVectors We implement a custom type for field vectors in \xe2\x80\xa6CeThe content of the first column of the runtime table.EhA convenience helper: given a <code>list_len</code> and <code>n</code> (arguments of \xe2\x80\xa6CnFree a pointer. This method is exported in the WebAssembly \xe2\x80\xa6BhDeserialize Mina address into public keyClDeserialize Mina address into compressed public key (via \xe2\x80\xa6AhDeserialize from BigUintCiInitializes a new foreign element from a big unsigned \xe2\x80\xa6Amgeneric gate commitment arrayCmObtains a Test SRS for a specific curve from disk. Panics \xe2\x80\xa6AlConverts an i32 into a FieldCdSerialize public key into corresponding Mina addressCkSerialize compressed public key into corresponding Mina \xe2\x80\xa6CiPlaceholder dummy value for the kimchi configuration, \xe2\x80\xa6CmThe Marlin_plonk_stubs crate exports some functionalities \xe2\x80\xa6BhAdds a lookup to the AtMost4Lookup table0BeAdds a lookup to the ByteLookup table0CfWhich lookup-patterns should be applied on which rows.0ClThis prover takes one Public Input and one Public Output \xe2\x80\xa6CmLookup \xe2\x80\x9cread\xe2\x80\x9d requests per table. Each element of the \xe2\x80\xa6BbAggregated lookups or \xe2\x80\x9creads\xe2\x80\x9d.B`Adds a lookup to the Reset tableCnReads a Lookup containing the input of a step and writes a \xe2\x80\xa6mLookup tablesAhGet the AND lookup tableCaGet the foreign field multiplication lookup tableAhGet the xor lookup tableAhGet the rot lookup tableB`Get the range check lookup tableBeevaluation of lookup table polynomialDhMaps variable (column index) in expression using the <code>mapper</code>DiReturns <code>x % y</code>, storing the results in <code>position</code>.ChReturns a degree-1 variable that encodes whether the \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6Cievaluation of the elliptic curve variable base scalar \xe2\x80\xa6AiSets <code>a = -a</code>.0ChOptional coefficient that can be multiplied with the \xe2\x80\xa60DdThis module implements the prover index as <code>ProverIndex</code>.Ampublic polynomial evaluationsCbThe public input used in the creation of the proofCkReturns the constraints converted into degree 2 or less \xe2\x80\xa6A`RangeCheck0 gateA`RangeCheck1 gateDaRange checks with 1 lookup to the AtMost4Lookup table 0 &lt;= \xe2\x80\xa6CnRange checks with 2 lookups to the ByteLookup table that a \xe2\x80\xa60Bievaluation of the Rot selector polynomialCdInside the circuit, we have a specialized scalar \xe2\x80\xa6CaReturns the 200 bytes of the sponge, as variablesCmReturns the last 32 terms that are added to the new block \xe2\x80\xa6BhReturns total height of the IVC circuit.Aa2^{2 * LIMB_BITS}0i2^{2 * B}Aa2^{3 * LIMB_BITS}i2^{3 * B}BhMacro to simplify creation of layout map0CeReturns the 400 variables corresponding to ChiShiftsBCfReturns the 80 variables corresponding to ThetaShiftsCCgReturns the 400 variables corresponding to PiRhoShiftsECiSRS to be used by the verifier. Can be seen as the \xe2\x80\x9c\xe2\x80\xa6CbVerify the <code>GateType::VarBaseMul</code>(TODO)AkWitness cell on current rowBhSame as witness but for the current row.AhWitness cell on next rowBeSame as witness but for the next row.CnReturn the corresponding expression regarding the selected \xe2\x80\xa6CkSet the value of the variable at the given position for \xe2\x80\xa6CiWrites an integer value to a column of the Keccak witnessBievaluation of the Xor selector polynomialCkThe type of constraints that this will produce. This is \xe2\x80\xa6AfInvalid address base58AfInvalid address lengthCjYou can create a new AdjacentPairs from an iterator using:CmValues from 0 to 4 to check the number of bytes read from \xe2\x80\xa6AjScalar coeff #2, r * phi^ilConstant h_rmu_O = u_L + rCiN_LIMBS values, representing the converted IPA challenge.ChA datatype expressing a generalized column, but with \xe2\x80\xa6CaWitness cell copied from another cell and shiftedClThe result of performing an endoscaling: the accumulated \xe2\x80\xa6CeGate for computing the scalar corresponding to an \xe2\x80\xa60BfNumber of columns in the FEC circuits.BfNumber of columns in the FFA circuits.CjTrusted (for range) foreign field modulus, in 4 big limbs.CkA trait that defines parameters for a field that can be \xe2\x80\xa6CkConstant column that is /always/ fixed for a given circuit.ClA single column containing the folding iteration number, \xe2\x80\xa6AlOutput of the folding proverAaG_GENERATOR_X = 10AdG1_GENERATOR_Y = \xe2\x80\xa60CkCapability for computing arithmetic functions and enforcingBmA challenge used to columns of a lookup tableCnThe witness columns used by the Keccak circuit. The Keccak \xe2\x80\xa6DjA \xe2\x80\x9clinearization\xe2\x80\x9d, which is linear combination with <code>E</code> \xe2\x80\xa6CbA position in the circuit relative to a given row.C`The table ID associated with a particular lookupAoTrait for lookup table variantsCfRepresents a witness of one instance of the lookup \xe2\x80\xa6ClEnabled if the number of lookups per row is at least the \xe2\x80\xa6AeNumber of full roundsBnNumber of constraints used by the IVC circuit.BhAlias for N_LIMBS, used for convenience.Abpoint not on curveAkInvalid y-coordinate parityBiThe result of running the oracle protocolAfQuotient limbs (large)AfQuotient limbs (small)CkThe number of bytes that can be processed by the Keccak \xe2\x80\xa6CiThis enum provides aliases for the registers. This is \xe2\x80\xa6BiA runtime table, with no explicit writes.BfA runtime table, with explicit writes.CnWe store several different types of SRS objects. This enum \xe2\x80\xa6AnSyscalls communication channelCmLook up the value in the table with ID given by the value \xe2\x80\xa6DcAccess the memory address <code>addr</code>, adding constraints \xe2\x80\xa60CnAllocate a new abstract variable for the current step. The \xe2\x80\xa60AmAppend a scalar field elementDjIf the <code>Value</code> is an Object, returns the associated mutable \xe2\x80\xa6B`Function used to map assertions.D`The function that maps the argument of <code>assert_zero</code>.ChCreate a new field element from this field elements bitsCmReturns the witness of an execution of a Cairo program in \xe2\x80\xa6F`Check that the witness value <code>x</code> is a boolean (<code>0</code> or <code>1</code>); \xe2\x80\xa6DiCheck that the witness value in <code>assert_equals_zero</code> is 0; \xe2\x80\xa60ClThe description of the program, in terms of gadgets. For \xe2\x80\xa6CkGet vector of foreign field multiplication circuit gate \xe2\x80\xa6BlGet vector of range check circuit gate typesAkcoefficients over domain d8CeDefines the domain over which the column is evaluatedCdHelper function for limb recombination for carry \xe2\x80\xa6DdCombine the polynomials using a scalar (<code>polyscale</code>), \xe2\x80\xa6DjSame as <code>combine_table_entry</code>, but for an entire table. The \xe2\x80\xa6ClCommit to a polynomial, with custom blinding factors. It \xe2\x80\xa6BoComposes the 91-bit carry1 value from its partsClPerform integer bound addition for all limbs x\xe2\x80\x99 = x + f\xe2\x80\xa6BhConfiguration for the lookup constraint.CnConnects a generic gate cell with zeros to a given row for \xe2\x80\xa6Bf0-th Lagrange evaluated over domain.d4Bf0-th Lagrange evaluated over domain.d8CiConstrains 200 checks of the chi algorithm in round stepsCiThis function generates constraints for the whole IVC \xe2\x80\xa6BlCreate an experimental kimchi hasher contextClCreate an experimental kimchi signer context with domain \xe2\x80\xa6AnCreate a legacy hasher contextCiCreate a legacy signer context with domain parameters \xe2\x80\xa6CkUse deterministic output for regression testing (stable \xe2\x80\xa6CoReturns <code>(x / y, x % y)</code>, storing the results in \xe2\x80\xa6CnGenerate unique domain string of length <code>&lt;= 20</code>.Chevaluation of the endoscalar multiplication selector \xe2\x80\xa6CmExtend an existing witness with a single-range-check gate \xe2\x80\xa6Akflags for optional featuresBnUseful helper methods to extend ark_ff::Field.CkDescribes helpers for foreign field arithmetics Generic \xe2\x80\xa6CjThis function returns the composed variable from dense \xe2\x80\xa6EfBuild the univariate polynomial <code>x_i</code> from the variable <code>i</code>. \xe2\x80\xa6CeObtains an SRS for a specific curve from disk, or \xe2\x80\xa6CmReturn the constants parameters that the expression might \xe2\x80\xa6CkReturns a range of exponents, for a given ArgumentType, \xe2\x80\xa6AmGenerate the nth prime numberCeInitialize state, hash input and obtain result outputCnReturns a slice of the input variables of the current step \xe2\x80\xa6CeIterate over the columns in the circuit, in parallel.BiThis module implements the linearization.ChThe symbolic linearization of our circuit, which can \xe2\x80\xa6AeLinearization helpersBmAdds a lookup to the RangeCheck16Lookup table0Bgevaluation of lookup sorted polynomialsB`Adds a lookup to the Shift tableCcAggregated \xe2\x80\x9cwrite\xe2\x80\x9d lookups, for runtime tables.BhCreate a new test rng with a random seedBbmaximal size of polynomial section0CfThe maximum polynomial degree that can be committed to0CgThis crate provides a generic implementation of the \xe2\x80\xa6EhReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.EeReturns <code>(x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, storing the results in \xe2\x80\xa6Bmscalar multiplication selector over domain d8AaIPA opening proofCgOn input a length, returns the smallest multiple of \xe2\x80\xa6ChComputes a log-sized vector of scalar challenges for \xe2\x80\xa6EcSet the general purpose register with index <code>idx</code> to <code>value</code>.0CiRange checks with 2 lookups to the RangeCheck16Lookup \xe2\x80\xa60CgReturn the corresponding variable at the given positionB`Rot gate selector over domain d8CkGiven a Poseidon round from 0 to 4 (inclusive), returns \xe2\x80\xa6BnThe evaluations of the optional runtime table.CiThis adds a few utility functions for serializing and \xe2\x80\xa6Dh<code>impl_shared_rwlock</code> implements an OCaml custom type that \xe2\x80\xa6AcField size in bytesCfProvides the sponge params to be used with this curve.0DjReturns the <code>idx</code>-th term of the shifts of the sponge, as a \xe2\x80\xa6E`Sets <code>self</code> to be the square root of <code>self</code>, if it exists.BdClean up old traces and start fresh.Adthe fp sponge paramsAkthe legacy fp sponge paramsAdthe fq sponge paramsAkthe legacy fq sponge paramsCeCircuit generator function for A + B - C, with D = 0.CjAssign a unique ID to the lookup tables, as an expression.CiGiven a linearization and an environment, compute the \xe2\x80\xa60CmCommitments to the N columns of the circuits, also called \xe2\x80\xa6BlWitness evaluations, including public inputsB`Xor gate selector over domain d8AgInvalid address versionAcHelpers for BigUintlConstant phiAlScalar coeff #2, r^2 * phi^iAlScalar coeff #2, r^3 * phi^ih\xce\xb1_{L,i}BiFormat: <code>blt rs1, rs2, offset</code>AbDisconnected wiresC`Default type for when you don\xe2\x80\x99t need structureBaTrack external check witness dataCnFEC ADD inputs: two points = four coordinates, and each in \xe2\x80\xa6BdFEC ADD intermediate (work) columns.CkRepresents a foreign field element Represents a foreign \xe2\x80\xa6CnNumber of coefficients used by a single generic gate Three \xe2\x80\xa6CfMinimal environment needed for evaluating constraints.CaEnumeration of concrete lookup tables used in \xe2\x80\xa6ClAn abstract interpreter that provides some functionality \xe2\x80\xa6CaFlags for each of the hard-coded lookup patterns.BeLookup tables used in the MSM projectCeAll of the possible lookup table IDs used in the zkVMClMaximum number of memory accesses per instruction (based \xe2\x80\xa60CnMaximum number of register accesses per instruction (based \xe2\x80\xa60CaThe number of constraints required by this gadgetCcTotal number of rounds, including partial and full.BdThe biggest packing format, 2 limbs.CmRepresents the parameters of the instance of the Poseidon \xe2\x80\xa600nNumber of rowsAcx \xe2\x88\x88 [-2^9, 2^9-1]Acx \xe2\x88\x88 [-2^4, 2^4-1]AhInvalid secret key bytesEhA standard folding config that supports: <code>G</code>: any curve <code>Col</code>: \xe2\x80\xa6DbA clone of the <code>PairingSRS</code> that is serialized in a \xe2\x80\xa6ChAdd a constraint to the proof system, asserting that \xe2\x80\xa60AhTrack a limb-range-checkDdAdds offset if the column is <code>Relation</code>. Fails otherwise.CjThis module hosts the AdjacentPairs type, which can be \xe2\x80\xa6BbAppend another random oracle inputDiAssert that the value <code>x</code> is boolean, and add a constraint \xe2\x80\xa60DiAssert that the value <code>assert_equals_zero</code> is 0, and add a \xe2\x80\xa60c2^tCiMultiplies each blinding chunk of f with powers of zeta^nCnSimulate an interaction with the verifier by requesting to \xe2\x80\xa60CiCompute the coefficient \xce\xbb used in the elliptic curve \xe2\x80\xa6CiCompute the output of the application on the previous \xe2\x80\xa6C`Creates a variable from a constant field elementChConstrains 4 checks of the iota algorithm in round stepsCkThe constraints given as multivariate polynomials using \xe2\x80\xa6AhCreate a generic circuitCmThis allows you to create two generic gates that will fit \xe2\x80\xa6CjCreates a witness for adding two points, p and q, each \xe2\x80\xa6Caendoscalar multiplication selector over domain d8DiImplementation of the <code>EndomulScalar</code> gate for the endomul \xe2\x80\xa6CnFetch the value of the general purpose register with index \xe2\x80\xa60ClFolded witness, containing, in particular, the result of \xe2\x80\xa6BnReturn the challenges, coined by the verifier.AiGet the next prime numberCnReturn true if the table has an entry (row) containing all \xe2\x80\xa6ClInitial state of the sponge, containing circuit specific \xe2\x80\xa6DjReturns true if the polynomial is homogeneous (of degree <code>D</code>\xe2\x80\xa6CbReturn true if the multi-variate polynomial is \xe2\x80\xa6CiThe challenge joint_combiner which is used to combine \xe2\x80\xa6BdThe combiner used for vector lookupsCkSerialize the given data structure as JSON into the I/O \xe2\x80\xa6BnCommitments to Lagrange bases, per domain size0BlAdds the 601 lookups required for the spongeCmReturns the maximum number of values that are used in any \xe2\x80\xa6CnThe maximum joint size of any joint lookup in a constraint \xe2\x80\xa60CjThe multiplicities of each lookup entry. Should not be \xe2\x80\xa6nmultiplicitiesCjReturns a slice of the output variables of the current \xe2\x80\xa6DiInstantiates the IVC circuit for folding. <code>N_COL_TOTAL</code> is \xe2\x80\xa6De<code>comms</code> is lefts, rights, and outs. Returns the packed \xe2\x80\xa6CnRuntime tables are tables (or arrays) that can be produced \xe2\x80\xa6DdOptional runtime tables, listed as tuples <code>(length, id)</code>.CbCommitments to the selectors used by both circuitsCgCircuit generator function for A_0 + B_0 - FIXED_SEL_1.DlReturns 1 if <code>x &lt; y</code> as unsigned integers, or 0 otherwise, \xe2\x80\xa60BoConvert to 3 PrimeField limbs of LIMB_BITS eachBkConvert limbs from BigUint to field elementCgReturns the 5 variables corresponding to ThetaQuotientCCiReturns the 100 variables corresponding to PiRhoQuotientECgReturns the 400 variables corresponding to ChiShiftsSumDhThis module implements the verifier index as <code>VerifierIndex</code>.EeProduces the <code>VerifierIndex</code> from the prover\xe2\x80\x99s <code>ProverIndex</code>.CeThe verifier index corresponding to this prover indexBiThe VerifierIndex associated to the proofBeVerify the <code>EndoMul</code> gate.Clverifies that the generic gate constraints are solved by \xe2\x80\xa6CjFunction to verify the generic polynomials with a witness.BjVerify the witness against the constraintsAhInvalid address checksumAlWitness data for an argumentCkRepresents additional information that a curve needs in \xe2\x80\xa6Aa2*17 15-bit limbsAh\xce\xb1_R^i, where \xce\xb1_R = h_RA`Handy re-exports0BmVector field over F. Something like a vector.ChA useful trait extending AffineRepr for commitments. \xe2\x80\xa6BjPolynomial represented by its coefficientsChThe domain parameter trait is used during hashing to \xe2\x80\xa6CjColumns related to dynamic selectors to indicate gate typeBnAdditional columns created by quadraticizationCkThis structure represents a witness extended with extra \xe2\x80\xa6CjFEC ADD outputs: one point, each in 17 limb output format.CaImplementation of the foreign field addition gateCmThis gate operates on the Curr and Next rowsIt uses copy, \xe2\x80\xa6CnEnumerates the different \xe2\x80\x98fixed\xe2\x80\x99 lookup tables used by \xe2\x80\xa6CnThe different type of computation that are possible with a \xe2\x80\xa6BgA public gate was incorrectly connectedClAn indexed relation is a structure that contains all the \xe2\x80\xa6BlAn iterator over the variants of Instruction0CjA spec for checking that the given vector belongs to a \xe2\x80\xa6A`Lookup selectorsBlAn iterator over the variants of LookupTable000CkCapability for reading and moving forward in a multirow \xe2\x80\xa6CjThe number of columns used for relation witness in the \xe2\x80\xa6CcThe number of witness columns used to store the \xe2\x80\xa6CmThe number of bits that must be shaved from the beginning \xe2\x80\xa6A`Number of roundsAex \xe2\x88\x88 [-2^14, 2^14-1]0CnA relaxed instance is an instance that has been relaxed by \xe2\x80\xa6ChUse this type at setup time, to list all the runtime \xe2\x80\xa6ClA challenge which is used as a scalar on a group element \xe2\x80\xa6AiInvalid base58 secret keyAiInvalid secrey key lengthChThe interface for a field that supports an efficient \xe2\x80\xa6DhFor the extra columns added by the module <code>quadraticization</code>.CbAbsorbs a slice of field elements into the sponge.DkAccess the general purpose register with index <code>idx</code>, adding \xe2\x80\xa60AcTrack a bound checkBdAppend a <code>Hashable</code> inputCjThis module provides a set of functions to perform bit \xe2\x80\xa6CaBuilds fixed selectors for serialization circuit.BaCompute the following constraint:CbConstrains 136 checks of correctness of mode flagsCkConstrains 150 checks of the pirho algorithm in round stepsBdConstrains 389 checks of round stepsCjConstrains 35 checks of the theta algorithm in round stepsCkEnvironment for the constraints (includes lookups). The \xe2\x80\xa6ChThis function creates SRS instance for circuits with \xe2\x80\xa6CgDouble the elliptic curve point given by the affine \xe2\x80\xa600Dh<code>eval_polynomial(coeffs, x)</code> evaluates a polynomial given \xe2\x80\xa6BmThis function evaluates polynomial in chunks.CiFill in a witness created via <code>create_circuit</code>DiFixed values for selector columns. <code>fixed_selectors[i][j]</code> \xe2\x80\xa6ChFixed selectors. These are \xe2\x80\x9cpredefined\xe2\x80\x9d with the \xe2\x80\xa6CnThe folded instance, containing, in particular, the result \xe2\x80\xa6AnCreate keypair from secret keyBcCreate public key from a secret keyBnCreate compressed public key from a secret keyBgThere are 32 general purpose registers.ClGet all relevant constraints generated by the constraint \xe2\x80\xa6CgReturn the constraints for the current instruction, \xe2\x80\xa60ClReturn only the first chunk Getting this single value is \xe2\x80\xa6AlGeneric SRS getter function.CnInterpret an I-type instruction. The encoding of an I-type \xe2\x80\xa6CnInterpret an M-type instruction. The encoding of an M-type \xe2\x80\xa6CnInterpret an R-type instruction. The encoding of an R-type \xe2\x80\xa6CnInterpret an S-type instruction. The encoding of an S-type \xe2\x80\xa6CnInterpret an U-type instruction. The encoding of an U-type \xe2\x80\xa6BmConvert public key into compressed public keyoLookup featuresCjModify the monomial in the polynomial to the new value \xe2\x80\xa6BgGet the modulus as <code>BigUint</code>CkReturns the 136 flags indicating which bytes of the new \xe2\x80\xa6CcThe mapping between powers of alpha and constraints0CjClone of kimchi/precomputed_srs.rs but for MSM project \xe2\x80\xa6CkTo prover and verify proofs you need a Structured ReferenceBkPreimage oracle interface used by the zkVM.CfSet up the number of previous challenges, used for \xe2\x80\xa6Cknumber of previous evaluation challenges, for recursive \xe2\x80\xa6CmThe challenges underlying the optional polynomials folded \xe2\x80\xa61CkProcesses scalars. Returns a vector of limbs of (powers \xe2\x80\xa6BhRead value from a (row,column) position.00CiReturns the 4 expanded quarters that encode the round \xe2\x80\xa6CcThis module offers a standard implementation of \xe2\x80\xa6ChReturns the 20 variables corresponding to ThetaDenseRotCCiReturns the 100 variables corresponding to PiRhoDenseRotECiReturns the 20 variables corresponding to ThetaRemainderCCjReturns the 100 variables corresponding to PiRhoRemainderEBlChecks if a witness verifies a poseidon gateAiEC ADD intermediate wiresAo\xce\xb1_{O,i} = \xce\xb1_{L,i} + r\xc2\xb7\xce\xb1_R^iCmThis structure stores all the needed information relative \xe2\x80\xa6A`Handy re-exportsCjN_INTERMEDIATE_LIMBS intermediate values, 4 bits long. \xe2\x80\xa6jGate errorCfCompressed public keys consist of x-coordinate and \xe2\x80\xa6CjA direct field access capability modelling an abstract \xe2\x80\xa6CkDummy lookup table. For the cases when you don\xe2\x80\x99t need \xe2\x80\xa6CnAn extended instance is an instance that has been extended \xe2\x80\xa6CnEnumerates the different \xe2\x80\x98fixed\xe2\x80\x99 lookup tables used by \xe2\x80\xa6BmAn iterator over the variants of IInstructionBoA concrete value or representation of a lookup.AlInput/Output of Keccak stepsBhFormat: <code>lbu rd, offset(rs1)</code>BhFormat: <code>lhu rd, offset(rs1)</code>ChThe fixed tables. The parameter is considered to the \xe2\x80\xa6DgPartial sums. This corresponds to the <code>h_i</code>. It is first \xe2\x80\xa6AhLength of Mina addressesAaSecret key lengthBmAn iterator over the variants of MInstructionAhNumber of partial roundsBgEvaluations of a polynomial at 2 pointsCcFor current row i, this is i - 2^{ceil(log(i)) - 1}CoPolynomial evaluations contained in a <code>ProverProof</code>.BmAn iterator over the variants of RInstructionClUsed by the accumulation protocol (folding) to perform a \xe2\x80\xa6BoTrait to make a witness relaxable/homogenizableBeThe specification of a runtime table.BmAn iterator over the variants of SInstructionAjInvalid secret key versionDeSame as <code>SerdeAs</code> but using unchecked and uncompressed \xe2\x80\xa6BeFormat: <code>sll rd, rs1, rs2</code>BmAn iterator over the variants of UInstructionCnWitness cell assigned from bits of a variable See Variables\xe2\x80\xa6AjInvalid x-coordinate bytesAbPoint not on curveCnThis module defines the particular form of the expressions \xe2\x80\xa6CnThis function returns a degree-2 variable that is computed \xe2\x80\xa6CkMultiplies each commitment chunk of f with powers of zeta^nAfCombine where x1 = oneBgConstrains 332 checks of absorb spongesBaConstraints for the inputs block.BeConstrains 354 checks of sponge stepsBaGet the expresion of constraints.CjThis function constructs prover\xe2\x80\x99s recursive zk-proof \xe2\x80\xa6CmThis adds a few utility functions for the DensePolynomial \xe2\x80\xa6AlThe endomorphism coefficientCbHelper to access endomorphism coefficient constantCeThe commitment to the error term, introduced when \xe2\x80\xa6BmEvaluates the expression in the provided sideChGiven the evaluations form of a polynomial, directly \xe2\x80\xa6ClThe original witness, extended with the columns added by \xe2\x80\xa6BkCombines constraints into single expressionDj<code>generate_witness(row, params, witness_cols, input)</code> uses a \xe2\x80\xa6Aegeneric gate selectorBmevaluation of the generic selector polynomialDmReturn the coefficients <code>a</code> and <code>b</code> of the equation \xe2\x80\xa6CiGenerates proof inputs, repacking/collecting internal \xe2\x80\xa6DfEvaluate the polynomial at the vector point <code>x</code> and the \xe2\x80\xa6CdThe relation this witness environment is related to.ClThis module defines a list of traits and structures that \xe2\x80\xa6ChInterpret an SB-type instruction. The encoding of an \xe2\x80\xa6ChInterpret an UJ-type instruction. The encoding of an \xe2\x80\xa6CjCheck if the points given by (x1, y1) and (x2, y2) are \xe2\x80\xa6BbConvenience function for printing.CnLookup selectors: For each kind of lookup-pattern, we have \xe2\x80\xa6EdReturns <code>((x * y) &gt;&gt; 32, (x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, \xe2\x80\xa6DkPerforms a multi-scalar multiplication between scalars <code>elm</code> \xe2\x80\xa6ClProvides the coefficient for the curve endomorphism over \xe2\x80\xa60mr^2\xc2\xb7\xcf\x95^{N+1}mr^3\xc2\xb7\xcf\x95^{N+1}BmPopulates and checks one poseidon invocation.00EfSet the general purpose register with index <code>idx</code> to <code>value</code> \xe2\x80\xa60BnA library to reduce constraints into degree 2.CkAn optional runtime table selector. It is 0 everywhere, \xe2\x80\xa6CdThe evaluations of the optional runtime selector \xe2\x80\xa6Dg<code>impl_shared_reference1</code> implements an OCaml custom type \xe2\x80\xa6ClConvert to 2 limbs of 2 * LIMB_BITS each. The compressed \xe2\x80\xa6B`Compose field limbs into BigUintCiReturns the 20 variables corresponding to ThetaExpandRotCCjReturns the 100 variables corresponding to PiRhoExpandRotECbThis module constructs a serde serializer (and \xe2\x80\xa6BaFormat: <code>auipc rd,imm</code>ChA commitment to a polynomial with some blinding factors.o17 15-bit limbsCeThe number of bytes used as a capacity in the sponge.AoField element helpers for CairoA`Handy re-exportsChThis struct contains multiple chunk polynomials with \xe2\x80\xa6kGate resultCnThe collection of polynomials (all in evaluation form) and \xe2\x80\xa60CmThe polynomials representing columns, in evaluation form. \xe2\x80\xa6BjSome connected wires have different valuesAnPrimeField array compact limbsB`PrimeField array compose BigUintAcField helpers errorCgNumber of generic of registers by a single generic gateAbInvalid constraintBmThe lookup aggregation, i.e. <code>phi</code>BhCommitments linked to the lookup featureC`The polynomials specific to the lookup argument.CiThis is what the prover needs to remember while doing \xe2\x80\xa6BnAn iterator over the variants of LookupPatternCeThe minimum SRS size required to use Nova, in base 2.CaCommunication bus for the multiplication circuit.CiThe maximum number of columns that can be used in the \xe2\x80\xa6BnThe number of gadgets supported by the programCcNumber of PLONK rows required to implement PoseidonCnThe following gadgets implement the Poseidon hash instance \xe2\x80\xa6CnThis gadget implement the Poseidon hash instance described \xe2\x80\xa6CnAll the commitments that the prover creates as part of the \xe2\x80\xa6BnAn iterator over the variants of SBInstructionAkInvalid secret key checksumBeFormat: <code>srl rd, rs1, rs2</code>BnAn iterator over the variants of UJInstructionCmWitness builder environment. Operates on multiple rows at \xe2\x80\xa6AkInvalid y-coordinate parityC`Activate the selector for the given instruction.0CgAllocate a new variable in the circuit for the next rowCmApply the whole permutation of Poseidon to the state. The \xe2\x80\xa60CdApply the HADES-based Poseidon to the state. The \xe2\x80\xa6Alcoefficient commitment arrayCmThis function commits a polynomial using the SRS\xe2\x80\x99 basis \xe2\x80\xa6BjEC addition selector polynomial commitmentCnConnect the pair of cells specified by the cell1 and cell2 \xe2\x80\xa6BmConstrains 6 checks of padding absorb spongesBgConstrains 16 checks of squeeze spongesAmConstraints for this argumentCmGenerates the constraints for the Cairo initial claim and \xe2\x80\xa6CgGenerates the constraints for the Cairo instruction \xe2\x80\xa6CjGenerates the constraints for the Cairo flags Accesses \xe2\x80\xa6CfGenerates the constraints for the Cairo transition \xe2\x80\xa6CnCreate a new sponge, with an empty state (i.e. initialized \xe2\x80\xa6CaCreates a XOR gadget for <code>bits</code> lengthBaThe current iteration of the IVC.Cnverifies that the Cairo gate constraints are solved by the \xe2\x80\xa6DhThe actual evaluation points. Each field <code>evaluations</code> of \xe2\x80\xa6CnExtends a XOR gadget for <code>bits</code> length to a circuitCmThe original instance, extended with the columns added by \xe2\x80\xa6AkForeign field addition gateAmForeign Field Addition moduleBaForeign field multiplication gateBcForeign field multiplication moduleDjCreate keypair from scalar field <code>secret</code> element and curve \xe2\x80\xa6CkCreate public key from curve point Note: Does not check \xe2\x80\xa6Aogeneric selector over domain d4AnWhether joint lookups are usedDgDecomposes a foreign field element into <code>N</code> limbs of bit \xe2\x80\xa6CbAdds the 800 lookups required for Chi in the roundhPoseidonAfposeidon gate selectorBnevaluation of the poseidon selector polynomialBbRangeCheck0 polynomial commitmentsBbRangeCheck1 polynomial commitmentsBkThe row layout for <code>RangeCheck0</code>CjA single-column table containing the numbers from 0 to \xe2\x80\xa6BhWrite an array of values simultaneously.ClUsed by the accumulation protocol (folding) to perform a \xe2\x80\xa6DhSets an assert predicate <code>f(X)</code> such that when assert_zero isCkCoin a challenge from the sponge. Note that a challenge \xe2\x80\xa6ClConvert an abstract variable to a field element! Inverse \xe2\x80\xa60ChReturns the 400 terms that compose the shifts of the \xe2\x80\xa6Cnverifies that the Cairo gate constraints are solved by the \xe2\x80\xa6CnThe Challenge term that contains an alpha. Is used to make \xe2\x80\xa6BcExponent of binary modulus (i.e. t)o17 15-bit limbsC`This struct contains multiple chunk evaluations.CnUsed to aggregate the constraints describing the relation. \xe2\x80\xa6CmIn FEC addition we use bigger limbs, of 75 bits, that are \xe2\x80\xa6BmAlias for LIMB_BITSIZE, used for convenience.AoFormat: <code>lui rd,imm</code>DhMultiplicities, indexed. This corresponds to the <code>m_i</code>. FirstAiNumber of round constantsCnTotal number of columns used in Keccak, including relation \xe2\x80\xa6ChSingle-column table of all values in the range [0, 2^16)DbA struct to store the challenges inside a <code>ProverProof</code>CdErrors that can arise when creating a verifier indexCnThe number of rows required for zero knowledge in circuits \xe2\x80\xa6BnAbsorbs the given evaluations into the sponge.DkAccess the general purpose register with index <code>idx</code>, adding \xe2\x80\xa60CnTake a prover environment, a multiplicities, and returns a \xe2\x80\xa6CjThis module provides a set of functions to perform bit \xe2\x80\xa6ChThis module contains a type ChunkedPolynomial, and a \xe2\x80\xa6CjCommit to evaluations with blinding factors, generated \xe2\x80\xa6CnPerform integer bound computation for high limb x\xe2\x80\x992 = x2 \xe2\x80\xa6CnA constraint function for A + B - C that reads values from \xe2\x80\xa6CfBuild the constraints for the lookup protocol. The \xe2\x80\xa6DjReturns the number of leading 1s in <code>x</code>, storing the result \xe2\x80\xa60CkCreate a And for inputs as field elements starting at row 0CdThis function creates a <code>CairoClaim</code> gateCdThis function creates a <code>CairoFlags</code> gateCjCreate foreign field addition gate chain without range \xe2\x80\xa6BmCreate a multi range check witness from limbsCjCreate single range check gate Inputs the starting row \xe2\x80\xa6CnCreate a Xor for up to the native length starting at row 0 \xe2\x80\xa6AhFor FoldingCompatibleExpCmEvaluate the constant expressions in this expression down \xe2\x80\xa60CbEvaluate the constants in a linearization with \xe2\x80\xa6B`Linearize the <code>expr</code>.ClExtends an AND witness to the whole witness Input: first \xe2\x80\xa6CnExtend a chain of foreign field addition gates. It already \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6CjCreate foreign field range-check gate by extending the \xe2\x80\xa6CjExtends the Xor rows to the full witness Panics if the \xe2\x80\xa6ClFold two relaxable instances into a relaxed instance. It \xe2\x80\xa60ClConvert a list of folding compatible expression into the \xe2\x80\xa6CgThe path of the serialized BN254 SRS, inside this repo.CnCompute commitments to the lagrange basis corresponding to \xe2\x80\xa6CmReturn all runtime tables collected so far, padded to the \xe2\x80\xa6ChCheck what kind of lookups, if any, are used by this \xe2\x80\xa6Bkevaluation of lookup aggregation polynomialC`Adds the 1 lookup required for Iota in the roundF`Returns <code>x * y</code>, where <code>x</code> and <code>y</code> are treated as integers, \xe2\x80\xa60B`poseidon selector over domain d8CmSet the last \xe2\x80\x98access index\xe2\x80\x99 for the memory at address \xe2\x80\xa60CjSerialize field element f to a (positive) BigInt directly.CnConverts a vector of elements to a boxed one. Semantically \xe2\x80\xa6CfWitness cells in current row in an interval [from, to)CcWitness cells in next row in an interval [from, to)BhWrite an array of values simultaneously.BmWrite a field element directly as a constant.CfWrites a field value to a column of the Keccak witnessAlBigUint array compose helperBaField element wrapper for BigUinto17 15-bit limbs0A`Handy re-exports0BnErrors that can arise when preparing the setupBfAn extension for the Evaluations type.CgForeign field helpers for <code>B</code> the limb size.BlGeneric structure containing column vectors.BfFormat: <code>jalr rd, rs1, imm</code>CkThe biggest packing variant for foreign field. Used for \xe2\x80\xa6CmConfiguration for the lookup constraint. These values are \xe2\x80\xa6ClThe arity of the multivariate polynomials describing the \xe2\x80\xa6CmWrapper around an iterator that warns you if not consumed \xe2\x80\xa6Cix \xe2\x88\x88 [0, ff_highest] where ff_highest is the highest \xe2\x80\xa60BfThe size of the SRS that we serialize.DeAn integer <code>b</code> such that there exists a multiplicative \xe2\x80\xa6BmColumns used by the serialization subcircuit.BfFormat: <code>sltu rd, rs1, rs2</code>k(t - 1) / 2BnAbsorb a list of curve points into the sponge.DhInterprets bigint <code>input</code> as an element of a field modulo \xe2\x80\xa6CcGet the group element used for blinding commitmentsBoThis module contains a type ChunkedEvaluations,EhThis function populates the parameters <code>scalars</code> and <code>points</code>. \xe2\x80\xa6DjCombines multiple constraints <code>[c0, ..., cn]</code> into a single \xe2\x80\xa60CnCombine the (chunked) evaluations of multiple polynomials. \xe2\x80\xa6CnLet\xe2\x80\x99s say we want to do a lookup in a \xe2\x80\x9cvector-valued\xe2\x80\x9d\xe2\x80\xa6ChCompute the cross-terms as described in Behind Nova: \xe2\x80\xa6CiThis function generates constraints for the whole IVC \xe2\x80\xa6CnUsed to aggregate the constraints describing the relation. \xe2\x80\xa6DjReturns the number of leading 0s in <code>x</code>, storing the result \xe2\x80\xa60ChGadget generator of the whole cairo circuits from an \xe2\x80\xa6CmCreate a single foreign field addition gate. This is used \xe2\x80\xa6CnKeep the current executed instruction. This can be used to \xe2\x80\xa6Ciendoscalar multiplication scalar computation selector \xe2\x80\xa6CmExtend a single foreign field addition gate followed by a \xe2\x80\xa6ChFetch the last \xe2\x80\x98access index\xe2\x80\x99 that the memory at \xe2\x80\xa60ClGenerates a random field element of up to a given number \xe2\x80\xa6ClGet all the constraints for the verifier circuit and the \xe2\x80\xa6CaProvides access to the extra columns added by \xe2\x80\xa6CiLoad the state of the Poseidon hash function into the \xe2\x80\xa6ChWhen in Squeeze mode, writes a Lookup containing the \xe2\x80\xa6CdAdds the 700 lookups required for PiRho in the roundCdAdds the 120 lookups required for Theta in the roundCjReturns the maximum number of lookups per row that are \xe2\x80\xa6ClGiven a number n, return the list of prime factors of n, \xe2\x80\xa6CiPoseidon hash function with 55 full rounds, 0 partial \xe2\x80\xa60CiPoseidon hash function with 8 full rounds, 56 partial \xe2\x80\xa6CiChallenges during the last computation. This field is \xe2\x80\xa6CjSponge state used by the prover for the current iteration.BoSave the state of poseidon into the environmentBmCreate selector polynomial for a circuit gateDjSets all fixed selectors directly. Each item in <code>selectors</code> \xe2\x80\xa6CeCircuit generator function for A * B - C, with D = 0.BgTrue if runtime lookup tables are used.CiConverts a two-dimensional vector to a constant sized \xe2\x80\xa6CkConverts a three-dimensional vector to a constant sized \xe2\x80\xa6CnCheck the correctness of witness values for a complete-add \xe2\x80\xa6ClThis method is exported in the WebAssembly to be used on \xe2\x80\xa6Cfevaluation of the Xor range check pattern selector \xe2\x80\xa6B`Invalid raw address bytes lengthAmContains the batch evaluationA`2*4 75-bit limbsA`Handy re-exportsBaNumber of instructions in the ISACaAn iterator over the variants of ITypeInstructionCaAn iterator over the variants of JTypeInstructionCkThe number of intermediate limbs of 4 bits required for \xe2\x80\xa6CnPoseidon hasher type with experimental kimchi plonk sponge \xe2\x80\xa6CgPoseidon hasher type with legacy plonk sponge constantsClAbsorb [PlonkSpongeConstants::SPONGE_WIDTH - 1] elements \xe2\x80\xa60AiThe range check table ID.CaAn iterator over the variants of RTypeInstructionA`x \xe2\x88\x88 [-1, 0, 1]Cm24-row table with all possible values for round and their \xe2\x80\xa6CjNumber of columns used by the MIPS interpreter to keep \xe2\x80\xa6BfFormat: <code>slti rd, rs1, imm</code>BeFormat: <code>sra rd, rs1, rs2</code>BgHelper function for limb recombination.CfReturns constraints safely combined via the passed \xe2\x80\xa6CfGet the combined constraints for all foreign field \xe2\x80\xa6ClGet the combined constraints for all range check circuit \xe2\x80\xa6ChConstrains 136 checks of booleanity for some mode flags.CnA constraint function for A * B - D that reads values from \xe2\x80\xa6DbCreates and writes the SRS into <code>get_bn254_srs_path()</code>.CjCreate a multi range check witness from two limbs: v01 \xe2\x80\xa6CjThis function creates a trusted-setup SRS instance for \xe2\x80\xa6CmCreate a trusted setup for the KZG protocol. The setup is \xe2\x80\xa6CmThis variant of folding is designed to efficiently handle \xe2\x80\xa6ChDisable gates checks (for testing; only enables with \xe2\x80\xa60ChExtend and existing witness with a multi range check \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6CbMap all quad columns into regular witness columns.CjCommon parameters and functions for kimchi\xe2\x80\x99s foreign \xe2\x80\xa6BkIndex of the values to absorb in the spongeCmWrite a value into a runtime table. Panics if called on a \xe2\x80\xa6BbThe polynomials of the inner sums.gIndexes0fProofsAeVerifier indexes/keys0CkSet the last \xe2\x80\x98access index\xe2\x80\x99 for the general purpose \xe2\x80\xa60Bmevaluation of runtime lookup table polynomialCkThe offset of the runtime table within the concatenated \xe2\x80\xa6BeThe challenge terms used in Berkeley.A`2*4 75-bit limbsA`Handy re-exportsCkBoxed so that we don\xe2\x80\x99t store large proving indexes in \xe2\x80\xa601CmUsed to homogenize the constraints and allow the protocol \xe2\x80\xa6CiThe double generic gate actually contains two generic \xe2\x80\xa6CmDescribes the additional columns. It is parametrized by a \xe2\x80\xa6ChCompatible folding expressions that can be used with \xe2\x80\xa6CnA value of type IntegratedFoldingExpr is the result of the \xe2\x80\xa6Cnlegacy curve, a copy of the normal curve to support legacy \xe2\x80\xa6CnThe collection of polynomials (all in evaluation form) and \xe2\x80\xa6CoThe default number of chunks in a circuit is one (&lt; 2^16 \xe2\x80\xa6CbAn iterator over the variants of PlonkishChallengeCaThe number of rows the verifier circuit requires.::AiTrack a multi-range-checkCmBuilds selectors for the IVC circuit. The round constants \xe2\x80\xa6BeFixed selectors for the test circuit.AkReturn the folding combinerChFIXME: check if we need to pick the left or right spongeCgHelper. Combines 17x15bit limbs into 1 native field \xe2\x80\xa6Cfevaluation of the elliptic curve addition selector \xe2\x80\xa6CmWhen P = (xP,yP) and Q = (xQ,yQ) are not negative of each \xe2\x80\xa6CnThis allows you to create two generic gates by passing the \xe2\x80\xa6CeCreates a witness for the Keccak hash function Input:CmFetch the last \xe2\x80\x98access index\xe2\x80\x99 for the general purpose \xe2\x80\xa60CgLoad the value to absorb at the current step at the \xe2\x80\xa6AoEvaluations of fixed selectors.ClThe evaluations of the fixed tables, over d8, indexed by \xe2\x80\xa6FdIncreases the heap pointer by <code>by_amount</code> if <code>if_is_true</code> is <code>1</code>\xe2\x80\xa60CnBase case IVC circuit, completely turned off. For the base \xe2\x80\xa6CjAdds the polynomials that are evaluated as part of the \xe2\x80\xa6CdConverts the linearization of the kimchi circuit \xe2\x80\xa6DiLookup multiplicities, a vector of values <code>m_i</code> per lookup \xe2\x80\xa6BbThe commitments of the inner sums.BmThe evaluations of the partial sums, over d8.CnAccessor for the other curve\xe2\x80\x99s prime subgroup generator, \xe2\x80\xa6Caevaluation of the RangeCheck0 selector polynomialCaevaluation of the RangeCheck1 selector polynomialDhIf a table is runtime table, <code>true</code> means we should create anCnValues for runtime tables. Each element (value) in the map \xe2\x80\xa6AkFull serialization circuit.DjReturns 1 if <code>x &lt; y</code> as signed integers, or 0 otherwise, \xe2\x80\xa60CnConvert a polynomial into chunks. Implementors must ensure \xe2\x80\xa6ChRetrieve or compute the digest for the corresponding \xe2\x80\xa6CjThe verifier index digest corresponding to this prover \xe2\x80\xa6CeSponge state used by the verifier for the current \xe2\x80\xa6BkVerify the <code>EndoMulscalar</code> gate.Aa2*2 150-bit limbsBcRAM lookup access time for input 1.BbRAM lookup access time for output.BiFormat: <code>bge rs1, rs2, offset</code>BjFormat: <code>bltu rs1, rs2, offset</code>Cnlegacy curve, a copy of the normal curve to support legacy \xe2\x80\xa6CkThe maximum total number of witness columns used by the \xe2\x80\xa6ClThe number of columns required for the Keccak selectors. \xe2\x80\xa6ClThe range check will be performed on 12-bit values, i.e. \xe2\x80\xa6CcAn iterator over the variants of SyscallInstructionBi2^s root of unity computed by GENERATOR^tAdInvalid y-coordinateBmList of the accumulated challenges over time.BgHelper function for limb recombination.AfUsed by the OCaml sideCfComputes the linearization of the evaluations of a \xe2\x80\xa6BiEC point addition selector over domain d4CmUsed to homogenize the constraints and allow the protocol \xe2\x80\xa6c\xe2\x80\xa6CcDescribe the control-flow for the verifier circuit.CcForeign field addition gates polynomial commitmentsCiForeign field multiplication gates polynomial commitmentsBoGet constraints related to the lookup argument.CkReturns the number of bytes used by the WebAssembly memory.DgDecompose biguint into <code>N</code> limbs of bit size <code>B</code>.BiAdds a lookup to the RoundConstants tableEhReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.CmMultiplication sub-circuit of the serialization/bootstrap \xe2\x80\xa6BhRangeCheck0 gate selector over domain d8BhRangeCheck1 gate selector over domain d8CmThis function checks that the preimage is read correctly. \xe2\x80\xa6DhRequest the preimage oracle for <code>len</code> bytes and store the \xe2\x80\xa6ClSets a fixed selector, the vector of length equal to the \xe2\x80\xa6ClSet up the shared precomputations. If not invoked, it is \xe2\x80\xa6EgReturn the result of shifting <code>x</code> by <code>by</code>, storing the result \xe2\x80\xa60CkTemporary registers for elliptic curve points in affine \xe2\x80\xa6ClConvert to 2 PrimeField limbs of 2 * LIMB_BITS each. The \xe2\x80\xa6BjAn extension for the DensePolynomial type.nInvalid lookupCiConstants used by the IVC circuit used by the folding \xe2\x80\xa60BlHelper. Combines small limbs into big limbs.CiThis function creates a <code>CairoTransition</code> gateCfevaluation of the endoscalar multiplication scalar \xe2\x80\xa6CmReturns the highest limb of the foreign field modulus. Is \xe2\x80\xa6ClBuild mapping from 1..N to the first N prime numbers. It \xe2\x80\xa6BkReturn the requested MDS matrix coefficientCiThe commitments to the multiplicities, indexed by the \xe2\x80\xa6CnThe polynomial of the multiplicities, indexed by the table \xe2\x80\xa6CiWhen in Absorb mode, reads Lookups containing the 136 \xe2\x80\xa6CkSet the last \xe2\x80\x98access index\xe2\x80\x99 for the general purpose \xe2\x80\xa60CbAn optional selector polynomial for runtime tablesCiCircuit generator function for A_0^7 + B_0 - FIXED_SEL_1.CnThe polynomial (x - w^{n - i}) * (x - w^{n - i + 1}) * \xe2\x80\xa6 \xe2\x80\xa6B`BigUint array PrimeField helpersChNumber of generic of registers by a double generic gate.AmFailed to get witness for rowB`PrimeField array BigUint helpersClEvaluations of all normalized lagrange basis polynomials \xe2\x80\xa6ChAccumulate the program state (or in other words, the \xe2\x80\xa60CfGet combined constraints for a given foreign field \xe2\x80\xa6ClGet combined constraints for a given range check circuit \xe2\x80\xa6CnA constraint function for A * B - D that reads values from \xe2\x80\xa6CgThis constarins the multiplication part of the circuit.CaA constraint function for A_0 + B_0 - FIXED_SEL_1CjThis function creates a <code>CairoInstruction</code> gateCgCreate foreign field multiplication gate Inputs the \xe2\x80\xa6CiCreate range check gate for constraining three 88-bit \xe2\x80\xa6BiEC point addition selector over domain d8CmCreate foreign field multiplication gate by extending the \xe2\x80\xa6CmCreate foreign field muti-range-check gadget by extending \xe2\x80\xa6ChGet constraints related to the application logic itself.CjReturn the constraints for the selector. Each selector \xe2\x80\xa60Ahlookup constraint systemCnThe evaluations of the multiplicities, over d8, indexed by \xe2\x80\xa6ChComputes what is the non-normalized next instruction \xe2\x80\xa6Ahpermutation coefficientsCmPoseidon parameters for 55 full rounds, 0 partial rounds, \xe2\x80\xa6BkCommitments to the previous program states.CaReset the environment to build the next iterationC`Write an array of /field/ values simultaneously.Ckpre-computed polynomials that depend only on the chosen \xe2\x80\xa6Ag(Self::MODULUS - 1) / 2CmNumber of additional columns that a reduction to degree 2 \xe2\x80\xa6BhFormat: <code>slli rd, rs1, shamt</code>CiUnnormalizedLagrangeBasis(i) is (x^n - 1) / (x - omega^i)BjAccumulated witness for the program state.CjGiven a filename with encoded (witness, runtime table, \xe2\x80\xa6CmCommit to evaluations with custom blinding factors. It is \xe2\x80\xa6BfConstraint for one row of FF addition:ClDeserialize a field element of the scalar field of Vesta \xe2\x80\xa6CkGetting multiplicities for range check tables less or equalBl2^259 (see foreign field multiplication RFC)CkProvides the sponge params to be used with the other curve.0Bgpermutation coefficients over domain d8AeForeign field helpersClDegree of the quotient polynomial. Used to keep track of \xe2\x80\xa6CmComponents to be used to convert multivariate polynomials \xe2\x80\xa6CjMaximum degree of the constraints. It does include the \xe2\x80\xa6CgThe maximum number of bits the fields can be. It is \xe2\x80\xa6BhFormat: <code>srli rd, rs1, shamt</code>CeAccumulate the committed state by adding the last \xe2\x80\xa60AnTrack a high bound computationCnCompute the cross-terms of the given polynomial, scaled by \xe2\x80\xa6BcOutput example for N = 2 and D = 2:CnConnects the wires of the range checks in a single foreign \xe2\x80\xa6CeCreate a multi range check witness from compact limbsCmThis contains the DomainConstantEvaluations which is used \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6CkExtend the witness with external compact multi range_checksCjThis is the main entry point to fold two instances and \xe2\x80\xa6Cnfolding with a selector will assume that only the selector \xe2\x80\xa6Ceevaluation of the ForeignFieldAdd selector polynomialCeevaluation of the ForeignFieldMul selector polynomialBmThe commitment to the aggregation polynomial.AkThe aggregation polynomial.CmThis function computes a strict lower bound in the number \xe2\x80\xa6CfThe polynomials representing evaluated columns, in \xe2\x80\xa6DfThe integer <code>k</code> such that there exists a multiplicative \xe2\x80\xa6CeTotal number of constraints for all instructions, \xe2\x80\xa60BmCommitments to the accumulated program state.CnHelper. Combines large limbs into one element. Computation \xe2\x80\xa6ClCompute the list of indices to perform N nested loops of \xe2\x80\xa6CcForeign field addition gate selector over domain d8CiForeign field multiplication gate selector over domain d8CbReturn the Poseidon round constants as a constant.CkLoad the affine coordinates of the elliptic curve point \xe2\x80\xa6BlThe evaluations of the aggregation, over d8.Cievaluation of the Lookup range check pattern selector \xe2\x80\xa6Cmevaluation of the RangeCheck range check pattern selector \xe2\x80\xa6C`Save temporary accumulators into the environmentCnRepresent a polynomial either with its coefficients or its \xe2\x80\xa6BcGENERATOR^((MODULUS-1) / (2^s * \xe2\x80\xa6BgFormat: <code>sltiu rd, rs1, imm</code>CiCompute the cross terms of a list of polynomials. The \xe2\x80\xa6CnEvaluates the polynomial (x - w^{n - i}) * (x - w^{n - i + \xe2\x80\xa6CmThe structure used by the prover the compute the quotient \xe2\x80\xa6BhFormat: <code>srai rd, rs1, shamt</code>ChThe first instruction in the verifier circuit (often \xe2\x80\xa6CjThe blinder used to commit, to avoid committing to the \xe2\x80\xa6BaTrack a compact-multi-range-checkCgNumber of constraints for a given foreign field mul \xe2\x80\xa6CnNumber of constraints for a given range check circuit gate \xe2\x80\xa6CjCommit to evaluations, without blinding factors. It is \xe2\x80\xa6BfCompute non-zero intermediate productsChRetrieve or compute the digest for the corresponding \xe2\x80\xa6CbCreate witness for bound computation addition gateCnExtend the witness with external bound addition as foreign \xe2\x80\xa6Cjevaluation of the runtime lookup table selector polynomialBjFormat: <code>bgeu rs1, rs2, offset</code>CkThis function can be called before any call to a kimchi \xe2\x80\xa6CmProvides access to commitments to the extra columns added \xe2\x80\xa6CkThe actual number of instructions executed results from \xe2\x80\xa60CfThe left relaxed instance, including the potential \xe2\x80\xa6AmCreate new index for lookups.CgThe right relaxed instance, including the potential \xe2\x80\xa6DaEach entry in <code>kinds</code> has a corresponding selector \xe2\x80\xa6CkCreate range check gate for constraining compact limbs. \xe2\x80\xa6CmCreate foreign field muti-range-check gadget by extending \xe2\x80\xa6DiExtends a NOT gadget for <code>bits</code> length using Xor gates. It \xe2\x80\xa6CgGet all the constraints for the verifier circuit, only.CdReturn the number of additional columns added by \xe2\x80\xa60CnThe polynomial (x - w^{n - zk_rows}) * (x - w^{n - zk_rows \xe2\x80\xa6Akzeta^n and (zeta * omega)^nCmCombines the constraints for the Cairo gates depending on \xe2\x80\xa6CcA constraint function for A_0^7 + B_0 - FIXED_SEL_1CnExtend a NOT witness for less than 255 bits (native field) \xe2\x80\xa6CcExtend the witness with external multi range_checksCievaluation of the ForeignFieldMul range check pattern \xe2\x80\xa6DkExtends a bitwise negation gadget with <code>n</code> NOT components of \xe2\x80\xa6Bhzero-knowledge polynomial over domain.d8DkGets permutation_vanishing_polynomial_m from <code>VerifierIndex</code> \xe2\x80\xa6Aizero-knowledge polynomialCnExtends negation witnesses from generic gate, assuming the \xe2\x80\xa6DgSame as <code>get_lagrange_basis</code> but only using the domain size.ClThe digest of the program state after executing the last \xe2\x80\xa6CdCircuit generator function for 3 * A_0^7 + B_0 * \xe2\x80\xa6CcDefine the number of values we must absorb when \xe2\x80\xa6CmThe digest of the program state before executing the last \xe2\x80\xa6CkCompute all the possible two factors decomposition of a \xe2\x80\xa6CnEvaluates the polynomial (x - w^{n - zk_rows}) * (x - w^{n \xe2\x80\xa6CmExtend the witness with external high bounds additions as \xe2\x80\xa6CiCircuit generator function for 3 * A_0^7 + 42 * B_0 - \xe2\x80\xa6CbNo lookups, no selectors, only witness column. \xe2\x80\xa6CkExtend the witness with external compact multi range_checksCmA generic regression serialization test for serialization \xe2\x80\xa6CkThe polynomial that vanishes on the zero-knowledge rows \xe2\x80\xa6Ckthe polynomial that vanishes on the zero-knowledge rows \xe2\x80\xa6CjThis is same as _lagrange_commitments, but returns the \xe2\x80\xa60CgA constraint function for 3 * A_0^7 + B_0 * FIXED_SEL_34CdA constraint function for 3 * A_0^7 + 42 * B_0 - \xe2\x80\xa6CbReads the lagrange commitments from a raw pointer.0")