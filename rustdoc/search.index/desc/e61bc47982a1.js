rd_("BcGeneric domain string argument typeCmAn alias for the intended usage of the expression type in \xe2\x80\xa6CkAn expression over /generic/ (not circuit-specific) columnsClType to represent a constraint on the individual columns \xe2\x80\xa6EgLet <code>M</code> be the power of 2^64 nearest to <code>Self::MODULUS_BITS</code>. \xe2\x80\xa6C`t for 2^s * t = MODULUS - 1, and t coprime to 2.CmThe parameter a is the coefficients of the elliptic curve \xe2\x80\xa6CnA list of functions/looked-up values. Invariant: for fixed \xe2\x80\xa600CnThe vector of group elements for committing to polynomials \xe2\x80\xa60BjThe polynomial keeping the sum of each rowBmA group element used for blinding commitments0kaggregation0CjThe multiplicity polynomials; by convention, this is a \xe2\x80\xa6AlThe multiplicity polynomials11CjThe coin folding combiner will be used to generate the \xe2\x80\xa6Cnpermutation polynomials (PERMUTS-1 evaluations because the \xe2\x80\xa6AoThe signature scalar component.A`wire evaluationsAcwitness polynomialsBmGets w from <code>VerifierIndex</code> lazilyB`domain offset for zero-knowledgeCj<code>X / Z</code> projection of the affine <code>X</code>0lX-coordinateCj<code>Y / Z</code> projection of the affine <code>Y</code>0BgThe permutation aggregation polynomial.Agpermutation evaluationsAfpermutation polynomialDeProjective multiplicative inverse. Will be <code>0</code> only at \xe2\x80\xa60AjFunction arguments/resultsBeThe native field we are working with.ChFrame pointer/saved register. This is the same register.nGlobal pointerBoIndex of high limb (in 3-limb foreign elements)AkCurrent instruction pointerBnIndex of low limb (in 3-limb foreign elements)CaIndex of middle limb (in 3-limb foreign elements)AjContains the success value000000BdFormat: <code>or rd, rs1, rs2</code>AhR2 = R^2 % Self::MODULUSBjContains the 24 round constants for KeccaknReturn addressoSaved registersmStack pointerAlTemporary/alternate registerkTemporariesnThread pointerAnReturns the allocation pointerChAllocation pointer: points to first free space in memoryAnconstraints system polynomialsAjevaluations over domain d4Ajevaluations over domain d8AiReturns the frame pointerCjFrame pointer: points to the beginning of the stack in \xe2\x80\xa6olookup multiset000BdReturns the ID of the runtime table.mThe table ID.0mThe table id.Bivector of rounds of L &amp; R commitmentsBiVector of rounds of L &amp; R commitments1nlookup witness0CmDegree-2 variable encoding the OR of two variables, which \xe2\x80\xa6AkReturns the program counterBlProgram counter: points to address in memoryCground constant that are relevant for this specific gateCgThe x-coordinate of the commitment point R from the \xe2\x80\xa6AnA final folded commitment basemInitial inputmCurrent inputoAdd two values.hAdditionBeFormat: <code>add rd, rs1, rs2</code>BeFormat: <code>and rd, rs1, rs2</code>AlThe gadget defining the app.BgValues involved in Chi permutation stepBaThe dimension of the Keccak stateBeFormat: <code>div rd, rs1, rs2</code>ClAn environment is used to contain the state of a long \xe2\x80\x9c\xe2\x80\xa6CbRepresents the environment for the logup argument.CiThis structure represents the environment the virtual \xe2\x80\xa6CgThe environment keeping the constraints between the \xe2\x80\xa61CkThis struct contains all that needs to be kept track of \xe2\x80\xa60AhContains the error value000000CcThe foreign field we are emulating (one of the two)kInvalid hexAlINV = -MODULUS^{-1} mod 2^64AlMultiplication of two valuesBeFormat: <code>mul rd, rs1, rs2</code>CkCreates the 5x5 table of rotation bits for Keccak modulo 64mA public gateBeFormat: <code>rem rd, rs1, rs2</code>kSubtractionBeFormat: <code>sub rd, rs1, rs2</code>AdHelper to obtain twomBuild for WebBeFormat: <code>xor rd, rs1, rs2</code>CnThis module includes the AND gadget implementation and the \xe2\x80\xa6AkThe column of this variable0DiReturns <code>x / y</code>, storing the results in <code>position</code>.BjReturns the destination of the instructionkDestinationBbReturns bit-flag for 16th positionCeOutputs the final value of the pointers after the \xe2\x80\xa6Ajfinal computation pointersBaDisplay a JSON value as a string.BnFormats the signature as a hexadecimal string.CjInitialize a random input with a random value of given \xe2\x80\xa6CnIndex into a JSON array or map. A string index can be used \xe2\x80\xa6CgOutputs the initial value of the pointers after the \xe2\x80\xa6Aminitial computation registersCmThis module contains the implementation of the polynomial \xe2\x80\xa6ClThis module implements the KZG protocol described in the \xe2\x80\xa6BhReturns the length of the runtime table.CeThe number of entries contained in the runtime table.B`Returns the length of the table.Cbnumber of limbs used for the foreign field elementAmReturns the number of chunks.CeGet size of the full memory including dummy 0th entryBfThe left-hand side of the composition.CkHandy macro to return the filename and line number of a \xe2\x80\xa6CgReturn field element as byte, if it fits. Otherwise \xe2\x80\xa6CcApply a function to all the coefficients in the \xe2\x80\xa6DgA matrix that maps all cells coordinates <code>{col, row}</code> to \xe2\x80\xa6nThe MDS matrixCfHelper to access maximum distance separable matrix \xe2\x80\xa6Ahstate of the computationAefull execution memoryDkInitializes a new foreign element from an absolute <code>BigUint</code> \xe2\x80\xa6ClThis will create a context that allows for benchmarks of \xe2\x80\xa6BkCreates a new set of wires for a given row.AcCreates a new Wire.BgGenerates the shifts for a given domainAcCreates a new LogupCbCreates a new witness with <code>rows</code> rows.BfCreate a new empty random oracle inputCmCreate a new cryptographic sponge using arithmetic sponge \xe2\x80\xa6AeCreates a new sponge.BkCreate secret key from scalar field elementCfCreates a new signature from the given field elements.ClCreates a new foreign element from an array containing N \xe2\x80\xa6CnStarts a new Keccak environment for a given hash index and \xe2\x80\xa6CfCreates a new RAMLookup from a mode, a table ID, a \xe2\x80\xa6ChCreate a new memory structure from a vector of field \xe2\x80\xa6CkCreates a new Cairo execution step from a step index, a \xe2\x80\xa6CiCreates a Cairo execution from the public information \xe2\x80\xa6B`Creates a new triple of pointersAjCreates a CairoInstructionBhCreates a CairoWord from a field elementCmThis module includes the definition of the NOT gadget and \xe2\x80\xa6CnDegree-1 variable encoding the negation of the input Note: \xe2\x80\xa6AfBuild the constant oneBmReturns a variable representing the value oneBlReturns the first operand of the instructionmFirst operandBmReturns the second operand of the instructionnSecond operandChPads the message with the 10*1 rule until reaching a \xe2\x80\xa6CiThis module contains a list of property tests for the \xe2\x80\xa6BcExponentiate a constant expression.BbRaise the value to the given powerCdRaise each evaluation to some power <code>pow</code>BeReturns the result of the instructionfResultBgThe right-hand side of the composition.hROT gateBgThe row (Curr of Next) of this variable0CaYou can use this module for serialization and \xe2\x80\xa6nSID polynomialAjpolynomial commitment keysBoGets srs from <code>VerifierIndex</code> lazily1cSRSCkThe \xe2\x80\x9crunning-sum\xe2\x80\x9d over the rows, coined <code>\xcf\x86</code>CkReturns the expression corresponding to the literal \xe2\x80\x9c2\xe2\x80\x9da2iValue twoBmReturns a variable representing the value twoA`type of the gatehXOR gateAkXOR pattern lookup selectorCmThis module includes the definition of the XOR gadget for \xe2\x80\xa6CmDegree-2 variable encoding the XOR of two variables which \xe2\x80\xa6C`Both challenges used in the permutation argumentCdThe first challenge used in the permutation argumentBoThe challenge to compute 1/(beta + lookupvalue)AjRepresents a JSON boolean.BfFormat: <code>divu rd, rs1, rs2</code>DfAn multi-variate polynomial over the base ring <code>C</code> with \xe2\x80\xa6CfGates in the PLONK constraint system. As gates are \xe2\x80\xa6BhValues involved in Iota permutation stepBfFormat: <code>mulh rd, rs1, rs2</code>AfA human readable name.0BoA dummy gadget, doing nothing. Use for padding.iNo value.AmRepresents a JSON null value.AiSum a value to a constantBfFormat: <code>remu rd, rs1, rs2</code>CfDefine the side of the temporary accumulator. When \xe2\x80\xa6BbSome value of type <code>T</code>.ClWire documents the other cell that is wired to this one. \xe2\x80\xa6iZero gate0CaBoth challenges used in the permutation argument.BdThe challenge \xce\xb2 from the PLONK IOP.CeThe evaluation point used for the lookup polynomials.CmReturns an offset of 16 bits to its biased representation \xe2\x80\xa6lCaml helpersCeConvenience function for constructing cell variables.0CiA witness row is represented by an array of N witness \xe2\x80\xa600AePolynomial commitmentAgWitness for current rowA`current pointersA`A single column.Bkfull memory vector, None if non initializedBfcoefficient for the group endomorphismAfendoscalar coefficientCkEvaluate the polynomial at the vector point <code>x</code>.00AoReturns the argument unchanged.000000000000000000000000000000DjConvert 32-bit floating point number to <code>Value::Number</code>, or \xe2\x80\xa6DjConvert 64-bit floating point number to <code>Value::Number</code>, or \xe2\x80\xa6BlConvert boolean to <code>Value::Bool</code>.CjConvert <code>String</code> to <code>Value::String</code>.CcConvert string slice to <code>Value::String</code>.CkConvert copy-on-write string to <code>Value::String</code>.CjConvert <code>Number</code> to <code>Value::Number</code>.CmConvert map (with string keys) to <code>Value::Object</code>.ChConvert a <code>Vec</code> to <code>Value::Array</code>.BmConvert a slice to <code>Value::Array</code>.CdConvert <code>()</code> to <code>Value::Null</code>.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CgThis module implements Plonk constraint gate primitive.BcHash input and obtain result outputDiCall the internal function <code>init_</code> and return the computed \xe2\x80\xa6CkInitialize a witness based on layout and computed variablesCkSet the initial state based on domain separation string \xe2\x80\xa6BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CoConstruct a <code>serde_json::Value</code> from a JSON literal.DgComputes <code>prod_{j != n} (1 - omega^j)</code> Assure we don\xe2\x80\x99t \xe2\x80\xa6DgReturn the value <code>prod_{j != 1} (1 - omega^j)</code>, used for \xe2\x80\xa6DhThe value <code>prod_{j != 1} (1 - omega^j)</code>, used for efficiently0DiThe value <code>prod_{j != 1} (1 - \xcf\x89^j)</code>, used for efficiently \xe2\x80\xa6CjTurns a non-hiding polynomial commitment into a hiding \xe2\x80\xa60CcThis modules implements some math helper functions.ClAn interpreter for the MIPS instruction set. This module \xe2\x80\xa6BoNumber encoding format (base-10 or hexadecimal)BdWhether it is a read or write lookup0AdWitness for next rowAenext wire evaluations0Af(if any) next pointersCkCreate an opening proof for a batch of polynomials. The \xe2\x80\xa6kParameters:Eg<code>pows(d, x)</code> returns a vector containing the first <code>d</code> powers \xe2\x80\xa6hpointersAgGenerate random keypairAlGenerate a random secret keyAnRead element in memory addressCkCustom seed for test vector generation (32 bytes as hex \xe2\x80\xa6CdReturns the sign of the operation as a field elementFdSign <code>input</code> (see <code>Hashable</code>) using keypair <code>kp</code> and return the \xe2\x80\xa6CeEach chunk polynomial has degree <code>size-1</code>.0BcReturns the size of the instructionAgSize of the instructionBnReturns the square root of self, if it exists.CjExecute a single step of the MIPS program. Returns the \xe2\x80\xa6CkEntrypoint for the interpreter. It executes one step of \xe2\x80\xa6lCurrent stepBmExecute a single step in the RISCV32i programEeTakes the value out of the <code>Value</code>, leaving a <code>Null</code> in its \xe2\x80\xa6CkRecursively print the expression, except for the cached \xe2\x80\xa6Aethis wire evaluations0Aistate auxiliary variablesAcauxiliary variablesCkProduces a <code>circuit.html</code> in the current folder.DdWire the cell at <code>col</code> to another cell (<code>to</code>).A`instruction wordCbReturns the content of the word as a field elementCkThe Cairo language works natively for field elements in \xe2\x80\xa6AgBuild the constant zeroBnthis function creates \xe2\x80\x9cempty\xe2\x80\x9d circuit gateCiCreates a new foreign element representing the value zeroBnReturns a variable representing the value zeroBgEvaluation at the challenge point zeta.CeReturns the end of the circuit, which is used for \xe2\x80\xa6CjUpdate by 2 in call instructions or zero behaviour for \xe2\x80\xa6AkUsed to combine constraintsBdThe challenge to combine constraintsAhRepresents a JSON array.gA cacheChA constant, the constructor contains the constant itselfDkRepresents a multivariate polynomial of degree less than <code>D</code> \xe2\x80\xa6CeErrors that can occur during the check of the witnessBdAll foreign field operations allowedAjFormat: <code>fence</code>CeThe second challenge used in the permutation argumentChThe challenge to combine tuple sum gamma^i lookupvalue_iCkAllows us to quickly implement a LaTeX encoder for each \xe2\x80\xa6CnGeneric structure to represent a (vector) lookup the table \xe2\x80\xa6BgFormat: <code>mulhu rd, rs1, rs2</code>BfTotal number of columns in this index.BiValues involved in PiRho permutation stepBkFIXME: a proof for the Nova recursive SNARKCiCurrent step performs a round of the permutation. The \xe2\x80\xa6CkVariants of Keccak steps available for the interpreter. \xe2\x80\xa6BiValues involved in Theta permutation stepAfindex of all registersBdThe challenge \xce\xb1 from the PLONK IOP.BmReturns flagset for allocation pointer updateBjBuild the ConstraintSystem from a Builder.jCache itemAoVector of scalar field elementskCoefficientAnCoefficient value at index idxBbCrumb constraint for 2-bit value xBbConstrain to crumb (i.e. two bits)BhThis file defines a trait similar to \xe2\x80\xa6CfThis module contains a useful trait for recursion: \xe2\x80\xa6CmCreate a dummy signature, whose components are both equal \xe2\x80\xa6EhThe empty <code>CompressedPubKey</code> value that is used as <code>public_key</code>\xe2\x80\xa6CiProvides the coefficients for the curve endomorphism, \xe2\x80\xa60EgReturns 1 if <code>x</code> is equal to <code>y</code>, or 0 otherwise, storing the \xe2\x80\xa60CiThis module implements the <code>ProverError</code> type.CnThe evaluations of a polynomial over the domain <code>D</code>oIf no chunking:CfTwo evaluations over a number of committed polynomials2CdForeign field multiplication pattern lookup selectorCnDefinition of some constants for easier readability of the \xe2\x80\xa6BdThe challenge \xce\xb3 from the PLONK IOP.mcircuit gatesCireturns the y-coordinate if x is a valid point on the \xe2\x80\xa6FaGiven variable <code>x</code> and position <code>ix</code>, it (hybrid) writes <code>x</code> \xe2\x80\xa6EeIndex into a <code>serde_json::Value</code> using the syntax <code>value[0]</code> orCjHandy function to quickly create an expression for a gate.AoThe index selector polynomials.C`Map the column alias to the actual column index.0CnMap the column alias to the actual column index. Note that \xe2\x80\xa60DeCreate an evaluation over the domain <code>res_domain</code>. The \xe2\x80\xa6AjReturns the inner witness.CmReturns the 100 step input variables, which correspond to \xe2\x80\xa6ClThis function returns the current word instruction being \xe2\x80\xa6CbReturns the field element corresponding to the \xe2\x80\xa6Allimbs in little endian order0ClThis file will implement a logup argument to allow users \xe2\x80\xa6CmImplement a variant of the logarithmic derivative lookups \xe2\x80\xa6CkConverts the expression in OCaml code Recursively print \xe2\x80\xa6BjReturns flagset for program counter updateB`Borrow public key as curve pointnrecursion dataAfThe chunk polynomials.ClMultivariate polynomial dense representation using prime \xe2\x80\xa6CfThis module implements the data structures of a proof.B`batched commitment opening proofAcThe proof to verifyClGenerate a proof. All the information to make a proof is \xe2\x80\xa6CnMake a PlonKish proof for the given circuit. As inputs, we \xe2\x80\xa6BkReset the environment to build the next row0ChFrom a vector of shifts, resets the underlying value \xe2\x80\xa6CdRestore the initial state that was set most recentlyCmReset the sponge back to its initial state (as if it were \xe2\x80\xa6CdReset the environment to handle the next instructionCmReturns a variable that encodes the current round number [\xe2\x80\xa6CbThis function \xe2\x80\x9cscales\xe2\x80\x9d (multiplies all the \xe2\x80\xa6CmThis function \xe2\x80\x9cscales\xe2\x80\x9d (multiplies) a polynomial with \xe2\x80\xa6CmThis module defines methods and structures for setting up \xe2\x80\xa6DfCompute the offset corresponding to the <code>CurrOrNext</code> value.Afwire coordinate shiftsCkFrom each quarter in sparse representation, it computes \xe2\x80\xa612CjUtility function for shifting poly along domain coordinateBoState of the current row in the execution traceAgThe state of the sponge00CnOutputs the total number of steps of the execution carried \xe2\x80\xa6Aetotal number of stepsDiReturns the lookup table used by the pattern, or <code>None</code> if \xe2\x80\xa6ChThe evaluations of the combined lookup table polynomial.AfUtils only for testingBnReturns a reference to the set of instructionsBoexecution trace as a vector of CairoInstructionCmThis module contains functions to work with prime numbers \xe2\x80\xa6CjEvaluate the given constant expression to a field element.0BeLinear combination of local-positionsCaThe columns containing the content of this lookup0CkReturns the number of columns, i.e. the width of the table.CjThis module implements Plonk circuit gate wires primitive.Cegate wiring (for each cell, what cell it is wired to)BcWrite u64 element in memory addressAcpre-computed zeta^nBiUpdate ap by adding a number of positionsAkUpdate ap by self incrementClThis type can be used to create a mapping between powers \xe2\x80\xa6CjThe generic type of column the environment can use. In \xe2\x80\xa6CeA type representing the variables involved in the \xe2\x80\xa6BjDescribe a generic indexed variable X_{i}.BhA specific gate did not verify correctlyCmCustom lookup table The index of the table is used as the \xe2\x80\xa6BaDestination refers to ap registerCmThe different multiplicaive domain sizes that can be used \xe2\x80\xa6CnUse as a result of the expression evaluations routine. For \xe2\x80\xa6AlFormat: <code>fence.i</code>CjThis enum represents the different gadgets that can be \xe2\x80\xa6CbInterface for hashing <code>Hashable</code> inputsAfNaive Keccak structureAcThe lookup argumentCgAdditive lookups used in the MSM project based on LogupCkThe lookups struct based on RAMLookups for the VM table IDsDk<code>MPrism</code> allows one to Something like a Prism, but for Maybe \xe2\x80\xa6CeGeneric trait to represent a multi-variate polynomialBhFormat: <code>mulhsu rd, rs1, rs2</code>AhNext instruction pointerA`Build for NodeJSCiRepresents a JSON number, whether integer or floating \xe2\x80\xa6BcFirst operand refers to ap registerBdSecond operand refers to ap registerBdSecond operand refers to fp registerAiRepresents a JSON object.AmUpdate pc by an absolute jumpBhUpdate pc by a conditional relative jumpAlUpdate pc by a relative jumpCaDefault increase of pc by adding instruction sizeClThe domain separation string to use in the hash. This is \xe2\x80\xa6jPublic keyBnThe number of rounds in the Keccak permutationBoThe result of a proof creation or verification.BcThe result of a proof verification.AaPublic key ResultnKeypair result0BdResult alias using FieldHelpersErrorAbInvalid secret keyjSecret keyCkShifts represent the shifts required in the permutation \xe2\x80\xa6AlInterface for signed objectsCjSkip the given number of tokens if the feature is enabled.CiThe lens source type, i.e., the object containing the \xe2\x80\xa6DiRepresents a multivariate polynomial in <code>N</code> variables with \xe2\x80\xa6CmCryptographic sponge interface - for hashing an arbitrary \xe2\x80\xa6AhCurrent step is a spongeAiRepresents a JSON string.CnGeneric sub-environment struct: don\xe2\x80\x99t use directly. It\xe2\x80\x99\xe2\x80\xa6CkThe lens target type, i.e., the field to be accessed or \xe2\x80\xa6BjAbsorbs the field element into the sponge.C`Absorb an array of field elements <code>x</code>BcThe lookup aggregation polynomials.BoCommitment to the lookup aggregation polynomialCnThis module implements an abstraction to keep track of the \xe2\x80\xa6CnThe powers of alpha: 1, alpha, alpha^2, etc. If set to Some\xe2\x80\xa6DkIf the <code>Value</code> is a number, represent it as f64 if possible. \xe2\x80\xa6DcIf the <code>Value</code> is an integer, represent it as i64 if \xe2\x80\xa6DfIf the <code>Value</code> is a String, returns the associated str. \xe2\x80\xa6DcIf the <code>Value</code> is an integer, represent it as u64 if \xe2\x80\xa6kReturns \xe2\x80\xa6CnReturns the minimum number of bits required to represent a \xe2\x80\xa6CiFor each row in the circuit, which lookup-constraints \xe2\x80\xa6CkModules mimicking the defined structures used by Cannon \xe2\x80\xa6AfThe chunk evaluations.AaGate coefficientsCfpublic selector polynomials that can used as handy \xe2\x80\xa6BhList all columns used by the interpreterCmThis module defines the custom columns used in the Keccak \xe2\x80\xa6CmCommits a polynomial, potentially splitting the result in \xe2\x80\xa6CjInitialize the environment for creating constraints of \xe2\x80\xa6EjInitializes the <code>ConstraintSystem&lt;F&gt;</code> on input <code>gates</code> and \xe2\x80\xa6BoCreate the <code>LookupConstraintSystem</code>.BhCreate the default lookup configuration.ChCreate a foreign field multiplication witness Input: \xe2\x80\xa6CjCreate a single range check witness Input: 88-bit value v0AlCreate a layout variable mapBgCreate witness cell with constant valueClCreate witness cell copied from bits [start, end) of the \xe2\x80\xa6CiCreate a witness cell copied from the witness cell at \xe2\x80\xa6CgCreate witness cell copied from the witness cell at \xe2\x80\xa6CjCreate witness cell assigned from a variable name a lengthCnCreate witness cell assigned from the bits [start, end) of \xe2\x80\xa6CaCreate witness cell assigned from a variable nameGbCreates 4 evaluation domains <code>d1</code> (of size <code>n</code>), <code>d2</code> (of size <code>2n</code>\xe2\x80\xa6CiThis function constructs prover\xe2\x80\x99s zk-proof from the \xe2\x80\xa6Cathis function compiles the index from constraintsCnCreate an environment for the prover to create a proof for \xe2\x80\xa6BiCreate a new empty-state witness builder.BiCreate an SRS of size <code>depth</code>.AoCreate a KZG proof. Parameters:CmReturn the degree of the expression. The degree of a cell \xe2\x80\xa60BeReturns the degree of the polynomial.00Cethe last evaluation of the Fq-Sponge in this protocolCjConsumes the sponge and returns the current digest, by \xe2\x80\xa6DkCompute the digest of the <code>VerifierIndex</code>, which can be used \xe2\x80\xa6AhObtain has result outputCbReturns a scalar field digest using the binary \xe2\x80\xa6DiReturns the digest of <code>self</code>. Note: this is implemented as \xe2\x80\xa6CoReturns <code>(x / y, x % y)</code>, storing the results in \xe2\x80\xa6Abevaluation domainsBgThe domains used in the PLONK argument.Aaevaluation domain11A`Double the valueCnIf any, an error that occurred during the execution of the \xe2\x80\xa6CnExpands a quarter of a word into the sparse representation \xe2\x80\xa6ChExtend an existing witness with a single range check \xe2\x80\xa6AbOutput file formatCmThis module obtains the gates of a foreign field addition \xe2\x80\xa60A`Range check gateBiThe hasher instance used to hash messagesCfThis module provides the CryptoDigest trait, which \xe2\x80\xa6CkThis module includes some field helpers that are useful \xe2\x80\xa6CfInsert a variable and corresponding value into the \xe2\x80\xa6DbReturns true if the <code>Value</code> is a number that can be \xe2\x80\xa6EfReturns true if the <code>Value</code> is an integer between <code>i64::MIN</code> \xe2\x80\xa6AfParity of y-coordinateCmDegree-1 variable encoding whether the input is the value \xe2\x80\xa6ChReturns a degree-1 variable that encodes whether the \xe2\x80\xa6DiReturns true if the <code>Value</code> is an integer between zero and \xe2\x80\xa6AbKeccak hash moduleCaAn interpreter for an optimised version of KeccakfKimchinWitness layoutBaReturns the length of each table.CbThis module implement the lookup argument. See \xe2\x80\xa6DjSet up the lookup tables. If not invoked, it is <code>vec![]</code> by \xe2\x80\xa6AnLookup pattern lookup selectorAkLookup specific polynomialsBjCommitments related to the lookup argumentBiLook up (read) value from a lookup table.2CkThis module represents the Cairo memory, containing the \xe2\x80\xa6EhReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.EeReturns <code>(x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, storing the results in \xe2\x80\xa6DiThis module contains the definition of the <code>MVPoly</code> trait, \xe2\x80\xa6AbNegate: 2^T - selfBbReturns flagset for operation codeCnReturns the 100 step output variables, which correspond to \xe2\x80\xa6AdPadded preimage dataBlA prover for the folding/accumulation schemeCeThis module implements prover\xe2\x80\x99s zk-proof primitive.BdPublic key structures and algorithmsCjSet up the number of public inputs. If not invoked, it \xe2\x80\xa6Agnumber of public inputsAhpublic input polynomials1jPublic keyClGenerate a random number of correct lookups in the table \xe2\x80\xa60DgGenerate a random polynomial of maximum degree <code>max_degree</code>.00CiReduce linear combinations in the lookup entries to a \xe2\x80\xa6CgResizes memory with enough additional None slots if \xe2\x80\xa6ChThis module represents a run of a Cairo program as a \xe2\x80\xa6Bjsample coordinate shifts deterministicallyBjBorrows secret key as scalar field elementBaSecret key structures and helpersjSecret keyBiShifts all the coefficients to the right.Acretrieve the shiftsDfThe coefficients <code>k</code> (in the Plonk paper) that create a \xe2\x80\xa6ClComputes the sorted lookup tables required by the lookup \xe2\x80\xa6BdThe sorted lookup table polynomials.CjCommitments to the sorted lookup table polynomial (may \xe2\x80\xa6ChThe sorted polynomials <code>s</code> in different formsClReturns the expansion of the 4 dense decomposed quarters \xe2\x80\xa6CfSponge used to coin and absorb values and simulate \xe2\x80\xa6BbCompute the square a field elementB`Compute the square of this valueAfSquare each evaluationAgSRS for the first curveAhSRS for the second curveBiThe commitment to the quotient polynomialBhThe fixed tables used in the Keccak gateAoTarget platform (nodejs or web)AlDeserialize keypair into hexAoDeserialize public key into hexBjDeserialize compressed public key into hexAoDeserialize secret key into hexA`Serialize to hexBbAssign a unique ID, as a u32 valueBiReturn first 64 bits of the field elementCbThis implements the constraints of the Cairo gatesCjThis module contains the code that executes a compiled \xe2\x80\xa6AoConsume hash <code>input</code>CfThis function verifies the consistency of the wire \xe2\x80\xa6CeChecks that all the lookup constraints are satisfied.1EdVerify a proof <code>ProverProof</code> using a <code>VerifierIndex</code> and a \xe2\x80\xa6FcVerify that the signature <code>sig</code> on <code>input</code> (see <code>Hashable</code>) is \xe2\x80\xa6AhVerify the opening proofCkThis function verifies a batch of polynomial commitment \xe2\x80\xa6ClVerify a proof. Note that it only works for two elements \xe2\x80\xa6C`The commitments to the witness (execution trace)BlThe commitment to the permutation polynomialCmOrder of absorb steps in the computation depending on the \xe2\x80\xa6AcNumber of registersAhA key for a cached valueClA circuit is specified as a public input size and a list \xe2\x80\xa6BmTrait to connect a pair of cells in a circuitBfContains variable used in the templateCeEC variable base scalar multiplication with group \xe2\x80\xa60CkThis trait defines a common arithmetic operations interfaceAgGeneric arithmetic gateBoImplementation of the <code>Generic</code> gate1AaKeypair structurenId for mainnetCeMaximum number of memory or register accesses per \xe2\x80\xa60AiThe modulus of the field.BaThe message to be signed/verifiedCjNumber of limbs representing one foreign field element \xe2\x80\xa6BaSecond operand is double indexingBaSecond operand is immediate valueBaOperation code is an assert-equalAjOperation code is a returnCdThis trait contains methods to obtain the offset \xe2\x80\xa6CkNumber of registers that can be wired (participating in \xe2\x80\xa6CdPosition of destination offset of 16 bits within \xe2\x80\xa6CfPosition of first operand offset of 16 bits within \xe2\x80\xa6CgPosition of second operand offset of 16 bits within \xe2\x80\xa6ChA running program that the (folding) interpreter has \xe2\x80\xa6AeResult is an additionAjResult is a multiplicationAjResult is a single operandAmRandom oracle input structureCgSchnorr signer context for the Mina signature algorithmCmYou can use SerdeAs with serde_with in order to serialize \xe2\x80\xa6AjVariants of Keccak spongesAcId for all testnetsCmA clone of the SRS struct that is used for serialization, \xe2\x80\xa6ClSince we don\xe2\x80\x99t have a specific type for the wires of a \xe2\x80\xa6CnThe witness columns used by a gate of the MSM circuits. It \xe2\x80\xa6CdThe type that represents the execution trace. It \xe2\x80\xa6CbReturns the destination address of the instructionAcDestination addressCdReturns the first operand address of the instructionAeFirst operand addressCeReturns the second operand address of the instructionAfSecond operand addressDhIf the <code>Value</code> is a Boolean, returns the associated bool. \xe2\x80\xa6DhIf the <code>Value</code> is a Null, returns (). Returns None otherwise.EfExtract the bits from the variable <code>x</code> between <code>highest_bit</code> \xe2\x80\xa60ChCreates a constraint to enforce that b is either 0 or 1.AdConstrain to booleanAklength of the public memoryCmBatch elliptic curve algorithms based on the batch-affine \xe2\x80\xa6B`Compose field limbs into BigUintAjCompose limbs into BigUintCmComposes a vector of 4 dense quarters into the dense full \xe2\x80\xa6CnThe final decider, i.e. the SNARK used on the accumulation \xe2\x80\xa6ClInitialize the environment for creating Expr constraints \xe2\x80\xa6BoReturns an instance with all features disabled.CnThis function creates an instance of a default CairoContext\xe2\x80\xa6CgReturns the (x,q)-th term of ThetaDenseC, as a variableBnReturns the (y,x,q)-th variable of PiRhoDenseEClThis module describes the evaluation domains that can be \xe2\x80\xa6BhReturns flagset for destination registerBoVector of values inside each entry of the tableCdProvides a full list of entries for the given table.1C`Executes a Cairo step from the current registersCmThis function simulates an execution of the Cairo program \xe2\x80\xa6AeReturns i-th bit-flagBkCreates a new set of wires for a given row.ClInitializes a new foreign element from a set of bytes in \xe2\x80\xa6BoThis module implements the double generic gate.CnMutably index into a JSON array or map. A string index can \xe2\x80\xa6ClObtains an SRS for a specific curve from disk. Panics if \xe2\x80\xa6CnThe index of the latest allocated variable in the circuit. \xe2\x80\xa6AeInverse of a variable00DcReturns true if the <code>Value</code> is a Null. Returns false \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6BaKeypair structures and algorithmsCjConvenience function for constructing expressions from \xe2\x80\xa60A`Create a literalCgReturns the layout of the lookups used by this pattern.ClInstantiations of Logups for the MSM project Instantiate \xe2\x80\xa6CdInstantiation of the lookups for the VM project. \xe2\x80\xa6BkVariables that are looked up in the circuitCjCreates all possible lookups to the Keccak constraints \xe2\x80\xa6ChThe mapping between constraint types and powers of alphaCmThis function computes the next program counter Panics if \xe2\x80\xa6CgReturns the destination offset in biased representationCiReturns the first operand offset in biased representationCjReturns the second operand offset in biased representationBjReturns flagset for first operand registerBkReturns flagset for second operand registerAbThe opening proof.CmThis type and logic only exists for the OCaml side. As we \xe2\x80\xa6Bgthe challenges produced in the protocolBmThis function runs the random oracle argumentgOraclesAnOutput directory for wasm-packBfByte-length of the 10*1 pad (&lt;=136)CkThis module defines Property-based tests for the SRS trait.CmPickles flavor of the o1vm. This is the pickles flavor of \xe2\x80\xa6BcLooks up a value by a JSON Pointer.CeCreates a new lazy value that is already initialized.CnReturns the product of all the field elements belonging to \xe2\x80\xa6CbReads one value when <code>if_is_true</code> is 1.BaReturns flagset for result logicsBmRandom oracle input structures and algorithmsAcRun the applicationCfAssigns the witness values needed in the chi algorithmBbRun an iteration of the IVC schemeDiSet up the runtime tables. If not invoked, it is <code>None</code> by \xe2\x80\xa6CbOptional commitment to concatenated runtime tablesCnThis module implements Plonk prover polynomial evaluations \xe2\x80\xa6AmMina Schnorr signature schemeBnThis function computes the destination addressC`This function computes the first operand addressCiThis function computes the second operand address and \xe2\x80\xa6CiThis function computes the value of the result of the \xe2\x80\xa6BaSqueeze an output from the spongeCmReturns the (y,x,q)-th input of the theta algorithm, as a \xe2\x80\xa6DdReturns the <code>idx</code>-th output of a round step as a variableAaSerialize to bitsDkWrites a <code>VerifierIndex</code> to a file, potentially appending it \xe2\x80\xa6e2^powlPower of twoBmReturns a variable representing the value 2^xCkThe witness of the current instance of the circuit. The \xe2\x80\xa6AgWitness cell (row, col)lWitness rowsCgThis module computes the witness of a foreign field \xe2\x80\xa6C`Foreign field multiplication witness computationAoRange check witness computationBeApply the <code>witness</code> value.AjKeccak witness computationCiHelper function to quickly create an expression for a \xe2\x80\xa6AnThe witness column polynomialsCmThe witness columns that the environment is working with. \xe2\x80\xa6CnThe witness column polynomials. Includes relation columns, \xe2\x80\xa6CfThis file contains the witness for the Keccak hash \xe2\x80\xa6BkThe full state of the Keccak gate (witness)CmThe witness column polynomials. Includes relation columns \xe2\x80\xa6BaThe number of zero-knowledge rowsCgthe number of randomized rows to achieve zero knowledgeCdThe interface for a minimal argument implementation.BiFormat: <code>beq rs1, rs2, offset</code>CkThe number of bits that can be reliably stored. (Should \xe2\x80\xa6A`Handy re-exportsBoLook up the value from the given fixed table IDBmWitness cell copied from another witness cell0CnThis trait contains methods that decompose a field element \xe2\x80\xa60DgAbstracts a sponge operating on a base field <code>Fq</code> of the \xe2\x80\xa6CnAbstracts a sponge that operates on the scalar field of an \xe2\x80\xa6CjThe different types of gates the system supports. Note \xe2\x80\xa6ClHandy re-exports The different types of gates the system \xe2\x80\xa6AnInterface for hashable objectsDdIdentity <code>MPrism</code> from any type <code>T</code> to itself.BgFormat: <code>lb rd, offset(rs1)</code>BgFormat: <code>lh rd, offset(rs1)</code>BgFormat: <code>lw rd, offset(rs1)</code>AhOperation code is a callCnThis trait contains functions to obtain the Cairo pointers \xe2\x80\xa6CfRepresent a polynomial commitment when the type is \xe2\x80\xa6AiPoseidon permutation gateCnImplementation of the Poseidon gate Poseidon quotient poly \xe2\x80\xa61AgPoseidon hasher contextBmA position can be seen as an indexed variable0CjAn element of the Keccak state is 64 bits. However, we \xe2\x80\xa6CfColumns related to the relation encoded in the circuitChSubEvals is used to refer to evaluations that can be \xe2\x80\xa6ClThe variable should be seen as a certain object that can \xe2\x80\xa6ChA type representing a variable which can appear in a \xe2\x80\xa6DkAbsorbs a base field point, that is a pair of <code>Fq</code> elements. \xe2\x80\xa6CjAllocate a new variable in the circuit for the current rowCeThe application size, i.e. the number of rows per \xe2\x80\xa6CkAn argument is simply a number of constraints, which we \xe2\x80\xa6ChArkworks types This module contains wrapper types to \xe2\x80\xa6DiIf the <code>Value</code> is an Array, returns the associated vector. \xe2\x80\xa6CkA blinding factor used to hide the polynomial, if necessary0CmFrom a canonical expanded state, obtain the corresponding \xe2\x80\xa6CkConvenience function for constructing constant expressions.0AaCreate a constantCiConstant value (see ConstantExpr for supported constants)CbConvenience function to create a constant as Expr.BgTurns a constant value into a variable.BjCreates a variable from a constant integerAhReturns the current row.00ChEvaluate an expression as a field element against an \xe2\x80\xa6BlEvaluate an expression into a field element.10BnEvaluate an RPN expression to a field element.Bievaluate witness polynomials over domainsBnEvaluate the combined value of a joint-lookup.CiEvaluate the linear combination specifying the lookup \xe2\x80\xa61ClEvaluate the combined value of a joint-lookup, resolving \xe2\x80\xa6ChGiven the evaluations form of a polynomial, directly \xe2\x80\xa6CjReturns bit-flag for allocation counter update being a \xe2\x80\xa60CkReturns bit-flag for destination register as <code>F</code>CmReturns bit-flag for first operand register as <code>F</code>CfReturns bit-flag for allocation pointer for second \xe2\x80\xa6DhReturns bit-flag for frame pointer for second register as <code>F</code>CnReturns bit-flag for program counter update being absolute \xe2\x80\xa6CeReturns bit-flag for program counter update being \xe2\x80\xa6CnReturns bit-flag for program counter update being relative \xe2\x80\xa6CbThe features enabled for this lookup configurationBgDeserialize keypair from secret key hexAoDeserialize public key from hexBjDeserialize compressed public key from hexAoDeserialize secret key from hexCjCreates a BigUint from an hexadecimal string in big endianBbDeserialize from little-endian hexAhBuild a value from a u32BlThe evaluation f(zeta) - t(zeta) * Z_H(zeta)BoRequired evaluation for Maller\xe2\x80\x99s optimizationCnThe full SRS is the one used by the prover. Can be seen as \xe2\x80\xa6Cgcreates a set of test vectors Uses a custom seed if \xe2\x80\xa6CnFollows approach of SvdW06 to construct a \xe2\x80\x9cnear injection\xe2\x80\xa6AiHash index in the circuitCiInitialize a witness row based on layout and computed \xe2\x80\xa6DeReturns true if the <code>Value</code> is an Array. Returns false \xe2\x80\xa6ChReturns <code>true</code> if the runtime table is empty.EeReturns <code>true</code> if the lookup table is empty, <code>false</code> otherwise.CeReturns <code>true</code> if the commitment is empty.ClReturns whether the memory is empty (either length 0, or \xe2\x80\xa6CmIdentify fixed and RAMLookups with a boolean. This can be \xe2\x80\xa6AlAll tables are fixed tables.0ClNaive implementation checking if n is prime You can also \xe2\x80\xa6CnCheck if a number is prime using the list of prime numbers \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6DgReturns a <code>LegendreSymbol</code>, which indicates whether this \xe2\x80\xa6ChReturns a degree-1 variable that encodes whether the \xe2\x80\xa6CnEC variable base scalar multiplication selector polynomial \xe2\x80\xa6AkProgresses to the next row.BmProgress to the computations on the next row.11CmReturns the number of XOR rows needed for inputs of usize \xe2\x80\xa6ClA collection of utility functions and constants that can \xe2\x80\xa6CdA single lookup constraint is a vector of lookup \xe2\x80\xa6CnComputes the poseidon hash of several field elements. Uses \xe2\x80\xa6CkThis module implements the Poseidon constraint polynomials.AdMina Poseidon hasherCgThis module implements Poseidon Hash Function primitiveBcYou can import this module like \xe2\x80\xa6Cbposeidon constraint selector polynomial commitmentClOutputs the state into dense quarters of 16-bits each in \xe2\x80\xa6AmReads one value from a table.CnRegisters a new ArgumentType, associating it with a number \xe2\x80\xa6oRot commitmentsCgAssigns the witness values needed in the iota algorithmCgSelector (as expression) for the constraints of the \xe2\x80\xa6ClReturns the selector of the current step in standardized \xe2\x80\xa6BoReturns the (i,y,x,q)-th variable of ChiShiftsBBoReturns the (i,x,q)-th variable of ThetaShiftsCCaReturns the (i,y,x,q)-th variable of PiRhoShiftsECmStep counter of the total number of steps executed so far \xe2\x80\xa6CnThe ID for the table associated with this lookup. Positive \xe2\x80\xa600BdTable ID corresponding to this tableBiThe table ID corresponding to this lookup10BfSerialize random oracle input to bytesAnDeserialize keypair into bytesBaDeserialize public key into bytesBlDeserialize compressed public key into bytesBaDeserialize secret key into bytesAbSerialize to bytesBhAssign a unique ID to the lookup tables.BgConvert BigUint into PrimeField elementBdConvert to 3 limbs of LIMB_BITS eachBlConvert limbs from field elements to BigUintCkReturns the variable corresponding to a given column alias.BnA verifier for the folding/accumulation schemeCbThis module implements zk-proof batch verifier \xe2\x80\xa6CcWrites one value when <code>if_is_true</code> is 1.oXor commitmentsCnPad with zeroes and then add 3 random elements in the last \xe2\x80\xa6AgBase field element typeBiFormat: <code>bne rs1, rs2, offset</code>AbBuild WASM packageCeA data structure to store a current step of Cairo \xe2\x80\xa6ClA Cairo word for the runner. Some words are instructions \xe2\x80\xa6DfThe collection of constants required to evaluate an <code>Expr</code>.ChA trait extending CommitmentCurve for endomorphisms. \xe2\x80\xa6DiA multiplicative generator of the field. <code>Self::GENERATOR</code> \xe2\x80\xa6CmRepresents an error found when verifying a witness with a \xe2\x80\xa6Cn<code>GateWires</code> document the wiring of a gate. More \xe2\x80\xa6CfHash identifier to distinguish inside the syscalls \xe2\x80\xa6ChWitness cell assigned from an indexable variable See \xe2\x80\xa60B`Represents any valid JSON value.CkThis struct contains all that needs to be kept track of \xe2\x80\xa6BfLimb length for foreign field elementsBhA thread-safe, lazily-initialized value.BfCapability for invoking table lookups.AeNumber of Cairo flagsBgMina network (or blockchain) identifierCiBit position of the beginning of the flags in a Cairo \xe2\x80\xa6CnAll [1..136] values of possible padding lengths, the value \xe2\x80\xa6A`Public key errorAmStruct containing a RAMLookupCjThis represents the internal state of the virtual machine.0ClThe number of field elements used to represent the whole \xe2\x80\xa6AbInvalid secret keyBjA Schnorr signature for the Mina protocol.CkSkip the given number of tokens if the feature is disabled.ChHash step identifier to distinguish inside interstep \xe2\x80\xa6BfAn iterator over the variants of StepsBhFormat: <code>sb rs2, offset(rs1)</code>BhFormat: <code>sh rs2, offset(rs1)</code>BhFormat: <code>sw rs2, offset(rs1)</code>AkConverts types to a BigUintCkLayout variables mapping - these values are substituted \xe2\x80\xa60CdAbsorb an element of the base field into the sponge.ClAbsorbs a base field element. This operation is the most \xe2\x80\xa6DiAbsorbs an element of the scalar field <code>Fr</code> \xe2\x80\x94 it is done \xe2\x80\xa6EfIf the <code>Value</code> is a Number, returns the associated <code>Number</code>. \xe2\x80\xa6DgIf the <code>Value</code> is an Object, returns the associated Map. \xe2\x80\xa6Cnfunction to avoid optimizations by the compiler taken from \xe2\x80\xa6AnCurrent block of preimage dataBjReturns ceil(log2(d)) but panics if d = 0.CoCreates a <code>ScalarChallenge</code> by squeezing the sponge.CkSqueeze out a challenge in the scalar field. Implemented byiConstantsCgConstants for each witness\xe2\x80\x99 index offsets and lengthsAhConstant values required00CgAdds one KeccakConstraint to the environment if the \xe2\x80\xa6EgChecks the constraint <code>tag</code> by checking that the input <code>x</code> is \xe2\x80\xa6Cnreturns the right-hand side of the Short Weierstrass curve \xe2\x80\xa6CmTakes a dense u64 word and decomposes it into a vector of \xe2\x80\xa6CkReturns a base field digest by squeezing the underlying \xe2\x80\xa6mDomain for FpmDomain for FqChendoscalar multiplication selector polynomial commitmentCichecks if two expressions are equal, if not return an \xe2\x80\xa6CdA challenge to aggregate multiple evaluation points.CiEvaluate an expression as a field element against the \xe2\x80\xa60ClReturns bit-flag for immediate value for second register \xe2\x80\xa6DfReturns bit-flag for operation being an assert-equal as <code>F</code>CoReturns bit-flag for operation being a return as <code>F</code>DgReturns bit-flag for addition operation in right side as <code>F</code>CjReturns bit-flag for multiplication operation in right \xe2\x80\xa6BoA sponge that acts on the base field of a curveAeDeserialize from bitsClBuild a value from an expression. This method aims to be \xe2\x80\xa6DjDeserializes a <code>VerifierIndex</code> from a file, given a pointer \xe2\x80\xa6DiReturns the lookup pattern used by a <code>GateType</code> on a given \xe2\x80\xa6DiCreate a <code>Value::Array</code> by collecting an iterator of array \xe2\x80\xa6DdCreate a <code>Value::Object</code> by collecting an iterator of \xe2\x80\xa6DfReturns the lookup table associated to a <code>GateLookupTable</code>.D`Write into a <code>serde_json::Value</code> using the syntax \xe2\x80\xa6CjInitialize a witness cell based on layout and computed \xe2\x80\xa6BhIterate over the columns in the circuit.BeIterate over the instruction variants0ClReturns a variable that encodes whether the current step \xe2\x80\xa6DeReturns true if the <code>Value</code> is a Number. Returns false \xe2\x80\xa6DfReturns true if the <code>Value</code> is an Object. Returns false \xe2\x80\xa6ChReturns a degree-2 variable that encodes whether the \xe2\x80\xa6DeReturns true if the <code>Value</code> is a String. Returns false \xe2\x80\xa6B`Converts the expression in LaTeX0ClThere is an optimization in PLONK called \xe2\x80\x9clinearization\xe2\x80\xa60ChMultiplies the chunks of a polynomial with powers of \xe2\x80\xa6CnThe number of times that this lookup value should be added \xe2\x80\xa608ChOptional coefficient that can be multiplied with the \xe2\x80\xa6EdReturns <code>((x * y) &gt;&gt; 32, (x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, \xe2\x80\xa6DdReturns the <code>idx</code>-th new state expanded quarter, as a \xe2\x80\xa6ClThis function computes the next values of the allocation \xe2\x80\xa6CmReturns the numerator corresponding to this lookup in the \xe2\x80\xa6BeConverts the expression in OCaml code0DdReturns the <code>idx</code>-th old state expanded quarter, as a \xe2\x80\xa6Cgpermutation linearization poly contribution computationCbpermutation quotient poly contribution computationBf1-st Lagrange evaluated over domain.d8ClA challenge to combine polynomials. Powers of this point \xe2\x80\xa6AhThe RAM lookup argument.BaAll the registers used by the ISACgAn interpreter for the RISC-V 32IM instruction set, \xe2\x80\xa6ChAssigns the witness values needed in the pirho algorithmCkAssigns the witness values needed in the round step for \xe2\x80\xa6ChAssigns the witness values needed in the theta algorithmBeThe lookup-type selector polynomials.B`Serialize the ROInput into bytesCmYou can use this to serialize an arkworks type with serde \xe2\x80\xa6BoMina signature structure and associated helpersCeThe sponges will be used to simulate the verifier \xe2\x80\xa6DiTable IDs for the lookup values. This may be <code>None</code> if all \xe2\x80\xa60AeReturns the pad tableDkReturns 1 if <code>x</code> is 0, or 0 otherwise, storing the result in \xe2\x80\xa60BbDeserialize secret key into base58ChFlatten the column \xe2\x80\x9calias\xe2\x80\x9d into the integer-like \xe2\x80\xa6AhAlias for to_field_limbsCiConvert the random oracle input to a vector of packed \xe2\x80\xa6CcReturn a field element in hexadecimal in big endianBkCompile an expression to an RPN expression.0D`Return <code>pos</code>-th 16-bit chunk as another field elementeUtilsBlMacro to simplify mapping of layout variable0AlWrites one value to a table.ClReturns the output of an absorb sponge, which is the XOR \xe2\x80\xa6AlReturns the XOR lookup tableAbBitwise operationsCgBlock index inside the hash to enumerate preimage bytesCmAll values that can be stored in a byte (amortized table, \xe2\x80\xa6eCairo0ClA structure to store program counter, allocation pointer \xe2\x80\xa6CgCommitment round challenges (endo mapped) and their \xe2\x80\xa6AnInvalid constraint with numberChAll the names for constraints involved in the Keccak \xe2\x80\xa6CnA row accessible from a given row, corresponds to the fact \xe2\x80\xa6CgHandy re-exports A row accessible from a given row, \xe2\x80\xa6CcImplementation of the <code>EndosclMul</code> gate.CkContains the evaluation of a polynomial commitment at a \xe2\x80\xa6AnNumber of gates in this gadgetBgAn iterator over the variants of GadgetCbNumber of desired limbs for foreign field elementsBkDescribes the desired lookup configuration.ChEnum representing the two different modes of a RAMLookupCdThe maximum degree of the polynomial that can be \xe2\x80\xa6CiRepresents a curve that has a static name attached to it.CkDefine a structured reference string (i.e. SRS) for the \xe2\x80\xa6BnErrors that can arise when preparing the setupCgEnabled if the table width is at least the given numberBfEC variable base scalar multiplication0CbImplementation of the <code>VarbaseMul</code> gateAcInvalid wire columnCkAdds a given Lookup to the environment if the condition \xe2\x80\xa6Althe computed powers of alphaB`Append a 32-bit unsigned integerB`Append a 64-bit unsigned integerCnObtains the representation of some constants as a literal. \xe2\x80\xa6CnAuto clone macro - Helps make constraints more readable by \xe2\x80\xa60DgSplit a foreign field element into a vector of <code>B</code> (limb \xe2\x80\xa6ClFlagged as unsafe as it does require an additional range \xe2\x80\xa60CiOn input a vector of 16-bit dense quarters, outputs a \xe2\x80\xa6CkWhile folding, we must keep track of the challenges the \xe2\x80\xa6AhChallenges from the IOP.00DhSame as <code>prechallenges</code>, but maps scalar challenges using \xe2\x80\xa6AmCapture the trace/checkpoint.CkThis module will be used by the prover to evaluate at a \xe2\x80\xa6CjThe commitment of the polynomial being evaluated. Note \xe2\x80\xa6CkThis module implements Dlog-based polynomial commitment \xe2\x80\xa6BeCompute the x^5 of the given variableCkCreate one rotation Right now it only creates a Generic \xe2\x80\xa6DiReturns <code>x / y</code>, storing the results in <code>position</code>.AkA module to load ELF files.CbThis module implements short Weierstrass curve \xe2\x80\xa6DkExtends an AND gadget for <code>bytes</code> length. The full operation \xe2\x80\xa6CkExtend one rotation Right now it only creates a Generic \xe2\x80\xa6BnExtends the rot rows to the full witness InputCmReturns bit-flag for operation being a call as <code>F</code>Cjfinds i for i=start, start+1, \xe2\x80\xa6 s.t. f(i) is a valid \xe2\x80\xa6BiDeserialize keypair from secret key bytesBaDeserialize public key from bytesBlDeserialize compressed public key from bytesBaDeserialize secret key from bytesAfDeserialize from bytesClInitializes a new foreign element from an element in the \xe2\x80\xa6CjApply a full round of the permutation. A full round is \xe2\x80\xa6ClThis function allows us to retrieve the powers of alpha, \xe2\x80\xa6CkReturn the evaluation of the given column, over the domain.BdReturns the hash index as a variableCjThe index of the latest allocated public inputs in the \xe2\x80\xa6DkReturns a variable that encodes whether the <code>idx</code>-th byte of \xe2\x80\xa6CjCOmpute the inner product of two slices of field elements.AoConversion into vector of bytesCiTransforms the current RAMLookup into an equivalent LogupBcConvert public key into curve pointDfReturns true if the <code>Value</code> is a Boolean. Returns false \xe2\x80\xa6CmDegree-2 variable encoding whether the input is a boolean \xe2\x80\xa6CiDegree-2 variable encoding whether the first input is \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6DkThis is a polyfill of the <code>LazyLock</code> type in the std library \xe2\x80\xa6CmOptional coefficient that can be multiplied with the left \xe2\x80\xa6AnAdds a lookup to the Pad tableDiReturns <code>x % y</code>, storing the results in <code>position</code>.4BlCreate an experimental kimchi hasher contextAnCreate a legacy hasher contextCmThe next power of alpha to use the end result will be [1, \xe2\x80\xa6CnNext row in the execution trace. It is useful when we deal \xe2\x80\xa6ChNullifies the Witness and Constraint environments by \xe2\x80\xa6CmNumber of blocks to be absorbed on input a given preimage \xe2\x80\xa6DiReturns <code>x or y</code>, storing the result in <code>position</code>.0CiThis function returns a vector of field elements that \xe2\x80\xa6CiReturns a variable that encodes the bytelength of the \xe2\x80\xa6DhReturns a variable that encodes the <code>idx</code>-th chunk of the \xe2\x80\xa6AeParameter type to useBfParse a hex string into a 32-byte seedCjThis module implements Plonk prover polynomials primitive.AoExpanded block of previous stepAjProgram state for curve E1AjProgram state for curve E2fCurvesChReturns the (x)-th term of ThetaQuotientC, as a variableCaReturns the (y,x,q)-th variable of PiRhoQuotientECnAssigns the witness values needed in an absorb step (root, \xe2\x80\xa6CnAssigns the witness values needed in a sponge step (absorb \xe2\x80\xa6EgReturn the result of shifting <code>x</code> by <code>by</code>, storing the result \xe2\x80\xa60CaReturns the (i,y,x,q)-th variable of ChiShiftsSumAlpermutation commitment arrayBdReturns the step index as a variableAfReturns the byte tableDfReturns the lookup table associated to a <code>GateLookupTable</code>.BjTarget directory for cargo build artifactsCgConverts a vector of bits in little endian to a BigUintBdSerialize field element to a BigUintCiObtains the big integer representation of the foreign \xe2\x80\xa6BdSerialization to random oracle inputAePrecomputed 2^pad_lenCfReturns a variable that encodes the value 2^pad_lengthCkThis module implements short Weierstrass curve variable \xe2\x80\xa6AbThis enforces thatDiEvaluation at <code>zeta . omega</code>, the product of the challenge \xe2\x80\xa6BhAn iterator over the variants of AbsorbsCgThe argument environment is used to specify how the \xe2\x80\xa6CdThis trait contains helper functions for boolean \xe2\x80\xa6CbThe number of constraints created by the argument.BoNumber of constraints produced by the argument.BkNumber of constraints produced by the gate.1CdThis data structure stores the memory of the programAkA single gate in a circuit.DgEnvironment capability similar to <code>ColAccessCap</code> but for \xe2\x80\xa6CgAbstract columns (or variables of our multi-variate \xe2\x80\xa6ClColumn aliases used by the Keccak circuit. The number of \xe2\x80\xa6BcComplete EC addition in Affine formDcImplementation of the <code>CompleteAdd</code> gate It uses the \xe2\x80\xa61CkDomain size for the MSM project, equal to the BN254 SRS \xe2\x80\xa6CnThe collection of polynomials (all in evaluation form) and \xe2\x80\xa6CiPolynomial represented by its evaluations over a domain DCkThe feature flags that can be used to enable or disable \xe2\x80\xa6CcA list of instruction/gadget implemented in the \xe2\x80\xa6ClThis trait includes functionalities needed to obtain the \xe2\x80\xa6CjA spec for checking that the given vector belongs to a \xe2\x80\xa6AoFormat: <code>jal rd,imm</code>BnThe number of columns the Keccak circuit uses.CkRepresents additional information that a curve needs in \xe2\x80\xa6CgRepresents an error found when computing the lookup \xe2\x80\xa6CeRepresents the proof of the lookup argument It is \xe2\x80\xa6CjA table of values that can be used for a lookup, along \xe2\x80\xa60CjThe lookup table struct based on LogupTable for the VM \xe2\x80\xa6CmRepresents one line of the execution trace of the virtual \xe2\x80\xa6BdAll the witness columns used in MIPSBhOperation code is a jump or an incrementBeFormat: <code>ori rd, rs1, imm</code>AhThe permutation argumentCkFor efficiency of evaluation, we compile expressions to \xe2\x80\xa6BkErrors that can arise when creating a proof0AlThe index used by the proverCnThe proof that the prover creates from a ProverIndex and a \xe2\x80\xa6AaPublic key errorsBhHelper to generate random field elementskRange check0CnDual-column table of all values in the range [0, 2^16) and \xe2\x80\xa6BnThe number of columns the Sponge circuit uses.CjThe order in a row in which we store states before and \xe2\x80\xa6AiScalar field element typemKeypair errorBeFormat: <code>slt rd, rs1, rs2</code>BhAn iterator over the variants of SpongesDiLet <code>N</code> be the size of the multiplicative group defined by \xe2\x80\xa6BcTwo to the power of the limb lengthBlErrors that can arise when verifying a proofCmWitness cell interface. By default, the witness cell is a \xe2\x80\xa6AdInvalid x-coordinateDkReturns <code>x + y</code> and the overflow bit, storing the results in \xe2\x80\xa60CmComputes the aggregation polynomial for maximum n lookups \xe2\x80\xa6DiReturns <code>x or y</code>, storing the result in <code>position</code>.0AcAppend a single bitB`Assert that the variable is zeroAoAsserts that the value is zero.CmConjunction of the bits of two BigUint inputs for a given \xe2\x80\xa6CkNegate the bits of a Self input If it provides a larger \xe2\x80\xa6BaBitwise XOR of two BigUint inputsBeReturns the block index as a variableDjReturns a variable that encodes the <code>idx</code>-th block of bytes \xe2\x80\xa6EaCheck that the witness values in <code>x</code> and <code>y</code> are equal; \xe2\x80\xa60CkChunk of consecutive coefficients in an interval [from, to)BbThe coefficient column polynomialsAfCombine where x1 = oneCdAll the polynomial commitments required in the proofCjThis module implements Plonk circuit constraint primitive.AnA number of useful constraintsCiReturns the set of constraints required to prove this \xe2\x80\xa6C`Specifies the lookup constraints as expressions.CfReturns the constraints related to the runtime tables.AnAn indexed set of constraints.CnA list of constraints, which are multi-variate polynomials \xe2\x80\xa6CiThis module contains the constraints for one Keccak step.BiConstraints that are added to the circuitCfCreates all 879 constraints/checks to the environment:CbCurrent processing row. Used to build the witness.AeDeclare traces group.BoReturns the (x,q)-th variable of ThetaDenseRotCCaReturns the (y,x,q)-th variable of PiRhoDenseRotEBmDeserialize a <code>ROInput</code> from bytesCiYou can use this to deserialize an arkworks type with \xe2\x80\xa6CeReturn the domain size of the individual evaluations.CnDegree-2 variable encoding whether at least one of the two \xe2\x80\xa6CmThis module contains the definition and implementation of \xe2\x80\xa6ClCompute the polynomial corresponding to this expression, \xe2\x80\xa6000CiThis adds a few utility functions for the Evaluations \xe2\x80\xa6CkContains an evaluation table. For instance, for vanilla \xe2\x80\xa6CkA list of evaluations, each supposed to correspond to a \xe2\x80\xa6CiExpands a u64 word into a vector of 4 sparse u64 quartersBaFetch an input of the applicationDkReturns a vector of pad bytes flags as variables, with <code>idx</code> \xe2\x80\xa6CnThe flat vector is a vector of fixed-size elements that we \xe2\x80\xa6ltest helpersBeDeserialize base58 encoded secret keyCkThis function returns the composed sparse variable from \xe2\x80\xa6ChA GateVector: this is used to represent a list of gates.BaGenerate the <code>witness</code>DbGenerates the <code>witness_curr</code> values for a series of \xe2\x80\xa6ClObtain the Mina address corresponding to the keypair\xe2\x80\x99s \xe2\x80\xa6AmGet size of the public memoryDhInstantiates the ranges with an actual field element <code>alpha</code>.CmThis module contains the implementation of the IVC scheme \xe2\x80\xa6CkThis module defines the Keccak interpreter in charge of \xe2\x80\xa6CkThis module implement an interpreter for the RISCV32 IM \xe2\x80\xa6BlConvert secret key into scalar field elementChChecks whether a value is in a table and returns the \xe2\x80\xa6CjReturns None if the table is runtime (and thus mapping \xe2\x80\xa6CiImplements a tool to visualize a circuit as an HTML page.AoAdds a lookup to the Byte tableBkInformation about the specific lookups used0BgAdds a lookup to the RangeCheck16 tableCkSame as SRS::mask except that you can pass the blinders \xe2\x80\xa6DgThe maximum length of an element of <code>kinds</code>. This can be \xe2\x80\xa60kMina hasherkMina signerClReturns a variable that encodes whether the current step \xe2\x80\xa6DjReturns <code>x nor y</code>, storing the result in <code>position</code>.0BhOutput file path, use \xe2\x80\x9c-\xe2\x80\x9d for stdoutBnpermutation aggregation polynomial computationCjThis module implements permutation constraint polynomials.CmThe permutation module contains the function implementing \xe2\x80\xa6ClLooks up a value by a JSON Pointer and returns a mutable \xe2\x80\xa6DhSet the memory value at address <code>addr</code> to <code>value</code>.0Dfgenerates a vector of <code>length</code> field elements using the \xe2\x80\xa6BcRange check pattern lookup selectorAaRange check tableAgRange check gate moduleBcReads value from a column position.C`Returns the (x,q)-th variable of ThetaRemainderCCbReturns the (y,x,q)-th variable of PiRhoRemainderECnOptional coefficient that can be multiplied with the right \xe2\x80\xa6CcAssigns the witness values needed in a squeeze stepEgReturn the result of shifting <code>x</code> by <code>by</code>, storing the result \xe2\x80\xa60DiGiven a variable <code>x</code>, this function extends it to a signed \xe2\x80\xa60DaReturns the <code>idx</code>-th byte of the sponge, as a variableBmStandardizes a Keccak step to a common opcodeDiReturns <code>x + y</code> and the underflow bit, storing the results \xe2\x80\xa60AgReturns the reset tableBffixed tables pre-existing the protocolAeTake captured traces.AbAlias for to_limbsm2^{LIMB_BITS}0e2^{B}CjThis function updates the next step of the environment \xe2\x80\xa6CeReturns the 20 variables corresponding to ThetaDenseCCfReturns the 100 variables corresponding to PiRhoDenseECeEnvironment for the witness (includes multiplicities)DjReturns <code>x xor y</code>, storing the result in <code>position</code>.0BfFormat: <code>addi rd, rs1, imm</code>BfFormat: <code>andi rd, rs1, imm</code>CkArgument environment data for constraints of field elementsCjA constraint type represents a polynomial that will be \xe2\x80\xa6CgThis trait contains helper functions for arithmetic \xe2\x80\xa6CgA structure to store auxiliary variables throughout \xe2\x80\xa6CjThis struct stores the needed information to run a programA`Handy re-exportsCmEnvironment capability for accessing and reading columns. \xe2\x80\xa6B`Witness cell with constant value0CnDefine the constant terms an expression can use. It can be \xe2\x80\xa6CeWitness cell copied from bits of another witness cell0CmThis trait can be implemented on any type that implements \xe2\x80\xa6CdFlags for optional features in the constraint systemClField element helpers Unless otherwise stated everything \xe2\x80\xa6CbA trait that defines parameters for a prime field.mKeypair errorCaBitsize of the foreign field limb representation.CmThis trait contains helper functions for the lookups used \xe2\x80\xa6CkRepresents a witness of one instance of the lookup argumentBfM extension instructions Following \xe2\x80\xa6DfThe number of bits needed to represent the <code>Self::MODULUS</code>.CbA runtime table. Runtime tables must match the \xe2\x80\xa6CaThe minimal number of columns required for the VMAcWidth of the spongeAfInvalid secret key hexCnLook up a single value in a lookup table. The value may be \xe2\x80\xa6CgSingle-column table of 2^16 entries with the sparse \xe2\x80\xa6CdSub environment with a lens that is mapping columns.CjSub environment with a lens that is mapping lookup tables.CkWitness cell assigned from a variable See Variables for \xe2\x80\xa60BhEvaluations of the wires and permutationCbThe table ID associated with the XOR lookup table.BfFormat: <code>xori rd, rs1, imm</code>CjAbsorb the last committed program state in the correct \xe2\x80\xa60DhAdd the monomial <code>coeff * x_1^{e_1} * ... * x_N^{e_N}</code> to thelAppend bytesAkAppend a base field elementDiIf the <code>Value</code> is an Array, returns the associated mutable \xe2\x80\xa6BgAssert that the two variables are equalEaAssert that the values <code>x</code> and <code>y</code> are equal, and add a \xe2\x80\xa60CiThis function verifies the batch of zk-proofs proofs: \xe2\x80\xa6CmSqueeze out a base field challenge. This operation is the \xe2\x80\xa6AlForeign field addition gate.AlForeign field multiplicationAagate coefficientsAgcoefficient polynomialsClCommit to the program state and updating the environment \xe2\x80\xa60Aglo + mi * 2^{LIMB_BITS}CcThis module implements a complete EC addition gate.DiCreates a FFAdd witness (including <code>ForeignFieldAdd</code> rows, \xe2\x80\xa6ChCreate a multi range check witness from three 88-bit \xe2\x80\xa6A`Produces a proofCeCreates a Rot64 gadget to rotate a word It will need:CiStandard nonce derivation using direct byte serializationBeThe domain parameter used for hashingCmA placeholder value that is known to appear in the lookup \xe2\x80\xa6C`Returns the (x,q)-th variable of ThetaExpandRotCCbReturns the (y,x,q)-th variable of PiRhoExpandRotECiOn input a 200-byte vector, generates a vector of 100 \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6DgFetch the memory value at address <code>addr</code> and store it in \xe2\x80\xa60CkVectors We implement a custom type for field vectors in \xe2\x80\xa6CeThe content of the first column of the runtime table.CcAll fixed lookup tables values, indexed by their IDBhDeserialize Mina address into public keyClDeserialize Mina address into compressed public key (via \xe2\x80\xa6AhDeserialize from BigUintCiInitializes a new foreign element from a big unsigned \xe2\x80\xa6Amgeneric gate commitment arrayAoThe path of the serialized SRS.CmObtains a Test SRS for a specific curve from disk. Panics \xe2\x80\xa6AlConverts an i32 into a FieldCdSerialize public key into corresponding Mina addressCkSerialize compressed public key into corresponding Mina \xe2\x80\xa6CiPlaceholder dummy value for the kimchi configuration, \xe2\x80\xa6CmThe Marlin_plonk_stubs crate exports some functionalities \xe2\x80\xa6BhAdds a lookup to the AtMost4Lookup table0BeAdds a lookup to the ByteLookup table0CfWhich lookup-patterns should be applied on which rows.0CmThis prover takes one Public Input and one Public Output. \xe2\x80\xa6CmLookup \xe2\x80\x9cread\xe2\x80\x9d requests per table. Each element of the \xe2\x80\xa6BbAggregated lookups or \xe2\x80\x9creads\xe2\x80\x9d.B`Adds a lookup to the Reset tableCnReads a Lookup containing the input of a step and writes a \xe2\x80\xa6mLookup tablesAhGet the AND lookup tableCaGet the foreign field multiplication lookup tableAhGet the xor lookup tableAhGet the rot lookup tableB`Get the range check lookup tableBeevaluation of lookup table polynomialCnThis function uses a cryptographic hash function (based on \xe2\x80\xa6DiReturns <code>x % y</code>, storing the results in <code>position</code>.ChReturns a degree-1 variable that encodes whether the \xe2\x80\xa6ClReturns a variable that encodes whether the current step \xe2\x80\xa6Cievaluation of the elliptic curve variable base scalar \xe2\x80\xa6AiSets <code>a = -a</code>.0ChOptional coefficient that can be multiplied with the \xe2\x80\xa60BkPrecomputed suffixes for the padding blocksa?DdThis module implements the prover index as <code>ProverIndex</code>.Ampublic polynomial evaluationsCbThe public input used in the creation of the proofA`RangeCheck0 gateA`RangeCheck1 gateDaRange checks with 1 lookup to the AtMost4Lookup table 0 &lt;= \xe2\x80\xa6CnRange checks with 2 lookups to the ByteLookup table that a \xe2\x80\xa60Bievaluation of the Rot selector polynomialAmVersion of <code>rustc</code>CdInside the circuit, we have a specialized scalar \xe2\x80\xa6CaReturns the 200 bytes of the sponge, as variablesCmReturns the last 32 terms that are added to the new block \xe2\x80\xa6AhReturns the sparse tableAa2^{2 * LIMB_BITS}0i2^{2 * B}Aa2^{3 * LIMB_BITS}i2^{3 * B}BhMacro to simplify creation of layout map0CeReturns the 400 variables corresponding to ChiShiftsBCfReturns the 80 variables corresponding to ThetaShiftsCCgReturns the 400 variables corresponding to PiRhoShiftsECiSRS to be used by the verifier. Can be seen as the \xe2\x80\x9c\xe2\x80\xa6CbVerify the <code>GateType::VarBaseMul</code>(TODO)AkWitness cell on current rowBhSame as witness but for the current row.AhWitness cell on next rowBeSame as witness but for the next row.CnReturn the corresponding expression regarding the selected \xe2\x80\xa6CkSet the value of the variable at the given position for \xe2\x80\xa6CiWrites an integer value to a column of the Keccak witnessBievaluation of the Xor selector polynomialCkThe type of constraints that this will produce. This is \xe2\x80\xa6AfInvalid address base58AfInvalid address lengthCjYou can create a new AdjacentPairs from an iterator using:CmValues from 0 to 4 to check the number of bytes read from \xe2\x80\xa6ChA datatype expressing a generalized column, but with \xe2\x80\xa6CaWitness cell copied from another cell and shifted0ClThe result of performing an endoscaling: the accumulated \xe2\x80\xa6CeGate for computing the scalar corresponding to an \xe2\x80\xa60CkA trait that defines parameters for a field that can be \xe2\x80\xa6CkConstant column that is /always/ fixed for a given circuit.AaG_GENERATOR_X = 10AdG1_GENERATOR_Y = \xe2\x80\xa60CkCapability for computing arithmetic functions and enforcingBmA challenge used to columns of a lookup tableCnThe witness columns used by the Keccak circuit. The Keccak \xe2\x80\xa6DjA \xe2\x80\x9clinearization\xe2\x80\x9d, which is linear combination with <code>E</code> \xe2\x80\xa6CbA position in the circuit relative to a given row.CfContains variables needed for lookup in the prover \xe2\x80\xa6C`The table ID associated with a particular lookupAoTrait for lookup table variantsCfRepresents a witness of one instance of the lookup \xe2\x80\xa60ClEnabled if the number of lookups per row is at least the \xe2\x80\xa6Abpoint not on curveAkInvalid y-coordinate parityBiThe result of running the oracle protocolBlThe maximum number of padding bytes involvedCkThe number of bytes that can be processed by the Keccak \xe2\x80\xa6CiThis enum provides aliases for the registers. This is \xe2\x80\xa6DfAn equation of the form <code>(curr | next)[i] = round(curr[j])</code>CnWe store several different types of SRS objects. This enum \xe2\x80\xa6AnSyscalls communication channelBkNumber of words that fit in the hash digestCmLook up the value in the table with ID given by the value \xe2\x80\xa6DcAccess the memory address <code>addr</code>, adding constraints \xe2\x80\xa60BmThe aggregation polynomial in different formsCnAllocate a new abstract variable for the current step. The \xe2\x80\xa60CgAppend a scalar field element by converting it to bits.DjIf the <code>Value</code> is an Object, returns the associated mutable \xe2\x80\xa6B`Function used to map assertions.D`The function that maps the argument of <code>assert_zero</code>.ChCreate a new field element from this field elements bitsCmReturns the witness of an execution of a Cairo program in \xe2\x80\xa6CdReturns the field element that represents a positionF`Check that the witness value <code>x</code> is a boolean (<code>0</code> or <code>1</code>); \xe2\x80\xa6DiCheck that the witness value in <code>assert_equals_zero</code> is 0; \xe2\x80\xa60ClThe description of the program, in terms of gadgets. For \xe2\x80\xa6CkGet vector of foreign field multiplication circuit gate \xe2\x80\xa6BlGet vector of range check circuit gate typesAkcoefficients over domain d8CeDefines the domain over which the column is evaluatedDdCombine the polynomials using a scalar (<code>polyscale</code>), \xe2\x80\xa6DjSame as <code>combine_table_entry</code>, but for an entire table. The \xe2\x80\xa6ClCommit to a polynomial, with custom blinding factors. It \xe2\x80\xa6BoComposes the 91-bit carry1 value from its partsClPerform integer bound addition for all limbs x\xe2\x80\x99 = x + f\xe2\x80\xa6BhConfiguration for the lookup constraint.CnConnects a generic gate cell with zeros to a given row for \xe2\x80\xa6Bf0-th Lagrange evaluated over domain.d4Bf0-th Lagrange evaluated over domain.d8CiConstrains 200 checks of the chi algorithm in round stepsBlCreate an experimental kimchi hasher contextClCreate an experimental kimchi signer context with domain \xe2\x80\xa6AnCreate a legacy hasher contextCiCreate a legacy signer context with domain parameters \xe2\x80\xa6CkUse deterministic output for regression testing (stable \xe2\x80\xa6CoReturns <code>(x / y, x % y)</code>, storing the results in \xe2\x80\xa6CnGenerate unique domain string of length <code>&lt;= 20</code>.Chevaluation of the endoscalar multiplication selector \xe2\x80\xa6CmExtend an existing witness with a single-range-check gate \xe2\x80\xa6Akflags for optional featuresBnUseful helper methods to extend ark_ff::Field.CkDescribes helpers for foreign field arithmetics Generic \xe2\x80\xa6CjThis function returns the composed variable from dense \xe2\x80\xa6EfBuild the univariate polynomial <code>x_i</code> from the variable <code>i</code>. \xe2\x80\xa6CeObtains an SRS for a specific curve from disk, or \xe2\x80\xa6CmReturn the constants parameters that the expression might \xe2\x80\xa6CkReturns a range of exponents, for a given ArgumentType, \xe2\x80\xa6AmGenerate the nth prime numberCeInitialize state, hash input and obtain result outputCnReturns a slice of the input variables of the current step \xe2\x80\xa6CeIterate over the columns in the circuit, in parallel.BiThis module implements the linearization.ChThe symbolic linearization of our circuit, which can \xe2\x80\xa6AeLinearization helpersBmAdds a lookup to the RangeCheck16Lookup table0Bgevaluation of lookup sorted polynomialsB`Adds a lookup to the Shift tableCcAggregated \xe2\x80\x9cwrite\xe2\x80\x9d lookups, for runtime tables.BhCreate a new test rng with a random seedBbmaximal size of polynomial section0CfThe maximum polynomial degree that can be committed to0CgThis crate provides a generic implementation of the \xe2\x80\xa6EhReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.EeReturns <code>(x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, storing the results in \xe2\x80\xa6Bmscalar multiplication selector over domain d8AaIPA opening proofCgOn input a length, returns the smallest multiple of \xe2\x80\xa6ChComputes a log-sized vector of scalar challenges for \xe2\x80\xa6EcSet the general purpose register with index <code>idx</code> to <code>value</code>.0CiRange checks with 2 lookups to the RangeCheck16Lookup \xe2\x80\xa60CgReturn the corresponding variable at the given positionB`Rot gate selector over domain d8CkGiven a Poseidon round from 0 to 4 (inclusive), returns \xe2\x80\xa6BnThe evaluations of the optional runtime table.mRuntime tableCiThis adds a few utility functions for serializing and \xe2\x80\xa6CjSets the flag columns related to padding flags such as \xe2\x80\xa6Dh<code>impl_shared_rwlock</code> implements an OCaml custom type that \xe2\x80\xa6AcField size in bytesCfProvides the sponge params to be used with this curve.0DjReturns the <code>idx</code>-th term of the shifts of the sponge, as a \xe2\x80\xa6E`Sets <code>self</code> to be the square root of <code>self</code>, if it exists.BdClean up old traces and start fresh.Adthe fp sponge paramsAkthe legacy fp sponge paramsAdthe fq sponge paramsAkthe legacy fq sponge paramsCjAssign a unique ID to the lookup tables, as an expression.CiGiven a linearization and an environment, compute the \xe2\x80\xa60B`Xor gate selector over domain d8AgInvalid address versionAcHelpers for BigUintBiFormat: <code>blt rs1, rs2, offset</code>AbDisconnected wiresBaTrack external check witness dataCkRepresents a foreign field element Represents a foreign \xe2\x80\xa6CnNumber of coefficients used by a single generic gate Three \xe2\x80\xa6BiDesired output length of the hash in bitsClAn abstract interpreter that provides some functionality \xe2\x80\xa6CaFlags for each of the hard-coded lookup patterns.BeLookup tables used in the MSM projectCeAll of the possible lookup table IDs used in the zkVMClMaximum number of memory accesses per instruction (based \xe2\x80\xa60CnMaximum number of register accesses per instruction (based \xe2\x80\xa60ChThe padding suffix of 1088 bits is stored as 5 field \xe2\x80\xa6nNumber of rowsAhInvalid secret key bytesDbA clone of the <code>PairingSRS</code> that is serialized in a \xe2\x80\xa6ChAdd a constraint to the proof system, asserting that \xe2\x80\xa60AhTrack a limb-range-checkDdAdds offset if the column is <code>Relation</code>. Fails otherwise.CjThis module hosts the AdjacentPairs type, which can be \xe2\x80\xa6BbAppend another random oracle inputCjhelper to convert array to tuple (OCaml doesn\xe2\x80\x99t have \xe2\x80\xa6DiAssert that the value <code>x</code> is boolean, and add a constraint \xe2\x80\xa60DiAssert that the value <code>assert_equals_zero</code> is 0, and add a \xe2\x80\xa60c2^tCiMultiplies each blinding chunk of f with powers of zeta^nCnSimulate an interaction with the verifier by requesting to \xe2\x80\xa60CiCompute the coefficient \xce\xbb used in the elliptic curve \xe2\x80\xa6CiCompute the output of the application on the previous \xe2\x80\xa6C`Creates a variable from a constant field elementChConstrains 4 checks of the iota algorithm in round stepsCkThe constraints given as multivariate polynomials using \xe2\x80\xa6AhCreate a generic circuitCmThis allows you to create two generic gates that will fit \xe2\x80\xa6Caendoscalar multiplication selector over domain d8DiImplementation of the <code>EndomulScalar</code> gate for the endomul \xe2\x80\xa6CnFetch the value of the general purpose register with index \xe2\x80\xa60BlReturns a vector containing all fixed tablesBnReturn the challenges, coined by the verifier.AiGet the next prime numberCnReturn true if the table has an entry (row) containing all \xe2\x80\xa6ClInitial state of the sponge, containing circuit specific \xe2\x80\xa6DjReturns true if the polynomial is homogeneous (of degree <code>D</code>\xe2\x80\xa6CbReturn true if the multi-variate polynomial is \xe2\x80\xa6CiThe challenge joint_combiner which is used to combine \xe2\x80\xa6CiThe joint combiner used to join the columns of lookup \xe2\x80\xa6BdThe combiner used for vector lookupsCkSerialize the given data structure as JSON into the I/O \xe2\x80\xa6BnCommitments to Lagrange bases, per domain size0BlAdds the 601 lookups required for the spongeCmReturns the maximum number of values that are used in any \xe2\x80\xa6CnThe maximum joint size of any joint lookup in a constraint \xe2\x80\xa60CjThe multiplicities of each lookup entry. Should not be \xe2\x80\xa6nmultiplicitiesCjReturns a slice of the output variables of the current \xe2\x80\xa6CnRuntime tables are tables (or arrays) that can be produced \xe2\x80\xa6DdOptional runtime tables, listed as tuples <code>(length, id)</code>.CbCommitments to the selectors used by both circuitsClUpdates the witness corresponding to the round value in [\xe2\x80\xa6DlReturns 1 if <code>x &lt; y</code> as unsigned integers, or 0 otherwise, \xe2\x80\xa60BoConvert to 3 PrimeField limbs of LIMB_BITS eachBkConvert limbs from BigUint to field elementCjhelper to convert tuple to array (OCaml doesn\xe2\x80\x99t have \xe2\x80\xa6CgReturns the 5 variables corresponding to ThetaQuotientCCiReturns the 100 variables corresponding to PiRhoQuotientECgReturns the 400 variables corresponding to ChiShiftsSumDhThis module implements the verifier index as <code>VerifierIndex</code>.EeProduces the <code>VerifierIndex</code> from the prover\xe2\x80\x99s <code>ProverIndex</code>.CeThe verifier index corresponding to this prover indexBiThe VerifierIndex associated to the proofBeVerify the <code>EndoMul</code> gate.Clverifies that the generic gate constraints are solved by \xe2\x80\xa6CjFunction to verify the generic polynomials with a witness.BjVerify the witness against the constraintsAhInvalid address checksumAlWitness data for an argumentCkRepresents additional information that a curve needs in \xe2\x80\xa6A`Handy re-exports0ChA useful trait extending AffineRepr for commitments. \xe2\x80\xa6BjPolynomial represented by its coefficientsChThe domain parameter trait is used during hashing to \xe2\x80\xa6CjColumns related to dynamic selectors to indicate gate typeCaImplementation of the foreign field addition gateCmThis gate operates on the Curr and Next rowsIt uses copy, \xe2\x80\xa6CnEnumerates the different \xe2\x80\x98fixed\xe2\x80\x99 lookup tables used by \xe2\x80\xa6CnThe different type of computation that are possible with a \xe2\x80\xa6BjDesired output length of the hash in bytesBgA public gate was incorrectly connectedClAn indexed relation is a structure that contains all the \xe2\x80\xa6BlAn iterator over the variants of Instruction0CjA spec for checking that the given vector belongs to a \xe2\x80\xa6A`Lookup selectorsCkCapability for reading and moving forward in a multirow \xe2\x80\xa6CjThe number of columns used for relation witness in the \xe2\x80\xa6CcThe number of witness columns used to store the \xe2\x80\xa6CmThe number of bits that must be shaved from the beginning \xe2\x80\xa6A`Number of roundsCcThe number of sparse round constants used per roundCmFor each round, the tuple (row, round) its state permutes \xe2\x80\xa6ChUse this type at setup time, to list all the runtime \xe2\x80\xa6CjTotal number of bytes for the header of the serialized \xe2\x80\xa6ClA challenge which is used as a scalar on a group element \xe2\x80\xa6AiInvalid base58 secret keyAiInvalid secrey key lengthChThe interface for a field that supports an efficient \xe2\x80\xa6CbAbsorbs a slice of field elements into the sponge.DkAccess the general purpose register with index <code>idx</code>, adding \xe2\x80\xa60AcTrack a bound checkBdAppend a <code>Hashable</code> inputCjThis module provides a set of functions to perform bit \xe2\x80\xa6BaCompute the following constraint:CbConstrains 136 checks of correctness of mode flagsCkConstrains 150 checks of the pirho algorithm in round stepsBdConstrains 389 checks of round stepsCjConstrains 35 checks of the theta algorithm in round stepsCkEnvironment for the constraints (includes lookups). The \xe2\x80\xa6ChThis function creates SRS instance for circuits with \xe2\x80\xa6CgDouble the elliptic curve point given by the affine \xe2\x80\xa600Dh<code>eval_polynomial(coeffs, x)</code> evaluates a polynomial given \xe2\x80\xa6DgThe polynomial that evaluates to each of <code>evals</code> for the \xe2\x80\xa6BmThis function evaluates polynomial in chunks.CiFill in a witness created via <code>create_circuit</code>DiFixed values for selector columns. <code>fixed_selectors[i][j]</code> \xe2\x80\xa6ChFixed selectors. These are \xe2\x80\x9cpredefined\xe2\x80\x9d with the \xe2\x80\xa6AnCreate keypair from secret keyBcCreate public key from a secret keyBnCreate compressed public key from a secret keyBgThere are 32 general purpose registers.ClGet all relevant constraints generated by the constraint \xe2\x80\xa6CgReturn the constraints for the current instruction, \xe2\x80\xa60ClReturn only the first chunk Getting this single value is \xe2\x80\xa6AlGeneric SRS getter function.CnInterpret an I-type instruction. The encoding of an I-type \xe2\x80\xa6CnInterpret an M-type instruction. The encoding of an M-type \xe2\x80\xa6CnInterpret an R-type instruction. The encoding of an R-type \xe2\x80\xa6CnInterpret an S-type instruction. The encoding of an S-type \xe2\x80\xa6CnInterpret an U-type instruction. The encoding of an U-type \xe2\x80\xa6BmConvert public key into compressed public keyoLookup featuresCjModify the monomial in the polynomial to the new value \xe2\x80\xa6BgGet the modulus as <code>BigUint</code>CkReturns the 136 flags indicating which bytes of the new \xe2\x80\xa6CcThe mapping between powers of alpha and constraints0kprecomputesCjClone of kimchi/precomputed_srs.rs but for MSM project \xe2\x80\xa6CkTo prover and verify proofs you need a Structured ReferenceBkPreimage oracle interface used by the zkVM.CfSet up the number of previous challenges, used for \xe2\x80\xa6Cknumber of previous evaluation challenges, for recursive \xe2\x80\xa6CmThe challenges underlying the optional polynomials folded \xe2\x80\xa61BhRead value from a (row,column) position.00CiReturns the 4 expanded quarters that encode the round \xe2\x80\xa6CnUpdates and any other sponge flag depending on the kind of \xe2\x80\xa6AkReturns the at most 4 tableChReturns the 20 variables corresponding to ThetaDenseRotCCiReturns the 100 variables corresponding to PiRhoDenseRotECiReturns the 20 variables corresponding to ThetaRemainderCCjReturns the 100 variables corresponding to PiRhoRemainderEBlChecks if a witness verifies a poseidon gateCbBuild kimchi-stubs with optional CPU optimisationsCmThis structure stores all the needed information relative \xe2\x80\xa6A`Handy re-exportsjGate errorCfCompressed public keys consist of x-coordinate and \xe2\x80\xa6CjA direct field access capability modelling an abstract \xe2\x80\xa6CkDummy lookup table. For the cases when you don\xe2\x80\x99t need \xe2\x80\xa6CnEnumerates the different \xe2\x80\x98fixed\xe2\x80\x99 lookup tables used by \xe2\x80\xa6BmAn iterator over the variants of IInstructionBoA concrete value or representation of a lookup.AlInput/Output of Keccak stepsBhFormat: <code>lbu rd, offset(rs1)</code>BhFormat: <code>lhu rd, offset(rs1)</code>ChThe fixed tables. The parameter is considered to the \xe2\x80\xa6DgPartial sums. This corresponds to the <code>h_i</code>. It is first \xe2\x80\xa6AhLength of Mina addressesAaSecret key lengthBmAn iterator over the variants of MInstructionBgEvaluations of a polynomial at 2 pointsCoPolynomial evaluations contained in a <code>ProverProof</code>.BmAn iterator over the variants of RInstructionClUsed by the accumulation protocol (folding) to perform a \xe2\x80\xa6BeThe specification of a runtime table.BmAn iterator over the variants of SInstructionAjInvalid secret key versionDeSame as <code>SerdeAs</code> but using unchecked and uncompressed \xe2\x80\xa6BeFormat: <code>sll rd, rs1, rs2</code>BmAn iterator over the variants of UInstructionCnWitness cell assigned from bits of a variable See Variables\xe2\x80\xa60AjInvalid x-coordinate bytesAbPoint not on curveFcGiven arrays of curve points <code>v0</code> and <code>v1</code> do <code>v0[i] += v1[i]</code> \xe2\x80\xa6CnThis module defines the particular form of the expressions \xe2\x80\xa6CnThis function returns a degree-2 variable that is computed \xe2\x80\xa6CjHelper to quickly test if a witness satisfies a constraintCkMultiplies each commitment chunk of f with powers of zeta^nAfCombine where x1 = oneBgConstrains 332 checks of absorb spongesBeConstrains 354 checks of sponge stepsBaGet the expresion of constraints.CjThis function constructs prover\xe2\x80\x99s recursive zk-proof \xe2\x80\xa6CmThis adds a few utility functions for the DensePolynomial \xe2\x80\xa6AlThe endomorphism coefficientCbHelper to access endomorphism coefficient constantChGiven the evaluations form of a polynomial, directly \xe2\x80\xa6Dj<code>generate_witness(row, params, witness_cols, input)</code> uses a \xe2\x80\xa6Aegeneric gate selectorBmevaluation of the generic selector polynomialDmReturn the coefficients <code>a</code> and <code>b</code> of the equation \xe2\x80\xa6DfEvaluate the polynomial at the vector point <code>x</code> and the \xe2\x80\xa6CdThe relation this witness environment is related to.ChInterpret an SB-type instruction. The encoding of an \xe2\x80\xa6ChInterpret an UJ-type instruction. The encoding of an \xe2\x80\xa6CjCheck if the points given by (x1, y1) and (x2, y2) are \xe2\x80\xa6CnLookup selectors: For each kind of lookup-pattern, we have \xe2\x80\xa6EdReturns <code>((x * y) &gt;&gt; 32, (x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, \xe2\x80\xa6DkPerforms a multi-scalar multiplication between scalars <code>elm</code> \xe2\x80\xa6ClProvides the coefficient for the curve endomorphism over \xe2\x80\xa60EfSet the general purpose register with index <code>idx</code> to <code>value</code> \xe2\x80\xa60CkAn optional runtime table selector. It is 0 everywhere, \xe2\x80\xa6CdThe evaluations of the optional runtime selector \xe2\x80\xa6Dg<code>impl_shared_reference1</code> implements an OCaml custom type \xe2\x80\xa6ClConvert to 2 limbs of 2 * LIMB_BITS each. The compressed \xe2\x80\xa6B`Compose field limbs into BigUintCiReturns the 20 variables corresponding to ThetaExpandRotCCjReturns the 100 variables corresponding to PiRhoExpandRotEBaFormat: <code>auipc rd,imm</code>ChA commitment to a polynomial with some blinding factors.CeThe number of bytes used as a capacity in the sponge.AoField element helpers for CairoA`Handy re-exportsChThis struct contains multiple chunk polynomials with \xe2\x80\xa6kGate resultCnThe collection of polynomials (all in evaluation form) and \xe2\x80\xa60CmThe polynomials representing columns, in evaluation form. \xe2\x80\xa6BjSome connected wires have different valuesAnPrimeField array compact limbsB`PrimeField array compose BigUintAcField helpers errorCnTrait that creates all the fixed lookup tables used in the \xe2\x80\xa6CgNumber of generic of registers by a single generic gateAbInvalid constraintBmThe lookup aggregation, i.e. <code>phi</code>BhCommitments linked to the lookup featureC`The polynomials specific to the lookup argument.CiThis is what the prover needs to remember while doing \xe2\x80\xa6BnAn iterator over the variants of LookupPatternCeThe minimum SRS size required to use Nova, in base 2.CjThe location of the preimage key as a field element of \xe2\x80\xa6CiThe maximum number of columns that can be used in the \xe2\x80\xa6BnThe number of gadgets supported by the programCcNumber of PLONK rows required to implement PoseidonCnThe following gadgets implement the Poseidon hash instance \xe2\x80\xa6CnThis gadget implement the Poseidon hash instance described \xe2\x80\xa6CnAll the commitments that the prover creates as part of the \xe2\x80\xa6BnAn iterator over the variants of SBInstructionAkInvalid secret key checksumBeFormat: <code>srl rd, rs1, rs2</code>BnAn iterator over the variants of UJInstructionCmWitness builder environment. Operates on multiple rows at \xe2\x80\xa6AkInvalid y-coordinate parityC`Activate the selector for the given instruction.0CgAllocate a new variable in the circuit for the next rowAlcoefficient commitment arrayCmThis function commits a polynomial using the SRS\xe2\x80\x99 basis \xe2\x80\xa6BjEC addition selector polynomial commitmentCnConnect the pair of cells specified by the cell1 and cell2 \xe2\x80\xa6BmConstrains 6 checks of padding absorb spongesBgConstrains 16 checks of squeeze spongesAmConstraints for this argumentCmGenerates the constraints for the Cairo initial claim and \xe2\x80\xa6CgGenerates the constraints for the Cairo instruction \xe2\x80\xa6CjGenerates the constraints for the Cairo flags Accesses \xe2\x80\xa6CfGenerates the constraints for the Cairo transition \xe2\x80\xa6CnCreate a new sponge, with an empty state (i.e. initialized \xe2\x80\xa6CaCreates a XOR gadget for <code>bits</code> lengthBaThe current iteration of the IVC.Cnverifies that the Cairo gate constraints are solved by the \xe2\x80\xa6DhThe actual evaluation points. Each field <code>evaluations</code> of \xe2\x80\xa6CnExtends a XOR gadget for <code>bits</code> length to a circuitAkForeign field addition gateAmForeign Field Addition moduleBaForeign field multiplication gateBcForeign field multiplication moduleDjCreate keypair from scalar field <code>secret</code> element and curve \xe2\x80\xa6CkCreate public key from curve point Note: Does not check \xe2\x80\xa6Aogeneric selector over domain d4AnWhether joint lookups are usedBeevaluation of lookup table polynomialCbAdds the 800 lookups required for Chi in the roundhPoseidonAfposeidon gate selectorBnevaluation of the poseidon selector polynomialBbRangeCheck0 polynomial commitmentsBbRangeCheck1 polynomial commitmentsBkThe row layout for <code>RangeCheck0</code>CjA single-column table containing the numbers from 0 to \xe2\x80\xa6BhWrite an array of values simultaneously.ClUsed by the accumulation protocol (folding) to perform a \xe2\x80\xa6DhSets an assert predicate <code>f(X)</code> such that when assert_zero isCkCoin a challenge from the sponge. Note that a challenge \xe2\x80\xa6CmThe power of the joint_combiner that can be used to add a \xe2\x80\xa6ClConvert an abstract variable to a field element! Inverse \xe2\x80\xa60ChReturns the 400 terms that compose the shifts of the \xe2\x80\xa6Cnverifies that the Cairo gate constraints are solved by the \xe2\x80\xa6CnThe Challenge term that contains an alpha. Is used to make \xe2\x80\xa6BcExponent of binary modulus (i.e. t)C`This struct contains multiple chunk evaluations.CnUsed to aggregate the constraints describing the relation. \xe2\x80\xa6AoFormat: <code>lui rd,imm</code>DhMultiplicities, indexed. This corresponds to the <code>m_i</code>. FirstCnTotal number of columns used in Keccak, including relation \xe2\x80\xa6ChSingle-column table of all values in the range [0, 2^16)DbA struct to store the challenges inside a <code>ProverProof</code>CfNumber of bytes for each part of the header of the \xe2\x80\xa6CdErrors that can arise when creating a verifier indexCnThe number of rows required for zero knowledge in circuits \xe2\x80\xa6BnAbsorbs the given evaluations into the sponge.DkAccess the general purpose register with index <code>idx</code>, adding \xe2\x80\xa60CnTake a prover environment, a multiplicities, and returns a \xe2\x80\xa6CjThis module provides a set of functions to perform bit \xe2\x80\xa6ChThis module contains a type ChunkedPolynomial, and a \xe2\x80\xa6CjCommit to evaluations with blinding factors, generated \xe2\x80\xa6CnPerform integer bound computation for high limb x\xe2\x80\x992 = x2 \xe2\x80\xa6CfBuild the constraints for the lookup protocol. The \xe2\x80\xa6DjReturns the number of leading 1s in <code>x</code>, storing the result \xe2\x80\xa60CkCreate a And for inputs as field elements starting at row 0CdThis function creates a <code>CairoClaim</code> gateCdThis function creates a <code>CairoFlags</code> gateCjCreate foreign field addition gate chain without range \xe2\x80\xa6BmCreate a multi range check witness from limbsCjCreate single range check gate Inputs the starting row \xe2\x80\xa6CnCreate a Xor for up to the native length starting at row 0 \xe2\x80\xa6DeThe polynomial that evaluates to <code>0</code> at the evaluation \xe2\x80\xa6CiThe combined lookup entry that can be used as dummy valueCmEvaluate the constant expressions in this expression down \xe2\x80\xa60CbEvaluate the constants in a linearization with \xe2\x80\xa6B`Linearize the <code>expr</code>.ClExtends an AND witness to the whole witness Input: first \xe2\x80\xa6CnExtend a chain of foreign field addition gates. It already \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6CjCreate foreign field range-check gate by extending the \xe2\x80\xa6CjExtends the Xor rows to the full witness Panics if the \xe2\x80\xa6CgThe path of the serialized BN254 SRS, inside this repo.CnCompute commitments to the lagrange basis corresponding to \xe2\x80\xa6CmReturn all runtime tables collected so far, padded to the \xe2\x80\xa6AiThe combined lookup tableChCheck what kind of lookups, if any, are used by this \xe2\x80\xa6Bkevaluation of lookup aggregation polynomialBgevaluation of lookup sorted polynomialsC`Adds the 1 lookup required for Iota in the roundF`Returns <code>x * y</code>, where <code>x</code> and <code>y</code> are treated as integers, \xe2\x80\xa60B`poseidon selector over domain d8CmSet the last \xe2\x80\x98access index\xe2\x80\x99 for the memory at address \xe2\x80\xa60CjSerialize field element f to a (positive) BigInt directly.CfWitness cells in current row in an interval [from, to)CcWitness cells in next row in an interval [from, to)BhWrite an array of values simultaneously.BmWrite a field element directly as a constant.CfWrites a field value to a column of the Keccak witnessAlBigUint array compose helperBaField element wrapper for BigUintA`Handy re-exports0BnErrors that can arise when preparing the setupBfAn extension for the Evaluations type.CgForeign field helpers for <code>B</code> the limb size.BfFormat: <code>jalr rd, rs1, imm</code>CmConfiguration for the lookup constraint. These values are \xe2\x80\xa6ClThe arity of the multivariate polynomials describing the \xe2\x80\xa6CmWrapper around an iterator that warns you if not consumed \xe2\x80\xa6BfThe size of the SRS that we serialize.DeAn integer <code>b</code> such that there exists a multiplicative \xe2\x80\xa6BfFormat: <code>sltu rd, rs1, rs2</code>k(t - 1) / 2C`Length of each word in the Keccak state, in bitsBnAbsorb a list of curve points into the sponge.CcGet the group element used for blinding commitmentsBoThis module contains a type ChunkedEvaluations,EhThis function populates the parameters <code>scalars</code> and <code>points</code>. \xe2\x80\xa6DjCombines multiple constraints <code>[c0, ..., cn]</code> into a single \xe2\x80\xa60CnCombine the (chunked) evaluations of multiple polynomials. \xe2\x80\xa6CnLet\xe2\x80\x99s say we want to do a lookup in a \xe2\x80\x9cvector-valued\xe2\x80\x9d\xe2\x80\xa6ChCompute the cross-terms as described in Behind Nova: \xe2\x80\xa6CnUsed to aggregate the constraints describing the relation. \xe2\x80\xa6DjReturns the number of leading 0s in <code>x</code>, storing the result \xe2\x80\xa60ChGadget generator of the whole cairo circuits from an \xe2\x80\xa6CmCreate a single foreign field addition gate. This is used \xe2\x80\xa6CnKeep the current executed instruction. This can be used to \xe2\x80\xa6Ciendoscalar multiplication scalar computation selector \xe2\x80\xa6CmExtend a single foreign field addition gate followed by a \xe2\x80\xa6ChFetch the last \xe2\x80\x98access index\xe2\x80\x99 that the memory at \xe2\x80\xa60ClGenerates a random field element of up to a given number \xe2\x80\xa6ClGet all the constraints for the verifier circuit and the \xe2\x80\xa6CiLoad the state of the Poseidon hash function into the \xe2\x80\xa6ChWhen in Squeeze mode, writes a Lookup containing the \xe2\x80\xa6CdAdds the 700 lookups required for PiRho in the roundCdAdds the 120 lookups required for Theta in the roundCjReturns the maximum number of lookups per row that are \xe2\x80\xa6ClGiven a number n, return the list of prime factors of n, \xe2\x80\xa6a?CiChallenges during the last computation. This field is \xe2\x80\xa6CjSponge state used by the prover for the current iteration.BoSave the state of poseidon into the environmentBmCreate selector polynomial for a circuit gateDjSets all fixed selectors directly. Each item in <code>selectors</code> \xe2\x80\xa6CkCompute the resulting scaled polynomial. Example: Given \xe2\x80\xa6BgTrue if runtime lookup tables are used.CnCheck the correctness of witness values for a complete-add \xe2\x80\xa6Cfevaluation of the Xor range check pattern selector \xe2\x80\xa6B`Invalid raw address bytes lengthAmContains the batch evaluationA`Handy re-exportsBaNumber of instructions in the ISACaAn iterator over the variants of ITypeInstructionCaAn iterator over the variants of JTypeInstructionCmDefine the maximum degree we support for the evaluations. \xe2\x80\xa6BeThe maximum size of a chunk (4 bytes)CgFlags indicating whether at least N bytes have been \xe2\x80\xa6CmAn alias to represent a polynomial (in either coefficient \xe2\x80\xa6CnPoseidon hasher type with experimental kimchi plonk sponge \xe2\x80\xa6CgPoseidon hasher type with legacy plonk sponge constantsClAbsorb [PlonkSpongeConstants::SPONGE_WIDTH - 1] elements \xe2\x80\xa60AiThe range check table ID.CaAn iterator over the variants of RTypeInstructionCm24-row table with all possible values for round and their \xe2\x80\xa6CjNumber of columns used by the MIPS interpreter to keep \xe2\x80\xa6BfFormat: <code>slti rd, rs1, imm</code>BeFormat: <code>sra rd, rs1, rs2</code>CfReturns constraints safely combined via the passed \xe2\x80\xa6CfGet the combined constraints for all foreign field \xe2\x80\xa6ClGet the combined constraints for all range check circuit \xe2\x80\xa6ChConstrains 136 checks of booleanity for some mode flags.DbCreates and writes the SRS into <code>get_bn254_srs_path()</code>.CjCreate a multi range check witness from two limbs: v01 \xe2\x80\xa6CjThis function creates a trusted-setup SRS instance for \xe2\x80\xa6CmCreate a trusted setup for the KZG protocol. The setup is \xe2\x80\xa6ChDisable gates checks (for testing; only enables with \xe2\x80\xa60ChExtend and existing witness with a multi range check \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6CjCommon parameters and functions for kimchi\xe2\x80\x99s foreign \xe2\x80\xa6BkIndex of the values to absorb in the spongeCmWrite a value into a runtime table. Panics if called on a \xe2\x80\xa6BbThe polynomials of the inner sums.gIndexesfProofsAeVerifier indexes/keysCkSet the last \xe2\x80\x98access index\xe2\x80\x99 for the general purpose \xe2\x80\xa60Bmevaluation of runtime lookup table polynomialCkThe offset of the runtime table within the concatenated \xe2\x80\xa6B`Returns the range check 16 tableBeThe challenge terms used in Berkeley.A`Handy re-exportsCkBoxed so that we don\xe2\x80\x99t store large proving indexes in \xe2\x80\xa601CmUsed to homogenize the constraints and allow the protocol \xe2\x80\xa6CiThe double generic gate actually contains two generic \xe2\x80\xa6Cnlegacy curve, a copy of the normal curve to support legacy \xe2\x80\xa6CnThe collection of polynomials (all in evaluation form) and \xe2\x80\xa6CnThe number of bytes of the preimage that have been read so \xe2\x80\xa6CbThe number of hashes performed so far in the blockCnThe at most 4-bytes of the length that are currently being \xe2\x80\xa6CoThe default number of chunks in a circuit is one (&lt; 2^16 \xe2\x80\xa6CaThe number of rows the verifier circuit requires.DgNumber of columns required in the <code>curr</code> part of the witnessDcNumber of columns required in the <code>next</code> part of the \xe2\x80\xa6AiTrack a multi-range-checkBiDouble an array of curve points in-place.CiHow many blocks are left to absorb (including current \xe2\x80\xa6DkEnforce the length of evaluations inside <code>ProverProof</code>. Atm, \xe2\x80\xa6AkReturn the folding combinerChFIXME: check if we need to pick the left or right spongeCfevaluation of the elliptic curve addition selector \xe2\x80\xa6CnThis allows you to create two generic gates by passing the \xe2\x80\xa6CeCreates a witness for the Keccak hash function Input:CmFetch the last \xe2\x80\x98access index\xe2\x80\x99 for the general purpose \xe2\x80\xa60CgLoad the value to absorb at the current step at the \xe2\x80\xa6ClThe evaluations of the fixed tables, over d8, indexed by \xe2\x80\xa6FdIncreases the heap pointer by <code>by_amount</code> if <code>if_is_true</code> is <code>1</code>\xe2\x80\xa60CjAdds the polynomials that are evaluated as part of the \xe2\x80\xa6CdConverts the linearization of the kimchi circuit \xe2\x80\xa6DiLookup multiplicities, a vector of values <code>m_i</code> per lookup \xe2\x80\xa6BbThe commitments of the inner sums.BmThe evaluations of the partial sums, over d8.CnAccessor for the other curve\xe2\x80\x99s prime subgroup generator, \xe2\x80\xa6Caevaluation of the RangeCheck0 selector polynomialCaevaluation of the RangeCheck1 selector polynomialDhIf a table is runtime table, <code>true</code> means we should create anCnValues for runtime tables. Each element (value) in the map \xe2\x80\xa6BaReturns the round constants tableDjReturns 1 if <code>x &lt; y</code> as signed integers, or 0 otherwise, \xe2\x80\xa60CnConvert a polynomial into chunks. Implementors must ensure \xe2\x80\xa6ChRetrieve or compute the digest for the corresponding \xe2\x80\xa6CjThe verifier index digest corresponding to this prover \xe2\x80\xa6CeSponge state used by the verifier for the current \xe2\x80\xa6BkVerify the <code>EndoMulscalar</code> gate.BiFormat: <code>bge rs1, rs2, offset</code>BjFormat: <code>bltu rs1, rs2, offset</code>Cnlegacy curve, a copy of the normal curve to support legacy \xe2\x80\xa6CkThe maximum total number of witness columns used by the \xe2\x80\xa6ClThe number of columns required for the Keccak selectors. \xe2\x80\xa6ClThe range check will be performed on 12-bit values, i.e. \xe2\x80\xa6CcAn iterator over the variants of SyscallInstructionBi2^s root of unity computed by GENERATOR^tAdInvalid y-coordinateBmList of the accumulated challenges over time.AfUsed by the OCaml sideCfComputes the linearization of the evaluations of a \xe2\x80\xa6BiEC point addition selector over domain d4CmUsed to homogenize the constraints and allow the protocol \xe2\x80\xa6c\xe2\x80\xa6BoTransform domain prefix string to field elementCcDescribe the control-flow for the verifier circuit.CcForeign field addition gates polynomial commitmentsCiForeign field multiplication gates polynomial commitmentsBoGet constraints related to the lookup argument.BiAdds a lookup to the RoundConstants tableEhReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.BhRangeCheck0 gate selector over domain d8BhRangeCheck1 gate selector over domain d8CmThis function checks that the preimage is read correctly. \xe2\x80\xa6DhRequest the preimage oracle for <code>len</code> bytes and store the \xe2\x80\xa6ClSets a fixed selector, the vector of length equal to the \xe2\x80\xa6ClSet up the shared precomputations. If not invoked, it is \xe2\x80\xa6EgReturn the result of shifting <code>x</code> by <code>by</code>, storing the result \xe2\x80\xa60CkTemporary registers for elliptic curve points in affine \xe2\x80\xa6ClConvert to 2 PrimeField limbs of 2 * LIMB_BITS each. The \xe2\x80\xa6BjAn extension for the DensePolynomial type.nInvalid lookupCcThe number of preimage bytes processed in this stepCjThe at most 4-bytes of the preimage that are currently \xe2\x80\xa6CjThe at most 4-byte chunk of the preimage that has been \xe2\x80\xa6DiA formal sum of the form <code>s_0 * p_0 + ... s_n * p_n</code> where \xe2\x80\xa6CiThis function creates a <code>CairoTransition</code> gateCdDerives a nonce compatible with OCaml/TypeScript \xe2\x80\xa6Cfevaluation of the endoscalar multiplication scalar \xe2\x80\xa6ClBuild mapping from 1..N to the first N prime numbers. It \xe2\x80\xa6BkReturn the requested MDS matrix coefficientBkevaluation of lookup aggregation polynomialCiThe commitments to the multiplicities, indexed by the \xe2\x80\xa6CnThe polynomial of the multiplicities, indexed by the table \xe2\x80\xa6CiWhen in Absorb mode, reads Lookups containing the 136 \xe2\x80\xa6ClCompute all evaluations of the normalized lagrange basis \xe2\x80\xa6CkSet the last \xe2\x80\x98access index\xe2\x80\x99 for the general purpose \xe2\x80\xa60CbAn optional selector polynomial for runtime tablesCnThe polynomial (x - w^{n - i}) * (x - w^{n - i + 1}) * \xe2\x80\xa6 \xe2\x80\xa6B`BigUint array PrimeField helpersChNumber of generic of registers by a double generic gate.AmFailed to get witness for rowB`PrimeField array BigUint helpersClEvaluations of all normalized lagrange basis polynomials \xe2\x80\xa6CnA flag indicating whether the preimage has been read fully \xe2\x80\xa6ChAccumulate the program state (or in other words, the \xe2\x80\xa60CfGet combined constraints for a given foreign field \xe2\x80\xa6ClGet combined constraints for a given range check circuit \xe2\x80\xa6CjThis function creates a <code>CairoInstruction</code> gateCgCreate foreign field multiplication gate Inputs the \xe2\x80\xa6CiCreate range check gate for constraining three 88-bit \xe2\x80\xa6BiEC point addition selector over domain d8CmCreate foreign field multiplication gate by extending the \xe2\x80\xa6CmCreate foreign field muti-range-check gadget by extending \xe2\x80\xa6ChGet constraints related to the application logic itself.CjReturn the constraints for the selector. Each selector \xe2\x80\xa60Ahlookup constraint systemCnThe evaluations of the multiplicities, over d8, indexed by \xe2\x80\xa6ChComputes what is the non-normalized next instruction \xe2\x80\xa6Ahpermutation coefficientsBkCommitments to the previous program states.CnTries to read the SRS from disk, otherwise panics. Returns \xe2\x80\xa6CaReset the environment to build the next iterationC`Write an array of /field/ values simultaneously.Ckpre-computed polynomials that depend only on the chosen \xe2\x80\xa6Ag(Self::MODULUS - 1) / 2BhFormat: <code>slli rd, rs1, shamt</code>CiUnnormalizedLagrangeBasis(i) is (x^n - 1) / (x - omega^i)BjAccumulated witness for the program state.CjGiven a filename with encoded (witness, runtime table, \xe2\x80\xa6CmCommit to evaluations with custom blinding factors. It is \xe2\x80\xa6CkGetting multiplicities for range check tables less or equalBl2^259 (see foreign field multiplication RFC)ClCompute all evaluations of the normalized Lagrange basis \xe2\x80\xa6CkProvides the sponge params to be used with the other curve.0Bgpermutation coefficients over domain d8Bmevaluation of runtime lookup table polynomialAeForeign field helpersClDegree of the quotient polynomial. Used to keep track of \xe2\x80\xa6CjMaximum degree of the constraints. It does include the \xe2\x80\xa6CgThe maximum number of bits the fields can be. It is \xe2\x80\xa6BhFormat: <code>srli rd, rs1, shamt</code>CeAccumulate the committed state by adding the last \xe2\x80\xa60AnTrack a high bound computationFcGiven arrays of curve points <code>v0</code> and <code>v1</code> do <code>v0[i] += v1[i]</code> \xe2\x80\xa6CnCompute the cross-terms of the given polynomial, scaled by \xe2\x80\xa6BcOutput example for N = 2 and D = 2:CnConnects the wires of the range checks in a single foreign \xe2\x80\xa6CeCreate a multi range check witness from compact limbsCmThis contains the DomainConstantEvaluations which is used \xe2\x80\xa6CnExtend an existing witness with a multi-range-check gadget \xe2\x80\xa6CkExtend the witness with external compact multi range_checksCeevaluation of the ForeignFieldAdd selector polynomialCeevaluation of the ForeignFieldMul selector polynomialBmThe commitment to the aggregation polynomial.AkThe aggregation polynomial.CmThis function computes a strict lower bound in the number \xe2\x80\xa6CfThe polynomials representing evaluated columns, in \xe2\x80\xa6DfThe integer <code>k</code> such that there exists a multiplicative \xe2\x80\xa6CeTotal number of constraints for all instructions, \xe2\x80\xa60BmCommitments to the accumulated program state.ClCompute the list of indices to perform N nested loops of \xe2\x80\xa6CcForeign field addition gate selector over domain d8CiForeign field multiplication gate selector over domain d8CbReturn the Poseidon round constants as a constant.CkLoad the affine coordinates of the elliptic curve point \xe2\x80\xa6BlThe evaluations of the aggregation, over d8.Cievaluation of the Lookup range check pattern selector \xe2\x80\xa6Cmevaluation of the RangeCheck range check pattern selector \xe2\x80\xa6C`Save temporary accumulators into the environmentChCompute the evaluations of the unnormalized lagrange \xe2\x80\xa6CnRepresent a polynomial either with its coefficients or its \xe2\x80\xa6BcGENERATOR^((MODULUS-1) / (2^s * \xe2\x80\xa6BgFormat: <code>sltiu rd, rs1, imm</code>CiCompute the cross terms of a list of polynomials. The \xe2\x80\xa6CnEvaluates the polynomial (x - w^{n - i}) * (x - w^{n - i + \xe2\x80\xa6CmThe structure used by the prover the compute the quotient \xe2\x80\xa6BhFormat: <code>srai rd, rs1, shamt</code>ChThe first instruction in the verifier circuit (often \xe2\x80\xa6CjThe blinder used to commit, to avoid committing to the \xe2\x80\xa6BaTrack a compact-multi-range-checkCgNumber of constraints for a given foreign field mul \xe2\x80\xa6CnNumber of constraints for a given range check circuit gate \xe2\x80\xa6CjCommit to evaluations, without blinding factors. It is \xe2\x80\xa6BfCompute non-zero intermediate productsChRetrieve or compute the digest for the corresponding \xe2\x80\xa6CbCreate witness for bound computation addition gateCnExtend the witness with external bound addition as foreign \xe2\x80\xa6Cjevaluation of the runtime lookup table selector polynomialBjFormat: <code>bgeu rs1, rs2, offset</code>EgGiven vectors of curve points <code>g1</code> and <code>g2</code>, compute a vector \xe2\x80\xa6CkThis function can be called before any call to a kimchi \xe2\x80\xa6DiCreates a BN254 SRS. If the <code>overwrite_srs</code> flag is on, or \xe2\x80\xa6CkThe actual number of instructions executed results from \xe2\x80\xa60AmCreate new index for lookups.DaEach entry in <code>kinds</code> has a corresponding selector \xe2\x80\xa6CkCreate range check gate for constraining compact limbs. \xe2\x80\xa6CmCreate foreign field muti-range-check gadget by extending \xe2\x80\xa6DiExtends a NOT gadget for <code>bits</code> length using Xor gates. It \xe2\x80\xa6CgGet all the constraints for the verifier circuit, only.CnThe polynomial (x - w^{n - zk_rows}) * (x - w^{n - zk_rows \xe2\x80\xa6Akzeta^n and (zeta * omega)^nCmCombines the constraints for the Cairo gates depending on \xe2\x80\xa6CnExtend a NOT witness for less than 255 bits (native field) \xe2\x80\xa6CcExtend the witness with external multi range_checksCievaluation of the ForeignFieldMul range check pattern \xe2\x80\xa6DkExtends a bitwise negation gadget with <code>n</code> NOT components of \xe2\x80\xa6Bhzero-knowledge polynomial over domain.d8DkGets permutation_vanishing_polynomial_m from <code>VerifierIndex</code> \xe2\x80\xa6Aizero-knowledge polynomialBjUses a batch version of Algorithm 1 of \xe2\x80\xa6CnExtends negation witnesses from generic gate, assuming the \xe2\x80\xa6DgSame as <code>get_lagrange_basis</code> but only using the domain size.ClThe digest of the program state after executing the last \xe2\x80\xa6CcDefine the number of values we must absorb when \xe2\x80\xa6CmThe digest of the program state before executing the last \xe2\x80\xa6CkCompute all the possible two factors decomposition of a \xe2\x80\xa6CnEvaluates the polynomial (x - w^{n - zk_rows}) * (x - w^{n \xe2\x80\xa6CmExtend the witness with external high bounds additions as \xe2\x80\xa6CkExtend the witness with external compact multi range_checksCmA generic regression serialization test for serialization \xe2\x80\xa6CkThe polynomial that vanishes on the zero-knowledge rows \xe2\x80\xa6Ckthe polynomial that vanishes on the zero-knowledge rows \xe2\x80\xa6CjThis is same as _lagrange_commitments, but returns the \xe2\x80\xa603")