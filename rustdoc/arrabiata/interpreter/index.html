<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains the implementation of the IVC scheme in addition to running an arbitrary function that can use up to crate::NUMBER_OF_COLUMNS columns. At the moment, all constraints must be of maximum degree crate::MAX_DEGREE, but it might change in the future."><title>arrabiata::interpreter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="arrabiata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../arrabiata/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../arrabiata/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module interpreter</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">arrabiata</a>::<wbr><a class="mod" href="#">interpreter</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/arrabiata/interpreter.rs.html#1-935">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains the implementation of the IVC scheme in addition to
running an arbitrary function that can use up to <a href="../constant.NUMBER_OF_COLUMNS.html" title="constant arrabiata::NUMBER_OF_COLUMNS">crate::NUMBER_OF_COLUMNS</a>
columns.
At the moment, all constraints must be of maximum degree
<a href="../constant.MAX_DEGREE.html" title="constant arrabiata::MAX_DEGREE">crate::MAX_DEGREE</a>, but it might change in the future.</p>
<p>The implementation relies on a representation of the circuit as a 2D array
of “data points” the interpreter can use.</p>
<p>An interpreter defines what a “position” is in the circuit and allow to
perform operations using these positions.
Some of these positions will be considered as public inputs and might be
fixed at setup time while making a proof, when other will be considered as
private inputs.</p>
<p>On top of these abstraction, gadgets are implemented.
For the Nova-like IVC schemes, we describe below the different gadgets and
how they are implemented with this abstraction.</p>
<p><strong>Table of contents</strong>:</p>
<ul>
<li><a href="#gadgets-implemented">Gadgets implemented</a>
<ul>
<li><a href="#elliptic-curve-addition">Elliptic curve addition</a>
<ul>
<li><a href="#gadget-layout">Gadget layout</a></li>
</ul>
</li>
<li><a href="#hash---poseidon">Hash - Poseidon</a>
<ul>
<li><a href="#gadget-layout-1">Gadget layout</a></li>
</ul>
</li>
<li><a href="#elliptic-curve-scalar-multiplication">Elliptic curve scalar multiplication</a>
<ul>
<li><a href="#gadget-layout-2">Gadget layout</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#handle-the-combinaison-of-constraints">Handle the combinaison of constraints</a></li>
<li><a href="#permutation-argument">Permutation argument</a></li>
<li><a href="#fiat-shamir-challenges">Fiat-Shamir challenges</a></li>
</ul>
<h3 id="gadgets-implemented"><a href="#gadgets-implemented">Gadgets implemented</a></h3><h4 id="elliptic-curve-addition"><a href="#elliptic-curve-addition">Elliptic curve addition</a></h4>
<p>The Nova augmented circuit requires to perform elliptic curve operations, in
particular additions and scalar multiplications.</p>
<p>To reduce the number of operations, we consider the affine coordinates.
As a reminder, here the equations to compute the addition of two different
points <code>P1 = (X1, Y1)</code> and <code>P2 = (X2, Y2)</code>. Let define <code>P3 = (X3, Y3) = P1 + P2</code>.</p>
<div class="example-wrap"><pre class="language-text"><code>- λ = (Y1 - Y2) / (X1 - X2)
- X3 = λ^2 - X1 - X2
- Y3 = λ (X1 - X3) - Y1
</code></pre></div>
<p>Therefore, the addition of elliptic curve points can be computed using the
following degree-2 constraints</p>
<div class="example-wrap"><pre class="language-text"><code>- Constraint 1: λ (X1 - X2) - Y1 + Y2 = 0
- Constraint 2: X3 + X1 + X2 - λ^2 = 0
- Constraint 3: Y3 - λ (X1 - X3) + Y1 = 0
</code></pre></div>
<p>If the points are the same, the λ is computed as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>- λ = (3 X1^2 + a) / (2Y1)
</code></pre></div><h5 id="gadget-layout"><a href="#gadget-layout">Gadget layout</a></h5>
<p>For given inputs (x1, y1) and (x2, y2), the layout will be as follow:</p>
<div class="example-wrap"><pre class="language-text"><code>| C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 | C15 | C16 | C17 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | --- | --- | --- | --- | --- | --- | --- | --- |
| x1 | y1 | x2 | y2 | b0 | λ  | x3 | y3 |    |     |     |     |     |     |     |     |     |
</code></pre></div>
<p>where <code>b0</code> is equal two <code>1</code> if the points are the same, and <code>0</code> otherwise.</p>
<p>TBD/FIXME: supports negation and the infinity point.</p>
<p>TBD/FIXME: the gadget layout might change when we will implement the
permutation argument. The values <code>(x1, y1)</code> can be public inputs.
The values <code>(x2, y2)</code> can be fetched from the permutation argument, and must
be the output of the elliptic curve scaling.</p>
<p>The gadget requires therefore 7 columns.</p>
<h4 id="hash---poseidon"><a href="#hash---poseidon">Hash - Poseidon</a></h4>
<p>Hashing is a crucial part of the IVC scheme. The hash function the
interpreter does use for the moment is an instance of the Poseidon hash
function with a fixed state size of <a href="../constant.POSEIDON_STATE_SIZE.html" title="constant arrabiata::POSEIDON_STATE_SIZE">POSEIDON_STATE_SIZE</a>. Increasing the
state size can be considered as it would potentially optimize the
number of rounds, and allow hashing more data on one row. We leave this for
future works.</p>
<p>A direct optimisation would be to use
<a href="https://eprint.iacr.org/2023/323">Poseidon2</a> as its performance on CPU is
better, for the same security level and the same cost in circuit. We leave
this for future works.</p>
<p>For a first version, we consider an instance of the Poseidon hash function
that is suitable for curves whose field size is around 256 bits.
A security analysis for these curves give us a recommandation of 60 full
rounds if we consider a 128-bit security level and a low-degree
exponentiation of <code>5</code>, with only full rounds.
In the near future, we will consider the partial rounds strategy to reduce
the CPU cost. For a first version, we keep the full rounds strategy to keep
the design simple.</p>
<p>When applying the full/partial round strategy, an optimisation can be used,
see <a href="https://eprint.iacr.org/2022/462">New Optimization techniques for PlonK’s
arithmetisation</a>. The techniques described
in the paper can also be generalized to other constraints used in the
interpreter, but we leave this for future works.</p>
<h5 id="gadget-layout-1"><a href="#gadget-layout-1">Gadget layout</a></h5>
<p>We start with the assumption that 17 columns are available for the whole
circuit, and we can support constraints up to degree 5.
Therefore, we can compute 4 full rounds per row if we rely on the
permutation argument, or 5 full rounds per row if we use the “next row”.</p>
<p>We provide two implementations of the Poseidon hash function. The first one
does not use the “next row” and is limited to 4 full rounds per row. The
second one uses the “next row” and can compute 5 full rounds per row.
The second implementation is more efficient as it allows to compute one
additional round per row.
For the second implementation, the permutation argument will only be
activated on the first and last group of 5 rounds.</p>
<p>The layout for the one not using the “next row” is as follow (4 full rounds):</p>
<div class="example-wrap"><pre class="language-text"><code>| C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 | C15 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | --- | --- | --- | --- | --- | --- |
| x  | y  | z  | a1 | a2 | a3 | b1 | b2 | b3 | c1  | c2  | c3  | o1  | o2  | o3  |
</code></pre></div>
<p>where (x, y, z) is the input of the current step, (o1, o2, o3) is the
output, and the other values are intermediary values. And we have the following equalities:</p>
<div class="example-wrap"><pre class="language-text"><code>(a1, a2, a3) = PoseidonRound(x, y, z)
(b1, b2, b3) = PoseidonRound(a1, a2, a3)
(c1, c2, c3) = PoseidonRound(b1, b2, b3)
(o1, o2, o3) = PoseidonRound(c1, c2, c3)
</code></pre></div>
<p>The layout for the one using the “next row” is as follow (5 full rounds):</p>
<div class="example-wrap"><pre class="language-text"><code>| C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 | C15 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | --- | --- | --- | --- | --- | --- |
| x  | y  | z  | a1 | a2 | a3 | b1 | b2 | b3 | c1  | c2  | c3  | d1  | d2  | d3  |
| o1 | o2 | o2
</code></pre></div>
<p>where (x, y, z) is the input of the current step, (o1, o2, o3) is the
output, and the other values are intermediary values. And we have the
following equalities:</p>
<div class="example-wrap"><pre class="language-text"><code>(a1, a2, a3) = PoseidonRound(x, y, z)
(b1, b2, b3) = PoseidonRound(a1, a2, a3)
(c1, c2, c3) = PoseidonRound(b1, b2, b3)
(d1, d2, d3) = PoseidonRound(c1, c2, c3)
(o1, o2, o3) = PoseidonRound(d1, d2, d3)
</code></pre></div>
<p>For both implementations, round constants are passed as public inputs. As a
reminder, public inputs are simply additional columns known by the prover
and verifier.
Also, the elements to absorb are added to the initial state at the beginning
of the call of the Poseidon full hash. The elements to absorb are supposed
to be passed as public inputs.</p>
<h4 id="elliptic-curve-scalar-multiplication"><a href="#elliptic-curve-scalar-multiplication">Elliptic curve scalar multiplication</a></h4>
<p>The Nova-based IVC schemes require to perform scalar multiplications on
elliptic curve points. The scalar multiplication is computed using the
double-and-add algorithm.</p>
<p>We will consider a basic implementation using the “next row”. The
accumulators will be saved on the “next row”. The decomposition of the
scalar will be incrementally on each row.
The scalar used for the scalar multiplication will be fetched using the
permutation argument (FIXME: to be implemented).
More than one bit can be decomposed at the same time, and we could reduce
the number of rows.
We leave this for future work.</p>
<h5 id="gadget-layout-2"><a href="#gadget-layout-2">Gadget layout</a></h5>
<p>For a (x, y) point and a scalar, we apply the double-and-add algorithm, one step per row.
Therefore, we have 255 rows to compute the scalar multiplication.
For a given step <code>i</code>, we have the following values:</p>
<ul>
<li><code>tmp_x</code>, <code>tmp_y</code>: the temporary values used to keep the double.</li>
<li><code>res_x</code>, <code>res_y</code>: the result of the scalar multiplication i.e. the accumulator.</li>
<li><code>b</code>: the i-th bit of the scalar.</li>
<li><code>r_i</code> and <code>r_(i+1)</code>: scalars such that r_(i+1) = b + 2 * r_i.</li>
<li><code>λ'</code> and <code>λ</code>: the coefficients</li>
<li>o’_x and o’_y equal to <code>res_plus_tmp_x</code> and <code>res_plus_tmp_y</code> if <code>b == 1</code>,
otherwise equal to <code>o_x</code> and <code>o_y</code>.</li>
</ul>
<p>We have the following layout:</p>
<div class="example-wrap"><pre class="language-text"><code>| C1   |   C2   |      C3       |      C4       |    C5     | C7 |       C7       |       C8       | C9 | C10 |   C11    | C12 | C13 | C14 | C15 | C16 | C17 |
| --   | -----  | ------------- | ------------- | --------- | -- | -------------- | -------------- | -- | --- | -------- | --- | --- | --- | --- | --- | --- |
| o_x  |  o_y   | double_tmp_x  | double_tmp_y  |    r_i    | λ  | res_plus_tmp_x | res_plus_tmp_y | λ&#39; |  b  |
| o&#39;_x |  o&#39;_y  | double_tmp&#39;_x | double_tmp&#39;_y |  r_(i+1)  |
</code></pre></div>
<p>FIXME: an optimisation can be implemented using “a bucket” style algorithm,
as described in <a href="https://github.com/o1-labs/rfcs/blob/main/0013-efficient-msms-for-non-native-pickles-verification.md">Efficient MSMs in Kimchi
Circuits</a>.
We leave this for future work.</p>
<h3 id="handle-the-combinaison-of-constraints"><a href="#handle-the-combinaison-of-constraints">Handle the combinaison of constraints</a></h3>
<p>The prover will have to combine the constraints to generate the
full circuit at the end. The constraints will be combined using a
challenge (often called α) that will be generated in the verifier circuit by
simulating the Fiat-Shamir transformation.
The challenges will then be accumulated over time using the random coin used
by the folding argument.
The verifier circuit must be carefully implemented to ensure that all the
messages that the prover would have sent before coining the random combiner
for the constraints has been absorbed properly in the verifier circuit.</p>
<p>Using this technique requires us a folding scheme that handles degree
<code>5 + 1</code> constraints, as the challenge will be considered as a variable.
The reader can refer to the folding library available in this monorepo for
more contexts.</p>
<h3 id="permutation-argument"><a href="#permutation-argument">Permutation argument</a></h3>
<p>Communication between rows must be done using a permutation argument. The
argument we use will be a generalisation of the one used in the <a href="https://eprint.iacr.org/2019/953">PlonK
paper</a>.</p>
<p>The construction of the permutations will be done using the methods prefixed
<code>save</code> and <code>load</code>. The index of the current row and the index of the
time the value has been written will be used to generate the permutation on
the fly.</p>
<p>The permutation argument described in the PlonK paper is a kind of “inverse
lookup” protocol, like Plookup. The polynomials are defined as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>           Can be seen as T[f(X)] = Χ
         --------
         |      |
f&#39;(X) = f(X) + β X + γ
                     |--- Can be seen as the evaluation point.
                        |
                        |
g&#39;(X) = g(X) + β σ(X) + γ
         |      |
         --------
         Can be seen as T[g(X)] = σ(X)
</code></pre></div>
<p>And from this, we build an accumulator, like for Plookup.
The accumulator requires to coin two challenges, β and γ, and it must be
done after the commitments to the columns have been absorbed.
The verifier at the next step will verify that the challenges have been
correctly computed.
In the implementation, the accumulator will be computed after the challenges
and the commitments. Note that the accumulator must also be aggregated, and
the aggregation must be performed by the verifier at the next step.</p>
<p>The methods <code>save</code> and <code>load</code> will accept as arguments only a column that is
included in the permutation argument. For instance, <code>save_poseidon_state</code>
will only accept columns with index 3, 4 and 5, where the
<code>load_poseidon_state</code> will only accepts columns with index 0, 1 and 2.</p>
<p>The permutations values will be saved in public values, and will contain the
index of the row. The permutation values will be encoded with a 32 bits
value (u32) as we can suppose a negligible probability that a user will use
more than 2^32 rows.</p>
<p>The permutation argument also generates constraints that will be
homogenized with the gadget constraints.</p>
<p>Note all rows might require to use the permutation argument. Therefore, a
selector will be added to activate/deactivate the permutation argument.
When a method calls <code>save</code> or <code>load</code>, the selector will be activated. By
default, the selector will be deactivated.</p>
<p>TBD:</p>
<ul>
<li>number of columns</li>
<li>accumulator column</li>
<li>folding of the permutation argument</li>
</ul>
<p>TBD/FIXME: do we use a additive permutation argument to increase the number
of columns we can perform the permutation on?</p>
<p>TBD/FIXME: We can have more than one permutation argument. For instance, we
can have a permutation argument for the columns 0, 1, 2, 3 and one for the
columns 4, 5, 6, 7. It can help to decrease the degree.</p>
<h3 id="fiat-shamir-challenges"><a href="#fiat-shamir-challenges">Fiat-Shamir challenges</a></h3>
<p>The challenges sent by the verifier must also be simulated by the IVC
circuit.</p>
<p>For a step <code>i + 1</code>, the challenges of the step <code>i</code> must be computed by the
verifier, and check that it corresponds to the ones received as a public
input.</p>
<p>TBD/FIXME: specify. Might require foreign field arithmetic.</p>
<p>TBD/FIXME: do we need to aggregate them for the end?</p>
<h3 id="folding"><a href="#folding">Folding</a></h3>
<p>Constraints must be homogenized for the folding scheme.
Homogenising a constraint means that we add a new variable (called “U” in
Nova for instance) that will be used to homogenize the degree of the monomials
forming the constraint.
Next to this, additional information, like the cross-terms and the error
terms must be computed.</p>
<p>This computation depends on the constraints, and in particular on the
monomials describing the constraints.
The computation of the cross-terms and the error terms happen after the
witness has been built and the different arguments like the permutation or
lookup have been done. Therefore, the interpreter must provide a method to
compute it, and the constraints should be passed as an argument.</p>
<p>When computing the cross-terms, we must compute the contribution of each
monomial to it.</p>
<p>The implementation works as follow:</p>
<ul>
<li>Split the constraint in monomials</li>
<li>For the monomials of degree <code>d</code>, compute the contribution when
homogenizing to degree <code>d'</code>.</li>
<li>Sum all the contributions.</li>
</ul>
<p>The library [mvpoly] can be used to compute the cross-terms and to
homogenize the constraints. The constraints can be converted into a type
implementing the trait <a href="mvpoly::MVPoly">MVPoly</a> and the method
<a href="mvpoly::MVPoly::compute_cross_terms">compute_cross_terms</a> can be used from
there.</p>
</div></details><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Instruction.html" title="enum arrabiata::interpreter::Instruction">Instruction</a></div><div class="desc docblock-short">A list of instruction/gadget implemented in the interpreter.
The control flow can be managed by implementing a function
<code>fetch_next_instruction</code> and <code>fetch_instruction</code> on a witness environnement.
See the <a href="../witness/struct.Env.html" title="struct arrabiata::witness::Env">Witness environment</a> for more details.</div></li><li><div class="item-name"><a class="enum" href="enum.Side.html" title="enum arrabiata::interpreter::Side">Side</a></div><div class="desc docblock-short">Define the side of the temporary accumulator.
When computing G1 + G2, the interpreter will load G1 and after that G2.
This enum is used to decide which side fetching into the cells.
In the near future, it can be replaced by an index.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.InterpreterEnv.html" title="trait arrabiata::interpreter::InterpreterEnv">InterpreterEnv</a></div><div class="desc docblock-short">An abstract interpreter that provides some functionality on the circuit. The
interpreter should be seen as a state machine with some built-in
functionality whose state is a matrix, and whose transitions are described
by polynomial functions.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.run_app.html" title="fn arrabiata::interpreter::run_app">run_app</a></div><div class="desc docblock-short">Run the application</div></li><li><div class="item-name"><a class="fn" href="fn.run_ivc.html" title="fn arrabiata::interpreter::run_ivc">run_ivc</a></div><div class="desc docblock-short">Run an iteration of the IVC scheme</div></li></ul></section></div></main></body></html>