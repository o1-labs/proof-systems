searchState.loadedDescShard("poly_commitment", 0, "Get the group element used for blinding commitments\nCommits a polynomial, potentially splitting the result in …\nCommit to a polynomial, with custom blinding factors. It …\nCommit to evaluations with blinding factors, generated …\nCommit to evaluations with custom blinding factors. It is …\nCommit to evaluations, without blinding factors. It is …\nThis function commits a polynomial using the SRS’ basis …\nThis module implements Dlog-based polynomial commitment …\nCreate an SRS of size <code>depth</code>.\nCompute commitments to the lagrange basis corresponding to …\nSame as <code>get_lagrange_basis</code> but only using the domain size.\nThis module contains the implementation of the polynomial …\nThis module implements the KZG protocol described in the …\nTurns a non-hiding polynomial commitment into a hidding …\nSame as SRS::mask except that you can pass the blinders …\nThe maximum polynomial degree that can be committed to\nCreate an opening proof for a batch of polynomials. The …\nThis module defines Property-based tests for the SRS trait.\nTo prover and verify proofs you need a Structured Reference\nVerify the opening proof\nContains the batch evaluation\nA commitment to a polynomial with some blinding factors.\nA useful trait extending AffineRepr for commitments. …\nA trait extending CommitmentCurve for endomorphisms. …\nContains the evaluation of a polynomial commitment at a …\nRepresent a polynomial commitment when the type is …\nReturns …\nMultiplies each blinding chunk of f with powers of zeta^n\nMultiplies each commitment chunk of f with powers of zeta^n\nThis function populates the parameters <code>scalars</code> and <code>points</code>. …\nCombine where x1 = one\nCombine where x1 = one\nComputes the linearization of the evaluations of a …\nThe commitment of the polynomial being evaluated. Note …\nA challenge to aggregate multiple evaluation points.\nThe actual evaluation points. Each field <code>evaluations</code> of …\nContains an evaluation table. For instance, for vanilla …\nA list of evaluations, each supposed to correspond to a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn only the first chunk Getting this single value is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the commitment is empty.\nReturns the number of chunks.\nPerforms a multi-scalar multiplication between scalars <code>elm</code> …\nThe opening proof.\nA challenge to combine polynomials. Powers of this point …\nInside the circuit, we have a specialized scalar …\nSponge used to coin and absorb values and simulate …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCommitment round challenges (endo mapped) and their …\nSame as <code>prechallenges</code>, but maps scalar challenges using …\nThis function creates SRS instance for circuits with …\nThis function creates a trusted-setup SRS instance for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe vector of group elements for committing to polynomials …\nA group element used for blinding commitments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommitments to Lagrange bases, per domain size\nVector of rounds of L &amp; R commitments\nTurns a non-hiding polynomial commitment into a hidding …\nThe maximum polynomial degree that can be committed to\nComputes a log-sized vector of scalar challenges for …\nA final folded commitment base\nThis function verifies a batch of polynomial commitment …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nvector of rounds of L &amp; R commitments\nDefine a structured reference string (i.e. SRS) for the …\nA blinding factor used to hide the polynomial, if necessary\nCombine the (chunked) evaluations of multiple polynomials. …\nCreate a KZG proof. Parameters:\nCreate a trusted setup for the KZG protocol. The setup is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe full SRS is the one used by the prover. Can be seen as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParameters:\nSRS to be used by the verifier. Can be seen as the “…\nVerify a proof. Note that it only works for two elements …\nThe size of the SRS that we serialize.\nWe store several different types of SRS objects. This enum …\nA clone of the SRS struct that is used for serialization, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe vector of group elements for committing to polynomials …\nObtains an SRS for a specific curve from disk. Panics if …\nGeneric SRS getter fuction.\nObtains a Test SRS for a specific curve from disk. Panics …\nA group element used for blinding commitments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommitments to Lagrange bases, per domain size\nPolynomial represented by its coefficients\nRepresent a polynomial either with its coefficients or its …\nPolynomial represented by its evaluations over a domain D\nCombine the polynomials using a scalar (<code>polyscale</code>), …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")