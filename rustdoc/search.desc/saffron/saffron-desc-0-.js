searchState.loadedDescShard("saffron", 0, "This file handles bytes &lt;-&gt; scalar conversions for Saffron.\nFolding version of the read prover.\nThis module defines the read proof prover and verifier. …\nThis module defines the storage proof prover and verifier. …\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nA <code>FieldBlob&lt;F&gt;</code> is what Storage Provider stores per user’s\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the byte representation of the <code>FieldBlob</code>. Note that\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTakes commitments C_i, computes α = hash(C_0 || C_1 || ……\nDiff request pointing to a single commitment.\nA list of unique addresses, each ∈ [0, SRS_SIZE]\nReturns a new vector that contains the data updated with …\nUpdates the data with the provided diff, replacing old …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA list of new values, each corresponding to address in …\nWhich commitment within a group of commitments representing\nConverts <code>bytes</code> into a field element ; <code>bytes</code> length can …\nConverts each chunk of size <code>F::MODULUS_BIT_SIZE / 8</code> from …\nSame as encode_as_field_elements, but the returned vector …\nNon-relaxed instance attesting to <code>d * q - a = 0</code>\nNon-relaxed witness contains evaluations (field vectors) …\nThe proof attesting to the validity of the relaxed …\nRelaxed instance variant, attesting to …\nRelaxed witness extends the non-relaxed witness with …\nEvaluation of answer polynomial at the required challenge …\nThis function checks if the provided instance is valid …\nCommitment to the answers\nCommitment to the data\nCommitment to the error term for folding\nCommitment to the query polynomial\nNon-relaxed part\nEvaluation of data polynomial at the required challenge …\nEvaluation of error polynomial at the required challenge …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPolynomial commitment’s proof for the validity of …\nEvaluation of query polynomial at the required challenge …\nCommitment of quotient polynomial T (aka t_comm)\nHomogeneization term for folding\nGenerates a random core instance and witness\nGenerates a relaxed instance and witness. Note that the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents the bytes a user query\nRepresents a query in term of Field element\nFor commitments C_i and randomness r, returns ∑ r^i C_i.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")