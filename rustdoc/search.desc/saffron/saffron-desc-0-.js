searchState.loadedDescShard("saffron", 0, "Abstracts a sponge operating on a base field <code>Fq</code> of the …\nAbsorbs a base field element. This operation is the most …\nAbsorbs an element of the scalar field <code>Fr</code> — it is done …\nAbsorbs a base field point, that is a pair of <code>Fq</code> elements. …\nSqueeze out a challenge in the scalar field. Implemented by\nSqueeze out a base field challenge. This operation is the …\nReturns a scalar field digest using the binary …\nReturns a base field digest by squeezing the underlying …\nThis file handles bytes &lt;-&gt; scalar conversions for Saffron.\nFolding version of the read prover.\nCreates a new sponge.\nThis module defines the read proof prover and verifier. …\nThis file handles the storage gestion for the state …\nThis module defines the storage proof prover and verifier. …\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nA <code>FieldBlob&lt;F&gt;</code> is what Storage Provider stores per user’s\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the byte representation of the <code>FieldBlob</code>. Note that\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA commitment that represent a whole data TODO: for now, we …\nTakes commitments C_i, computes α = hash(C_0 || C_1 || ……\nReturns the non-hiding commitment to the provided …\nCompute the commitment to the polynomial <code>P</code> of same degree …\nCompute the commitment to <code>data</code> ; if the length of <code>data</code> …\nReturns the argument unchanged.\nCommit a <code>data</code> of length smaller than <code>SRS_SIZE</code> If greater …\nCalls <code>U::from(self)</code>.\nTODO: This only handle the single commitment version for …\nDiff request pointing to a single commitment.\nA list of unique addresses, each ∈ [0, SRS_SIZE]\nReturns a new vector that contains the data updated with …\nUpdates the data with the provided diff, replacing old …\nA list of <code>new_value - old_values</code>, each corresponding to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhich commitment within a group of commitments representing\nConverts <code>bytes</code> into a field element ; <code>bytes</code> length can …\nConverts each chunk of size <code>F::MODULUS_BIT_SIZE / 8</code> from …\nConverts each chunk of size <code>F::size_in_bytes()</code> from <code>bytes</code> …\nSame as encode_as_field_elements, but the returned vector …\nNon-relaxed instance attesting to <code>d * q - a = 0</code>\nNon-relaxed witness contains evaluations (field vectors) …\nThe proof attesting to the validity of the relaxed …\nRelaxed instance variant, attesting to …\nRelaxed witness extends the non-relaxed witness with …\nEvaluation of answer polynomial at the required challenge …\nThis function checks if the provided instance is valid …\nCommitment to the answers\nCommitment to the data\nCommitment to the error term for folding\nCommitment to the query polynomial\nNon-relaxed part\nEvaluation of data polynomial at the required challenge …\nEvaluation of error polynomial at the required challenge …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPolynomial commitment’s proof for the validity of …\nEvaluation of query polynomial at the required challenge …\nCommitment of quotient polynomial T (aka t_comm)\nHomogeneization term for folding\nGenerates a random core instance and witness\nGenerates a relaxed instance and witness. Note that the …\nAnswer to a query regarding some data\nIndexes of the data to be read ; this will be stored …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates a random query, the proportion of indexes …\nComputes the commitment to the query from its sparse form, …\nChecks that the provided answer is consistent with the …\nReturns a new data corresponding to the provided data with …\nModifies inplace the provided data with <code>diff</code>\nReturns the argument unchanged.\nCreates a file at <code>path</code> and fill it with <code>data</code> TODO: For …\nCalls <code>U::from(self)</code>.\nReturns the length of the data\nReturns the data correpsonding to the provided <code>bytes</code>\n<code>read(path)</code> loads the whole content of the file in <code>path</code> and …\nCommit a <code>data</code> of length smaller than <code>SRS_SIZE</code> If greater …\nReturns the polynomial that correspond to the data. If the …\nTakes a valid diff and update the file accordingly, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents the bytes a user query\nRepresents a query in term of Field element\nFor commitments C_i and randomness r, returns ∑ r^i C_i.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")