searchState.loadedDescShard("arrabbiata", 0, "The maximum number of bits the fields can be. It is …\nThe maximum degree of the polynomial that can be …\nThe minimum SRS size required to use Nova, in base 2.\nThe arity of the multivariate polynomials describing the …\nThe maximum number of columns that can be used in the …\nThe number of gadgets supported by the program\nDefine the number of values we must absorb when …\nThe number of rows the verifier circuit requires.\nThis file defines a trait similar to …\nThe final decider, i.e. the SNARK used on the accumulation …\nThis module contains the implementation of the IVC scheme …\nThis file will implement a logup argument to allow users …\nThis module defines methods and structures for setting up …\nBoth challenges used in the permutation argument\nUsed to aggregate the constraints describing the relation. …\nUsed to homogenize the constraints and allow the protocol …\nUsed by the accumulation protocol (folding) to perform a …\nBoth challenges used in the permutation argument.\nUsed to aggregate the constraints describing the relation. …\nUsed to homogenize the constraints and allow the protocol …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUsed by the accumulation protocol (folding) to perform a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe gadget defining the app.\nThis enum represents the different gadgets that can be …\nAn iterator over the variants of Gadget\nA dummy gadget, doing nothing. Use for padding.\nThe following gadgets implement the Poseidon hash instance …\nAbsorb [PlonkSpongeConstants::SPONGE_WIDTH - 1] elements …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe parameter a is the coefficients of the elliptic curve …\nDouble the elliptic curve point given by the affine …\nReturns the argument unchanged.\nGet all the constraints for the verifier circuit and the …\nGet all the constraints for the verifier circuit, only.\nCalls <code>U::from(self)</code>.\nInverse of a variable\nReturn the corresponding expression regarding the selected …\nRepresents additional information that a curve needs in …\nA human readable name.\nAbsorb a list of curve points into the sponge.\nAbsorb an element of the base field into the sponge.\nCreate a new sponge, with an empty state (i.e. initialized …\nProvides the coefficients for the curve endomorphism, …\nReturns the argument unchanged.\nReturn the coefficients <code>a</code> and <code>b</code> of the equation …\nCalls <code>U::from(self)</code>.\nProvides the coefficient for the curve endomorphism over …\nProvides the sponge params to be used with the other curve.\nProvides the sponge params to be used with this curve.\nCoin a challenge from the sponge. Note that a challenge …\nThis module will be used by the prover to evaluate at a …\nA prover for the folding/accumulation scheme\nA verifier for the folding/accumulation scheme\nFIXME: a proof for the Nova recursive SNARK\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerate a proof. All the information to make a proof is …\nA list of instruction/gadget implemented in the …\nAn abstract interpreter that provides some functionality …\nThis gadget implement the Poseidon hash instance described …\nAbsorb [PlonkSpongeConstants::SPONGE_WIDTH - 1] elements …\nDefine the side of the temporary accumulator. When …\nThe first instruction in the verifier circuit (often …\nThe variable should be seen as a certain object that can …\nAllocate a new variable in the circuit for the current row\nAllocate a new variable in the circuit for the next row\nAssert that the two variables are equal\nAssert that the variable is zero\nFlagged as unsafe as it does require an additional range …\nReturn the folding combiner\nCompute the coefficient λ used in the elliptic curve …\nCompute the x^5 of the given variable\nDouble the elliptic curve point given by the affine …\nFetch an input of the application\nDescribe the control-flow for the verifier circuit.\nLoad the value to absorb at the current step at the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the requested MDS matrix coefficient\nReturn the Poseidon round constants as a constant.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverse of a variable\nCheck if the points given by (x1, y1) and (x2, y2) are …\nLoad the state of the Poseidon hash function into the …\nLoad the affine coordinates of the elliptic curve point …\nBuild the constant one\nReturn the corresponding variable at the given position\nReset the environment to build the next row\nRun the application\nRun an iteration of the IVC scheme\nSave the state of poseidon into the environment\nSave temporary accumulators into the environment\nCompute the square a field element\nSet the value of the variable at the given position for …\nBuild the constant zero\nAn indexed relation is a structure that contains all the …\nThe application size, i.e. the number of rows per …\nThe description of the program, in terms of gadgets. For …\nThe constraints given as multivariate polynomials using …\nDomain for Fp\nDomain for Fq\nReturns the argument unchanged.\nInitial state of the sponge, containing circuit specific …\nCalls <code>U::from(self)</code>.\nCommitments to the selectors used by both circuits\nSRS for the first curve\nSRS for the second curve\nAn environment is used to contain the state of a long “…\nA running program that the (folding) interpreter has …\nAbsorb the last committed program state in the correct …\nAbsorb the last committed program state in the correct …\nThe blinder used to commit, to avoid committing to the …\nAccumulate the committed state by adding the last …\nAccumulate the committed state by adding the last …\nAccumulate the program state (or in other words, the …\nAccumulate the program state (or in other words, the …\nList of the accumulated challenges over time.\nCommitments to the accumulated program state.\nAccumulated witness for the program state.\nFlagged as unsafe as it does require an additional range …\nWhile folding, we must keep track of the challenges the …\nSimulate an interaction with the verifier by requesting to …\nSimulate an interaction with the verifier by requesting to …\nFIXME: check if we need to pick the left or right sponge\nCommit to the program state and updating the environment …\nCommit to the program state and updating the environment …\nCompute the output of the application on the previous …\nKeep the current executed instruction. This can be used to …\nThe current iteration of the IVC.\nCurrent processing row. Used to build the witness.\nDouble the elliptic curve point given by the affine …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIndex of the values to absorb in the sponge\nThe index of the latest allocated variable in the circuit. …\nThe index of the latest allocated public inputs in the …\nThe relation this witness environment is related to.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverse of a variable\nThe digest of the program state after executing the last …\nThe digest of the program state before executing the last …\nNext row in the execution trace. It is useful when we deal …\nChallenges during the last computation. This field is …\nCommitments to the previous program states.\nProgram state for curve E1\nProgram state for curve E2\nSponge state used by the prover for the current iteration.\nThe coin folding combiner will be used to generate the …\nReset the environment to build the next row\nReset the environment to build the next iteration\nThe sponges will be used to simulate the verifier …\nState of the current row in the execution trace\nTemporary registers for elliptic curve points in affine …\nSponge state used by the verifier for the current …\nThe witness of the current instance of the circuit. The …\nInitial input\nCurrent input")