searchState.loadedDescShard("kimchi", 0, "Kimchi\nThis module implements an abstraction to keep track of the …\nAuto clone macro - Helps make constraints more readable by …\nThis module contains a useful trait for recursion: …\nThis module implements the <code>ProverError</code> type.\nThis module implements the linearization.\nHandy macro to return the filename and line number of a …\nThis type and logic only exists for the OCaml side. As we …\nTo prover and verify proofs you need a Structured Reference\nThis module implements the data structures of a proof.\nThis module implements prover’s zk-proof primitive.\nThis module implements the prover index as <code>ProverIndex</code>.\nMacro to simplify creation of layout map\nMacro to simplify mapping of layout variable\nThis module implements zk-proof batch verifier …\nThis module implements the verifier index as <code>VerifierIndex</code>.\nThis type can be used to create a mapping between powers …\nWrapper around an iterator that warns you if not consumed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis function allows us to retrieve the powers of alpha, …\nReturns a range of exponents, for a given ArgumentType, …\nInstantiates the ranges with an actual field element <code>alpha</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRegisters a new ArgumentType, associating it with a number …\nThis function can be called before any call to a kimchi …\nGiven a filename with encoded (witness, runtime table, …\nProduces a proof\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis will create a context that allows for benchmarks of …\nAn argument is simply a number of constraints, which we …\nThis module defines the particular form of the expressions …\nThis module implements Plonk circuit constraint primitive.\nThis contains the DomainConstantEvaluations which is used …\nThis module describes the evaluation domains that can be …\nThis module implements Plonk constraint gate primitive.\nThis module implement the lookup argument. See …\nThis module implements Plonk prover polynomials primitive.\nThis module implements Plonk prover polynomial evaluations …\nThis module implements Plonk circuit gate wires primitive.\nThe type of constraints that this will produce. This is …\nThe interface for a minimal argument implementation.\nArgument environment data for constraints of field elements\nThe argument environment is used to specify how the …\nA constraint type represents a polynomial that will be …\nWitness data for an argument\nThe number of constraints created by the argument.\nGates in the PLONK constraint system. As gates are …\nThe lookup argument\nThe permutation argument\nCoefficient value at index idx\nChunk of consecutive coefficients in an interval [from, to)\nGate coefficients\nReturns constraints safely combined via the passed …\nConstant value (see ConstantExpr for supported constants)\nConstants\nConstraints for this argument\nReturns the set of constraints required to prove this …\nInitialize the environment for creating constraints of …\nWitness for current row\nInitialize the environment for creating Expr constraints …\nHelper to access endomorphism coefficient constant\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper to access maximum distance separable matrix …\nWitness for next row\nWitness cell (row, col)\nWitness rows\nWitness cell on current row\nWitness cells in current row in an interval [from, to)\nWitness cell on next row\nWitness cells in next row in an interval [from, to)\nUsed to combine constraints\nThe challenge terms used in Berkeley.\nThe first challenge used in the permutation argument\nA type representing the variables involved in the …\nAn alias for the intended usage of the expression type in …\nThe collection of polynomials (all in evaluation form) and …\nThe second challenge used in the permutation argument\nA challenge used to columns of a lookup table\nThe polynomials specific to the lookup argument.\nThe lookup aggregation polynomials.\nThe challenge α from the PLONK IOP.\nThe challenge β from the PLONK IOP.\nChallenges from the IOP.\nThe coefficient column polynomials\nConvenience function to create a constant as Expr.\nConstant values required\nThe domains used in the PLONK argument.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe challenge γ from the PLONK IOP.\nHandy function to quickly create an expression for a gate.\nThe index selector polynomials.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe challenge joint_combiner which is used to combine …\nThe value <code>prod_{j != 1} (1 - omega^j)</code>, used for efficiently\nLookup specific polynomials\nThe evaluations of the optional runtime selector …\nThe evaluations of the optional runtime table.\nThe lookup-type selector polynomials.\nThe sorted lookup table polynomials.\nThe evaluations of the combined lookup table polynomial.\nThe polynomial that vanishes on the zero-knowledge rows …\nHelper function to quickly create an expression for a …\nThe witness column polynomials\nSame as witness but for the current row.\nSame as witness but for the next row.\nThe permutation aggregation polynomial.\nThe polynomials representing columns, in evaluation form. …\nA specific gate did not verify correctly\nSome connected wires have different values\nThe polynomials representing evaluated columns, in …\nFlags for optional features in the constraint system\nRepresents an error found when verifying a witness with a …\nA public gate was incorrectly connected\nThe default number of chunks in a circuit is one (&lt; 2^16 …\nThe number of rows required for zero knowledge in circuits …\nBuild the ConstraintSystem from a Builder.\ngate coefficients\ncoefficients over domain d8\nEC point addition selector over domain d4\nInitializes the <code>ConstraintSystem&lt;F&gt;</code> on input <code>gates</code> and …\nReturns an instance with all features disabled.\nDisable gates checks (for testing; only enables with …\nDisable gates checks (for testing; only enables with …\nevaluation domains\nendoscalar multiplication selector over domain d8\ncoefficient for the group endomorphism\nEC point addition selector over domain d8\nevaluate witness polynomials over domains\nflags for optional features\ntest helpers\nForeign field addition gate\nForeign field addition gate selector over domain d8\nForeign field multiplication gate\nForeign field multiplication gate selector over domain d8\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ncircuit gates\ngeneric gate selector\ngeneric selector over domain d4\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet up the lookup tables. If not invoked, it is <code>vec![]</code> by …\nlookup constraint system\nLookup features\nscalar multiplication selector over domain d8\npermutation coefficients\npermutation coefficients over domain d8\nposeidon gate selector\nposeidon selector over domain d8\nSet up the number of previous challenges, used for …\nnumber of previous evaluation challenges, for recursive …\nSet up the number of public inputs. If not invoked, it …\nnumber of public inputs\nRangeCheck0 gate\nRangeCheck0 gate selector over domain d8\nRangeCheck1 gate\nRangeCheck1 gate selector over domain d8\nROT gate\nRot gate selector over domain d8\nSet up the runtime tables. If not invoked, it is <code>None</code> by …\nCreate selector polynomial for a circuit gate\nSet up the shared precomputations. If not invoked, it is …\nwire coordinate shifts\nSID polynomial\nXOR gate\nXor gate selector over domain d8\nThis function computes a strict lower bound in the number …\npre-computed polynomials that depend only on the chosen …\n0-th Lagrange evaluated over domain.d4\n0-th Lagrange evaluated over domain.d8\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nzero-knowledge polynomial over domain.d8\n1-st Lagrange evaluated over domain.d8\nthe polynomial that vanishes on the zero-knowledge rows …\nThe different multiplicaive domain sizes that can be used …\nCreates 4 evaluation domains <code>d1</code> (of size <code>n</code>), <code>d2</code> (of size <code>2n</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe Challenge term that contains an alpha. Is used to make …\nA cache\nA key for a cached value\nThe generic type of column the environment can use. In …\nDefine the constant terms an expression can use. It can be …\nThe collection of constants required to evaluate an <code>Expr</code>.\nAn multi-variate polynomial over the base ring <code>C</code> with …\nThe feature flags that can be used to enable or disable …\nA “linearization”, which is linear combination with <code>E</code> …\nEnabled if the number of lookups per row is at least the …\nFor efficiency of evaluation, we compile expressions to …\nSkip the given number of tokens if the feature is enabled.\nSkip the given number of tokens if the feature is disabled.\nEnabled if the table width is at least the given number\nUnnormalizedLagrangeBasis(i) is (x^n - 1) / (x - omega^i)\nA type representing a variable which can appear in a …\nObtains the representation of some constants as a literal. …\nAuto clone macro - Helps make constraints more readable by …\nConvenience function for constructing cell variables.\nConvenience function for constructing cell variables.\nThe column of this variable\nDefines the domain over which the column is evaluated\nCombines multiple constraints <code>[c0, ..., cn]</code> into a single …\nCombines multiple constraints <code>[c0, ..., cn]</code> into a single …\nConvenience function for constructing constant expressions.\nConvenience function for constructing constant expressions.\nA number of useful constraints\nReturn the degree of the expression. The degree of a cell …\nReturn the degree of the expression. The degree of a cell …\nThe endomorphism coefficient\nEvaluate an expression into a field element.\nEvaluate an expression as a field element against an …\nEvaluate an expression into a field element.\nEvaluate an expression as a field element against an …\nEvaluate an RPN expression to a field element.\nEvaluate an expression as a field element against the …\nEvaluate an expression as a field element against the …\nEvaluate the constant expressions in this expression down …\nEvaluate the constant expressions in this expression down …\nEvaluate the constants in a linearization with …\nCompute the polynomial corresponding to this expression, …\nCompute the polynomial corresponding to this expression, …\nCompute the polynomial corresponding to this expression, …\nCompute the polynomial corresponding to this expression, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the challenges, coined by the verifier.\nReturn the evaluation of the given column, over the domain.\nReturn the constants parameters that the expression might …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes <code>prod_{j != n} (1 - omega^j)</code> Assure we don’t …\nReturn the value <code>prod_{j != 1} (1 - omega^j)</code>, used for …\nConverts the expression in LaTeX\nConverts the expression in LaTeX\nThere is an optimization in PLONK called “linearization…\nThere is an optimization in PLONK called “linearization…\nConvenience function for constructing expressions from …\nConvenience function for constructing expressions from …\nApply a function to all the coefficients in the …\nThe MDS matrix\nConverts the expression in OCaml code Recursively print …\nConverts the expression in OCaml code\nConverts the expression in OCaml code\nExponentiate a constant expression.\nYou can import this module like …\nThe row (Curr of Next) of this variable\nRecursively print the expression, except for the cached …\nCompile an expression to an RPN expression.\nCompile an expression to an RPN expression.\nGiven a linearization and an environment, compute the …\nGiven a linearization and an environment, compute the …\nEvaluate the given constant expression to a field element.\nEvaluate the given constant expression to a field element.\nThe number of zero-knowledge rows\nThis trait defines a common arithmetic operations interface\nCreates a constraint to enforce that b is either 0 or 1.\nConstrain to boolean\nCache item\nCoefficient\nlo + mi * 2^{LIMB_BITS}\nCreate a constant\nCrumb constraint for 2-bit value x\nConstrain to crumb (i.e. two bits)\nDouble the value\nCreate a literal\nRaise the value to the given power\nCompute the square of this value\n2^pow\n2^{2 * LIMB_BITS}\n2^{3 * LIMB_BITS}\n2^{LIMB_BITS}\nCairo\nA circuit is specified as a public input size and a list …\nA single gate in a circuit.\nGate error\nGate result\nComplete EC addition in Affine form\nTrait to connect a pair of cells in a circuit\nInvalid constraint with number\nDisconnected wires\nA row accessible from a given row, corresponds to the fact …\nEC variable base scalar multiplication with group …\nGate for computing the scalar corresponding to an …\nContains the error value\nFailed to get witness for row\nThe different types of gates the system supports. Note …\nGeneric arithmetic gate\nInvalid constraint\nInvalid lookup\nContains the success value\nPoseidon permutation gate\nRange check\nEC variable base scalar multiplication\nInvalid wire column\nZero gate\npublic selector polynomials that can used as handy …\nConnects a generic gate cell with zeros to a given row for …\nConnect the pair of cells specified by the cell1 and cell2 …\nConnects the wires of the range checks in a single foreign …\nThis function creates a <code>CairoClaim</code> gate\nThis function creates a <code>CairoFlags</code> gate\nGadget generator of the whole cairo circuits from an …\nThis function creates a <code>CairoInstruction</code> gate\nThis function creates a <code>CairoTransition</code> gate\nCreate foreign field addition gate chain without range …\nCreate range check gate for constraining compact limbs. …\nCreate foreign field multiplication gate Inputs the …\nThis allows you to create two generic gates that will fit …\nThis allows you to create two generic gates by passing the …\nCreate range check gate for constraining three 88-bit …\n…\nCreate single range check gate Inputs the starting row …\nCreate one rotation Right now it only creates a Generic …\nCreates a Rot64 gadget to rotate a word It will need:\nCreate a single foreign field addition gate. This is used …\nCreates a XOR gadget for <code>bits</code> length\nExtends an AND gadget for <code>bytes</code> length. The full operation …\nExtend a chain of foreign field addition gates. It already …\nCreate foreign field muti-range-check gadget by extending …\nCreate foreign field multiplication gate by extending the …\nCreate foreign field muti-range-check gadget by extending …\nExtends a NOT gadget for <code>bits</code> length using Xor gates. It …\nExtends a bitwise negation gadget with <code>n</code> NOT components of …\nCreate foreign field range-check gate by extending the …\nExtend one rotation Right now it only creates a Generic …\nExtend a single foreign field addition gate followed by a …\nExtends a XOR gadget for <code>bits</code> length to a circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhich lookup-patterns should be applied on which rows.\nround constant that are relevant for this specific gate\nCompute the offset corresponding to the <code>CurrOrNext</code> value.\ntype of the gate\nThis function verifies the consistency of the wire …\nverifies that the Cairo gate constraints are solved by the …\nCheck the correctness of witness values for a complete-add …\nVerify the <code>EndoMul</code> gate.\nVerify the <code>EndoMulscalar</code> gate.\nverifies that the generic gate constraints are solved by …\nChecks if a witness verifies a poseidon gate\nVerify the <code>GateType::VarBaseMul</code>(TODO)\nVerify the witness against the constraints\ngate wiring (for each cell, what cell it is wired to)\nthis function creates “empty” circuit gate\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRuntime tables are tables (or arrays) that can be produced …\nNumber of constraints produced by the argument.\nConfiguration for the lookup constraint. These values are …\nComputes the aggregation polynomial for maximum n lookups …\nSpecifies the lookup constraints as expressions.\nA placeholder value that is known to appear in the lookup …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInformation about the specific lookups used\nComputes the sorted lookup tables required by the lookup …\nChecks that all the lookup constraints are satisfied.\nPad with zeroes and then add 3 random elements in the last …\nRepresents an error found when computing the lookup …\nLookup selectors\nConfiguration for the lookup constraint.\nCreate the <code>LookupConstraintSystem</code>.\nForeign field multiplication pattern lookup selector\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLookup pattern lookup selector\nLookup selectors: For each kind of lookup-pattern, we have …\nLookup tables\nRange check pattern lookup selector\nAn optional runtime table selector. It is 0 everywhere, …\nThe offset of the runtime table within the concatenated …\nOptional runtime tables, listed as tuples <code>(length, id)</code>.\nTable IDs for the lookup values. This may be <code>None</code> if all …\nXOR pattern lookup selector\nLook up the value from the given fixed table ID\nA spec for checking that the given vector belongs to a …\nA spec for checking that the given vector belongs to a …\nA concrete value or representation of a lookup.\nA position in the circuit relative to a given row.\nDescribes the desired lookup configuration.\nAn iterator over the variants of LookupPattern\nFlags for each of the hard-coded lookup patterns.\nThe table ID associated with a particular lookup\nLook up a single value in a lookup table. The value may be …\nLook up the value in the table with ID given by the value …\nFor each row in the circuit, which lookup-constraints …\nCreate the default lookup configuration.\nEvaluate the combined value of a joint-lookup.\nEvaluate the linear combination specifying the lookup …\nEvaluate the combined value of a joint-lookup.\nEvaluate the combined value of a joint-lookup, resolving …\nThe features enabled for this lookup configuration\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the lookup pattern used by a <code>GateType</code> on a given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether joint lookups are used\nCheck what kind of lookups, if any, are used by this …\nReturns the layout of the lookups used by this pattern.\nReturns the maximum number of values that are used in any …\nThe maximum joint size of any joint lookup in a constraint …\nReturns the maximum number of lookups per row that are …\nThe maximum length of an element of <code>kinds</code>. This can be …\nA single lookup constraint is a vector of lookup …\nReduce linear combinations in the lookup entries to a …\nEach entry in <code>kinds</code> has a corresponding selector …\nReturns the lookup table used by the pattern, or <code>None</code> if …\nThe ID for the table associated with this lookup. Positive …\nThe ID for the table associated with this lookup. Positive …\nThe ID for the table associated with this lookup. Positive …\nTrue if runtime lookup tables are used.\nLinear combination of local-positions\nA runtime table. Runtime tables must match the …\nUse this type at setup time, to list all the runtime …\nThe specification of a runtime table.\nReturns the constraints related to the runtime tables.\nA single column.\nThe content of the first column of the runtime table.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the ID of the runtime table.\nThe table ID.\nThe table ID.\nThe table id.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the runtime table is empty.\nReturns the length of the runtime table.\nThe number of entries contained in the runtime table.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnumerates the different ‘fixed’ lookup tables used by …\nEnumerates the different ‘fixed’ lookup tables used by …\nA table of values that can be used for a lookup, along …\nThe range check table ID.\nThe table ID associated with the XOR lookup table.\nSame as <code>combine_table_entry</code>, but for an entire table. The …\nLet’s say we want to do a lookup in a “vector-valued”…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the lookup table associated to a <code>GateLookupTable</code>.\nReturn true if the table has an entry (row) containing all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the lookup table is empty, <code>false</code> otherwise.\nReturns the length of the table.\nRange check table\nReturns the lookup table associated to a <code>GateLookupTable</code>.\nReturns the number of columns, i.e. the width of the table.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe range check will be performed on 12-bit values, i.e. …\nA single-column table containing the numbers from 0 to …\nReturns the XOR lookup table\nEvaluations of the wires and permutation\nevaluations over domain d4\nevaluations over domain d8\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nlookup multiset\nlookup multiset\nlookup multiset\nlookup multiset\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\naggregation\naggregation\nlookup witness\nlookup witness\nnext wire evaluations\nnext wire evaluations\nthis wire evaluations\nthis wire evaluations\nwire evaluations\npermutation evaluations\nThis module includes the AND gadget implementation and the …\nThis module implements a complete EC addition gate.\nImplementation of the <code>EndomulScalar</code> gate for the endomul …\nThis module implements short Weierstrass curve …\nForeign Field Addition module\nCommon parameters and functions for kimchi’s foreign …\nForeign field multiplication module\nThis module implements the double generic gate.\nKeccak hash module\nThis module includes the definition of the NOT gadget and …\nThis module implements permutation constraint polynomials.\nThis module implements the Poseidon constraint polynomials.\nRange check gate module\nThis implements the constraints of the Cairo gates\nThis module implements short Weierstrass curve variable …\nThis module includes the definition of the XOR gadget for …\nCreate a And for inputs as field elements starting at row 0\nExtends an AND witness to the whole witness Input: first …\nGet the AND lookup table\nImplementation of the <code>CompleteAdd</code> gate It uses the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nGenerate the <code>witness</code>\nCalls <code>U::from(self)</code>.\nThe result of performing an endoscaling: the accumulated …\nImplementation of the <code>EndosclMul</code> gate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates the <code>witness_curr</code> values for a series of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForeign field addition gate.\nThis module obtains the gates of a foreign field addition …\nThis module computes the witness of a foreign field …\nImplementation of the foreign field addition gate\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAddition\nAll foreign field operations allowed\nSubtraction\nCreates a FFAdd witness (including <code>ForeignFieldAdd</code> rows, …\nCreate witness for bound computation addition gate\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the sign of the operation as a field element\nExponent of binary modulus (i.e. t)\nBigUint array compose helper\nBigUint array PrimeField helpers\nForeign field helpers\nPrimeField array BigUint helpers\nPrimeField array compact limbs\nPrimeField array compose BigUint\nIndex of high limb (in 3-limb foreign elements)\nLimb length for foreign field elements\nNumber of desired limbs for foreign field elements\nIndex of low limb (in 3-limb foreign elements)\nIndex of middle limb (in 3-limb foreign elements)\nTwo to the power of the limb length\n2^t\nCompose field limbs into BigUint\nCompose limbs into BigUint\nlimbs in little endian order\n2^259 (see foreign field multiplication RFC)\nNegate: 2^T - self\nAlias for to_limbs\nConvert to 2 PrimeField limbs of 2 * LIMB_BITS each. The …\nConvert to 2 limbs of 2 * LIMB_BITS each. The compressed …\nCompose field limbs into BigUint\nConvert to 3 PrimeField limbs of LIMB_BITS each\nConvert limbs from BigUint to field element\nAlias for to_field_limbs\nConvert to 3 limbs of LIMB_BITS each\nConvert limbs from field elements to BigUint\n2\n2^{2 * LIMB_BITS}\n2^{LIMB_BITS}\nForeign field multiplication\nThis module obtains the gates of a foreign field addition …\nForeign field multiplication witness computation\nThis gate operates on the Curr and Next rowsIt uses copy, …\nComposes the 91-bit carry1 value from its parts\nCompute non-zero intermediate products\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of gates in this gadget\nNumber of constraints for a given foreign field mul …\nGet combined constraints for a given foreign field …\nGet vector of foreign field multiplication circuit gate …\nGet the combined constraints for all foreign field …\nGet the foreign field multiplication lookup table\nTrack external check witness data\nTrack a bound check\nTrack a compact-multi-range-check\nTrack a high bound computation\nTrack a limb-range-check\nTrack a multi-range-check\nPerform integer bound addition for all limbs x’ = x + f…\nPerform integer bound computation for high limb x’2 = x2 …\nCreate a foreign field multiplication witness Input: …\nExtend the witness with external bound addition as foreign …\nExtend the witness with external compact multi range_checks\nExtend the witness with external high bounds additions as …\nExtend the witness with external compact multi range_checks\nExtend the witness with external multi range_checks\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAdd two values.\nNumber of constraints produced by the gate.\nA constant, the constructor contains the constant itself\nThe double generic gate actually contains two generic …\nNumber of generic of registers by a double generic gate.\nNumber of coefficients used by a single generic gate Three …\nNumber of generic of registers by a single generic gate\nImplementation of the <code>Generic</code> gate\nThe different type of computation that are possible with a …\nMultiplication of two values\nSum a value to a constant\nA public gate\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOptional coefficient that can be multiplied with the left …\nOptional coefficient that can be multiplied with the …\nOptional coefficient that can be multiplied with the …\nOptional coefficient that can be multiplied with the …\nOptional coefficient that can be multiplied with the right …\nCreate a generic circuit\nFill in a witness created via <code>create_circuit</code>\nNaive Keccak structure\nCreates the 5x5 table of rotation bits for Keccak modulo 64\nContains the 24 round constants for Keccak\nOn input a vector of 16-bit dense quarters, outputs a …\nFrom a canonical expanded state, obtain the corresponding …\nComposes a vector of 4 dense quarters into the dense full …\nTakes a dense u64 word and decomposes it into a vector of …\nExpands a quarter of a word into the sparse representation …\nOn input a 200-byte vector, generates a vector of 100 …\nExpands a u64 word into a vector of 4 sparse u64 quarters\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of blocks to be absorbed on input a given preimage …\nPads the message with the 10*1 rule until reaching a …\nOn input a length, returns the smallest multiple of …\nOutputs the state into dense quarters of 16-bits each in …\nFrom a vector of shifts, resets the underlying value …\nFrom each quarter in sparse representation, it computes …\nReturns the expansion of the 4 dense decomposed quarters …\nKeccak witness computation\nThe number of bytes used as a capacity in the sponge.\nConstants for each witness’ index offsets and lengths …\nThe number of columns the Keccak circuit uses.\nAn element of the Keccak state is 64 bits. However, we …\nThe number of bytes that can be processed by the Keccak …\nThe number of rounds in the Keccak permutation\nThe number of columns the Sponge circuit uses.\nThe number of field elements used to represent the whole …\nValues involved in Chi permutation step\nValues involved in Iota permutation step\nValues involved in PiRho permutation step\nValues involved in Theta permutation step\nCreates a witness for the Keccak hash function Input:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtend a NOT witness for less than 255 bits (native field) …\nExtends negation witnesses from generic gate, assuming the …\nNumber of constraints produced by the argument.\nShifts represent the shifts required in the permutation …\nEvaluates the polynomial (x - w^{n - zk_rows}) * (x - w^{n …\nEvaluates the polynomial (x - w^{n - i}) * (x - w^{n - i + …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerates the shifts for a given domain\nThe polynomial (x - w^{n - zk_rows}) * (x - w^{n - zk_rows …\nretrieve the shifts\nThe polynomial (x - w^{n - i}) * (x - w^{n - i + 1}) * … …\nReturns the end of the circuit, which is used for …\nNumber of PLONK rows required to implement Poseidon\nImplementation of the Poseidon gate Poseidon quotient poly …\nNumber of rounds\nNumber of rows\nWidth of the sponge\nThe order in a row in which we store states before and …\nReturns the argument unchanged.\n<code>generate_witness(row, params, witness_cols, input)</code> uses a …\nCalls <code>U::from(self)</code>.\nGiven a Poseidon round from 0 to 4 (inclusive), returns …\nRange check gate\nRange check witness computation\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of constraints for a given range check circuit gate …\nGet combined constraints for a given range check circuit …\nGet vector of range check circuit gate types\nGet the combined constraints for all range check circuit …\nGet the range check lookup table\nCreate a single range check witness Input: 88-bit value v0\nCreate a multi range check witness from three 88-bit …\nCreate a multi range check witness from two limbs: v01 …\nCreate a multi range check witness from compact limbs\nCreate a multi range check witness from limbs\nExtend an existing witness with a single range check …\nExtend an existing witness with a multi-range-check gadget …\nExtend and existing witness with a multi range check …\nExtend an existing witness with a multi-range-check gadget …\nExtend an existing witness with a multi-range-check gadget …\nExtend an existing witness with a multi-range-check gadget …\nExtend an existing witness with a single-range-check gate …\nThe row layout for <code>RangeCheck0</code>\nExtends the rot rows to the full witness Input\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the rot lookup table\nCombines the constraints for the Cairo gates depending on …\nGenerates the constraints for the Cairo initial claim and …\nGenerates the constraints for the Cairo instruction …\nGenerates the constraints for the Cairo flags Accesses …\nGenerates the constraints for the Cairo transition …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nverifies that the Cairo gate constraints are solved by the …\nReturns the witness of an execution of a Cairo program in …\nImplementation of the <code>VarbaseMul</code> gate\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApply the <code>witness</code> value.\nCreate a Xor for up to the native length starting at row 0 …\nExtends the Xor rows to the full witness Panics if the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet the xor lookup table\nReturns the number of XOR rows needed for inputs of usize …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of registers\n<code>GateWires</code> document the wiring of a gate. More …\nNumber of registers that can be wired (participating in …\nindex of all registers\nSince we don’t have a specific type for the wires of a …\nWire documents the other cell that is wired to this one. …\nCreates a new set of wires for a given row.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new set of wires for a given row.\nCreates a new Wire.\nWire the cell at <code>col</code> to another cell (<code>to</code>).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWitness cell with constant value\nWitness cell copied from bits of another witness cell\nWitness cell copied from another witness cell\nWitness cell copied from another cell and shifted\nWitness cell assigned from an indexable variable See …\nWitness cell assigned from bits of a variable See Variables…\nWitness cell assigned from a variable See Variables for …\nLayout variables mapping - these values are substituted …\nWitness cell interface. By default, the witness cell is a …\nCreate witness cell with constant value\nCreate witness cell copied from bits [start, end) of the …\nCreate a witness cell copied from the witness cell at …\nCreate witness cell copied from the witness cell at …\nCreate witness cell assigned from a variable name a length\nCreate witness cell assigned from the bits [start, end) of …\nCreate witness cell assigned from a variable name\nCreate a layout variable map\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize a witness based on layout and computed variables\nInitialize a witness cell based on layout and computed …\nInitialize a witness row based on layout and computed …\nInsert a variable and corresponding value into the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMacro to simplify creation of layout map\nMacro to simplify mapping of layout variable\nRepresents additional information that a curve needs in …\nA human readable name.\nProvides the coefficients for the curve endomorphism, …\nProvides the coefficient for the curve endomorphism over …\nAccessor for the other curve’s prime subgroup generator, …\nProvides the sponge params to be used with the other curve.\nProvides the sponge params to be used with this curve.\nErrors that can arise when preparing the setup\nErrors that can arise when creating a proof\nErrors that can arise when preparing the setup\nErrors that can arise when creating a verifier index\nErrors that can arise when verifying a proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluations of all normalized lagrange basis polynomials …\nReturn the domain size of the individual evaluations.\nGiven the evaluations form of a polynomial, directly …\nGiven the evaluations form of a polynomial, directly …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet the expresion of constraints.\nLinearize the <code>expr</code>.\nAdds the polynomials that are evaluated as part of the …\nThe result of running the oracle protocol\nthe computed powers of alpha\nUsed by the OCaml side\nthe last evaluation of the Fq-Sponge in this protocol\nA sponge that acts on the base field of a curve\nReturns the argument unchanged.\nThe evaluation f(zeta) - t(zeta) * Z_H(zeta)\nCalls <code>U::from(self)</code>.\nthe challenges produced in the protocol\nrecursion data\nzeta^n and (zeta * omega)^n\npublic polynomial evaluations\npre-computed zeta^n\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAbstracts a sponge that operates on the scalar field of an …\nAbsorbs the field element into the sponge.\nAbsorbs the given evaluations into the sponge.\nAbsorbs a slice of field elements into the sponge.\nCreates a <code>ScalarChallenge</code> by squeezing the sponge.\nConsumes the sponge and returns the current digest, by …\nCreates a new Fr-Sponge.\nThe size of the SRS that we serialize.\nWe store several different types of SRS objects. This enum …\nA clone of the SRS struct that is used for serialization, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe vector of group elements for committing to polynomials …\nObtains an SRS for a specific curve from disk. Panics if …\nGeneric SRS getter fuction.\nObtains a Test SRS for a specific curve from disk. Panics …\nA group element used for blinding commitments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommitments to Lagrange bases, per domain size\nCommitments linked to the lookup feature\nEvaluations of a polynomial at 2 points\nPolynomial evaluations contained in a <code>ProverProof</code>.\nAll the commitments that the prover creates as part of the …\nThe proof that the prover creates from a ProverIndex and a …\nA struct to store the challenges inside a <code>ProverProof</code>\nCommitment to the lookup aggregation polynomial\nVector of scalar field elements\ncoefficient polynomials\nPolynomial commitment\nAll the polynomial commitments required in the proof\nevaluation of the elliptic curve addition selector …\nThis function constructs prover’s zk-proof from the …\nThis function constructs prover’s recursive zk-proof …\nevaluation of the endoscalar multiplication selector …\nevaluation of the endoscalar multiplication scalar …\nTwo evaluations over a number of committed polynomials\nevaluation of the ForeignFieldAdd selector polynomial\nevaluation of the ForeignFieldMul range check pattern …\nevaluation of the ForeignFieldMul selector polynomial\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRequired evaluation for Maller’s optimization\nevaluation of the generic selector polynomial\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommitments related to the lookup argument\nevaluation of lookup aggregation polynomial\nevaluation of the Lookup range check pattern selector …\nevaluation of lookup sorted polynomials\nevaluation of lookup table polynomial\nevaluation of the elliptic curve variable base scalar …\nThis function runs the random oracle argument\nevaluation of the poseidon selector polynomial\nThe challenges underlying the optional polynomials folded …\nbatched commitment opening proof\npublic input polynomials\nevaluation of the RangeCheck0 selector polynomial\nevaluation of the RangeCheck1 selector polynomial\nevaluation of the RangeCheck range check pattern selector …\nevaluation of the Rot selector polynomial\nOptional commitment to concatenated runtime tables\nevaluation of runtime lookup table polynomial\nevaluation of the runtime lookup table selector polynomial\npermutation polynomials (PERMUTS-1 evaluations because the …\nCommitments to the sorted lookup table polynomial (may …\nThe commitment to the quotient polynomial\nwitness polynomials\nThe commitments to the witness (execution trace)\nevaluation of the Xor range check pattern selector …\nevaluation of the Xor selector polynomial\npermutation polynomial\nThe commitment to the permutation polynomial\nEvaluation at the challenge point zeta.\nEvaluation at <code>zeta . omega</code>, the product of the challenge …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nClean up old traces and start fresh.\nTake captured traces.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe index used by the prover\nRetrieve or compute the digest for the corresponding …\nthis function compiles the index from constraints\nconstraints system polynomials\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe symbolic linearization of our circuit, which can …\nmaximal size of polynomial section\npermutation aggregation polynomial computation\npermutation linearization poly contribution computation\npermutation quotient poly contribution computation\nThe mapping between powers of alpha and constraints\npolynomial commitment keys\nProduces the <code>VerifierIndex</code> from the prover’s <code>ProverIndex</code>.\nThe verifier index corresponding to this prover index\nRetrieve or compute the digest for the corresponding …\nThe verifier index digest corresponding to this prover …\nThis function verifies the consistency of the wire …\nFunction to verify the generic polynomials with a witness.\nCreate new index for lookups.\nContains the error value\nContains the success value\nThe result of a proof verification.\nThis function verifies the batch of zk-proofs proofs: …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe proof to verify\nThe public input used in the creation of the proof\nThe VerifierIndex associated to the proof\nVerify a proof <code>ProverProof</code> using a <code>VerifierIndex</code> and a …\ncoefficient commitment array\nEC addition selector polynomial commitment\nCompute the digest of the <code>VerifierIndex</code>, which can be used …\nevaluation domain\nendoscalar multiplication selector polynomial commitment\nendoscalar coefficient\nendoscalar multiplication scalar computation selector …\nForeign field addition gates polynomial commitments\nForeign field multiplication gates polynomial commitments\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes a <code>VerifierIndex</code> from a file, given a pointer …\ncoefficient commitment array\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInformation about the specific lookups used\nmaximal size of polynomial section\nEC variable base scalar multiplication selector polynomial …\nGets permutation_vanishing_polynomial_m from <code>VerifierIndex</code> …\nzero-knowledge polynomial\nThe mapping between powers of alpha and constraints\nnumber of previous evaluation challenges, for recursive …\nposeidon constraint selector polynomial commitment\nnumber of public inputs\nRangeCheck0 polynomial commitments\nRangeCheck1 polynomial commitments\nRot commitments\nAn optional selector polynomial for runtime tables\nwire coordinate shifts\npermutation commitment array\nGets srs from <code>VerifierIndex</code> lazily\npolynomial commitment keys\nTable IDs for the lookup values. This may be <code>None</code> if all …\nWrites a <code>VerifierIndex</code> to a file, potentially appending it …\nGets w from <code>VerifierIndex</code> lazily\ndomain offset for zero-knowledge\nXor commitments\nthe number of randomized rows to achieve zero knowledge")