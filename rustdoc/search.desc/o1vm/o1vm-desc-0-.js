searchState.loadedDescShard("o1vm", 0, "Type to represent a constraint on the individual columns …\nModules mimicking the defined structures used by Cannon …\nA module to load ELF files.\nInstantiation of the lookups for the VM project. …\nPickles flavor of the o1vm. This is the pickles flavor of …\nPreimage oracle interface used by the zkVM.\nThe RAM lookup argument.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn interpreter for an optimised version of Keccak\nAn interpreter for the MIPS instruction set. This module …\nAn interpreter for the RISC-V 32IM instruction set, …\nAll the names for constraints involved in the Keccak …\nErrors that can occur during the check of the witness\nThis module defines the custom columns used in the Keccak …\nThis module contains the constraints for one Keccak step.\nThis module contains the definition and implementation of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module defines the Keccak interpreter in charge of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis function returns a vector of field elements that …\nStandardizes a Keccak step to a common opcode\nThis file contains the witness for the Keccak hash …\nOrder of absorb steps in the computation depending on the …\nAn iterator over the variants of Absorbs\nBlock index inside the hash to enumerate preimage bytes\nColumn aliases used by the Keccak circuit. The number of …\nHash identifier to distinguish inside the syscalls …\nThe witness columns used by the Keccak circuit. The Keccak …\nTotal number of columns used in Keccak, including relation …\nThe maximum total number of witness columns used by the …\nThe number of columns required for the Keccak selectors. …\nCurrent step performs a round of the permutation. The …\nCurrent step is a sponge\nVariants of Keccak sponges\nAn iterator over the variants of Sponges\nHash step identifier to distinguish inside interstep …\nVariants of Keccak steps available for the interpreter. …\nAn iterator over the variants of Steps\nA witness row is represented by an array of N witness …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMap the column alias to the actual column index. Note that …\nMap the column alias to the actual column index. Note that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over the instruction variants\nThis struct contains all that needs to be kept track of …\nConstraints that are added to the circuit\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nVariables that are looked up in the circuit\nThis struct contains all that needs to be kept track of …\nEnvironment for the constraints (includes lookups). The …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStarts a new Keccak environment for a given hash index and …\nNullifies the Witness and Constraint environments by …\nReturns the selector of the current step in standardized …\nEntrypoint for the interpreter. It executes one step of …\nCurrent step\nThis function updates the next step of the environment …\nEnvironment for the witness (includes multiplicities)\nWrites an integer value to a column of the Keccak witness\nWrites a field value to a column of the Keccak witness\nThis trait contains helper functions for arithmetic …\nThis trait contains helper functions for boolean …\nThis trait contains helper functions for the lookups used …\nDegree-2 variable encoding whether at least one of the two …\nDegree-2 variable encoding whether the input is a boolean …\nDegree-2 variable encoding whether the first input is …\nDegree-1 variable encoding whether the input is the value …\nAdds a lookup to the Byte table\nAdds a lookup to the Pad table\nAdds a lookup to the RangeCheck16 table\nAdds a lookup to the Reset table\nAdds a lookup to the RoundConstants table\nAdds a lookup to the Shift table\nDegree-1 variable encoding the negation of the input Note: …\nReturns a variable representing the value one\nDegree-2 variable encoding the OR of two variables, which …\nReturns a variable representing the value two\nReturns a variable representing the value 2^x\nDegree-2 variable encoding the XOR of two variables which …\nReturns a variable representing the value zero\nThis trait includes functionalities needed to obtain the …\nAdds a given Lookup to the environment if the condition …\nThis function returns a degree-2 variable that is computed …\nReturns the block index as a variable\nReturns a variable that encodes the <code>idx</code>-th block of bytes …\nCreates a variable from a constant integer\nCreates a variable from a constant field element\nAdds one KeccakConstraint to the environment if the …\nConstrains 332 checks of absorb sponges\nConstrains 136 checks of booleanity for some mode flags.\nConstrains 200 checks of the chi algorithm in round steps\nConstrains 136 checks of correctness of mode flags\nConstrains 4 checks of the iota algorithm in round steps\nConstrains 6 checks of padding absorb sponges\nConstrains 150 checks of the pirho algorithm in round steps\nConstrains 389 checks of round steps\nConstrains 354 checks of sponge steps\nConstrains 16 checks of squeeze sponges\nConstrains 35 checks of the theta algorithm in round steps\nCreates all 879 constraints/checks to the environment:\nReturns the (x,q)-th term of ThetaDenseC, as a variable\nReturns the (y,x,q)-th variable of PiRhoDenseE\nReturns the (x,q)-th variable of ThetaDenseRotC\nReturns the (y,x,q)-th variable of PiRhoDenseRotE\nReturns the (x,q)-th variable of ThetaExpandRotC\nReturns the (y,x,q)-th variable of PiRhoExpandRotE\nReturns a vector of pad bytes flags as variables, with <code>idx</code> …\nThis function returns the composed variable from dense …\nCOLUMN OPERATIONS /// This function returns the composed …\nReturns the hash index as a variable\nReturns a variable that encodes whether the <code>idx</code>-th byte of …\nReturns the 100 step input variables, which correspond to …\nReturns a slice of the input variables of the current step …\nReturns a variable that encodes whether the current step …\nReturns a degree-1 variable that encodes whether the …\nReturns a variable that encodes whether the current step …\nReturns a variable that encodes whether the current step …\nSELECTOR OPERATIONS /// Returns a degree-2 variable that …\nReturns a variable that encodes whether the current step …\nReads a Lookup containing the input of a step and writes a …\nWhen in Squeeze mode, writes a Lookup containing the …\nWhen in Absorb mode, reads Lookups containing the 136 …\nCreates all possible lookups to the Keccak constraints …\nAdds the 800 lookups required for Chi in the round\nAdds the 1 lookup required for Iota in the round\nAdds the 700 lookups required for PiRho in the round\nAdds the 120 lookups required for Theta in the round\nAdds the 601 lookups required for the sponge\nReturns a variable that encodes whether the current step …\nReturns a degree-1 variable that encodes whether the …\nReturns a variable that encodes whether the current step …\nReturns a degree-1 variable that encodes whether the …\nReturns a variable that encodes whether the current step …\nReturns a variable that encodes whether the current step …\nReturns the <code>idx</code>-th new state expanded quarter, as a …\nReturns the <code>idx</code>-th old state expanded quarter, as a …\nReturns the 100 step output variables, which correspond to …\nReturns a slice of the output variables of the current …\nReturns the 136 flags indicating which bytes of the new …\nReturns a variable that encodes the bytelength of the …\nReturns a variable that encodes the <code>idx</code>-th chunk of the …\nReturns the (x)-th term of ThetaQuotientC, as a variable\nReturns the (y,x,q)-th variable of PiRhoQuotientE\nReturns the (x,q)-th variable of ThetaRemainderC\nReturns the (y,x,q)-th variable of PiRhoRemainderE\nReturns a variable that encodes the current round number […\nReturns the 4 expanded quarters that encode the round …\nReturns the (i,y,x,q)-th variable of ChiShiftsB\nReturns the (i,x,q)-th variable of ThetaShiftsC\nReturns the (i,y,x,q)-th variable of PiRhoShiftsE\nReturns the (i,y,x,q)-th variable of ChiShiftsSum\nReturns the <code>idx</code>-th byte of the sponge, as a variable\nReturns the 200 bytes of the sponge, as variables\nReturns the <code>idx</code>-th term of the shifts of the sponge, as a …\nReturns the last 32 terms that are added to the new block …\nReturns the (y,x,q)-th input of the theta algorithm, as a …\nReturns the <code>idx</code>-th output of a round step as a variable\nReturns the step index as a variable\nReturns a variable that encodes the value 2^pad_length\nReturns the variable corresponding to a given column alias.\nReturns the 20 variables corresponding to ThetaDenseC\nReturns the 100 variables corresponding to PiRhoDenseE\nReturns the 20 variables corresponding to ThetaDenseRotC\nReturns the 100 variables corresponding to PiRhoDenseRotE\nReturns the 20 variables corresponding to ThetaExpandRotC\nReturns the 100 variables corresponding to PiRhoExpandRotE\nReturns the 5 variables corresponding to ThetaQuotientC\nReturns the 100 variables corresponding to PiRhoQuotientE\nReturns the 20 variables corresponding to ThetaRemainderC\nReturns the 100 variables corresponding to PiRhoRemainderE\nReturns the 400 variables corresponding to ChiShiftsB\nReturns the 80 variables corresponding to ThetaShiftsC\nReturns the 400 variables corresponding to PiRhoShiftsE\nReturns the 400 variables corresponding to ChiShiftsSum\nReturns the 400 terms that compose the shifts of the …\nReturns the output of an absorb sponge, which is the XOR …\nThis struct contains all that needs to be kept track of …\nChecks the constraint <code>tag</code> by checking that the input <code>x</code> is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe multiplicities of each lookup entry. Should not be …\nThe fixed tables used in the Keccak gate\nThe full state of the Keccak gate (witness)\nMaximum degree of the constraints. It does include the …\nTotal number of constraints for all instructions, …\nAbstract columns (or variables of our multi-variate …\nRepresents one line of the execution trace of the virtual …\nAll the witness columns used in MIPS\nThe number of columns used for relation witness in the …\nThe number of witness columns used to store the …\nNumber of columns used by the MIPS interpreter to keep …\nA witness row is represented by an array of N witness …\nReturns the argument unchanged.\nMap the column alias to the actual column index.\nMap the column alias to the actual column index.\nCalls <code>U::from(self)</code>.\nThe environment keeping the constraints between the …\nReturns the argument unchanged.\nReturn the constraints for the current instruction, …\nReturn the constraints for the selector. Each selector …\nCalls <code>U::from(self)</code>.\nThis function checks that the preimage is read correctly. …\nAn iterator over the variants of ITypeInstruction\nAn iterator over the variants of Instruction\nAn iterator over the variants of JTypeInstruction\nA position can be seen as an indexed variable\nAn iterator over the variants of RTypeInstruction\nAccess the memory address <code>addr</code>, adding constraints …\nAccess the general purpose register with index <code>idx</code>, adding …\nAccess the general purpose register with index <code>idx</code>, adding …\nActivate the selector for the given instruction.\nAdd a constraint to the proof system, asserting that …\nReturns <code>x + y</code> and the overflow bit, storing the results in …\nAllocate a new abstract variable for the current step. The …\nReturns <code>x or y</code>, storing the result in <code>position</code>.\nAssert that the value <code>x</code> is boolean, and add a constraint …\nAssert that the values <code>x</code> and <code>y</code> are equal, and add a …\nAssert that the value <code>assert_equals_zero</code> is 0, and add a …\nExtract the bits from the variable <code>x</code> between <code>highest_bit</code> …\nCheck that the witness value <code>x</code> is a boolean (<code>0</code> or <code>1</code>); …\nCheck that the witness values in <code>x</code> and <code>y</code> are equal; …\nCheck that the witness value in <code>assert_equals_zero</code> is 0; …\nReturns the number of leading 1s in <code>x</code>, storing the result …\nReturns the number of leading 0s in <code>x</code>, storing the result …\nReturns <code>(x / y, x % y)</code>, storing the results in …\nReturns <code>(x / y, x % y)</code>, storing the results in …\nReturns 1 if <code>x</code> is equal to <code>y</code>, or 0 otherwise, storing the …\nFetch the memory value at address <code>addr</code> and store it in …\nFetch the last ‘access index’ that the memory at …\nFetch the value of the general purpose register with index …\nFetch the last ‘access index’ for the general purpose …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncreases the heap pointer by <code>by_amount</code> if <code>if_is_true</code> is <code>1</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over the instruction variants\nAdds a lookup to the RangeCheck16Lookup table\nAdds a lookup to the AtMost4Lookup table\nAdds a lookup to the ByteLookup table\nReturns <code>((x * y) &gt;&gt; 32, (x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, …\nReturns <code>((x * y) &gt;&gt; 32, (x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, …\nReturns <code>x * y</code>, where <code>x</code> and <code>y</code> are treated as integers, …\nReturns <code>x nor y</code>, storing the result in <code>position</code>.\nReturns <code>x or y</code>, storing the result in <code>position</code>.\nSet the memory value at address <code>addr</code> to <code>value</code>.\nSet the last ‘access index’ for the memory at address …\nSet the general purpose register with index <code>idx</code> to <code>value</code>.\nSet the last ‘access index’ for the general purpose …\nSet the last ‘access index’ for the general purpose …\nSet the general purpose register with index <code>idx</code> to <code>value</code> …\nRange checks with 2 lookups to the RangeCheck16Lookup …\nRange checks with 1 lookup to the AtMost4Lookup table 0 &lt;= …\nRange checks with 2 lookups to the ByteLookup table that a …\nRequest the preimage oracle for <code>len</code> bytes and store the …\nReset the environment to handle the next instruction\nReturn the result of shifting <code>x</code> by <code>by</code>, storing the result …\nReturn the result of shifting <code>x</code> by <code>by</code>, storing the result …\nReturn the result of shifting <code>x</code> by <code>by</code>, storing the result …\nGiven a variable <code>x</code>, this function extends it to a signed …\nReturns <code>x + y</code> and the underflow bit, storing the results …\nReturns 1 if <code>x &lt; y</code> as unsigned integers, or 0 otherwise, …\nReturns 1 if <code>x &lt; y</code> as signed integers, or 0 otherwise, …\nReturns 1 if <code>x</code> is 0, or 0 otherwise, storing the result in …\nReturns <code>x xor y</code>, storing the result in <code>position</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis represents the internal state of the virtual machine.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis structure represents the environment the virtual …\nMaximum number of memory or register accesses per …\nMaximum number of memory accesses per instruction (based …\nMaximum number of register accesses per instruction (based …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes what is the non-normalized next instruction …\nThe actual number of instructions executed results from …\nExecute a single step of the MIPS program. Returns the …\nNumber of instructions in the ISA\nThe minimal number of columns required for the VM\nList all columns used by the interpreter\nThis module implement an interpreter for the RISCV32 IM …\nAll the registers used by the ISA\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturn the constraints for the current instruction, …\nReturn the constraints for the selector. Each selector …\nCalls <code>U::from(self)</code>.\nFormat: <code>add rd, rs1, rs2</code>\nFormat: <code>addi rd, rs1, imm</code>\nFormat: <code>auipc rd,imm</code>\nFormat: <code>and rd, rs1, rs2</code>\nFormat: <code>andi rd, rs1, imm</code>\nFormat: <code>beq rs1, rs2, offset</code>\nFormat: <code>bge rs1, rs2, offset</code>\nFormat: <code>bgeu rs1, rs2, offset</code>\nFormat: <code>blt rs1, rs2, offset</code>\nFormat: <code>bltu rs1, rs2, offset</code>\nFormat: <code>bne rs1, rs2, offset</code>\nFormat: <code>div rd, rs1, rs2</code>\nFormat: <code>divu rd, rs1, rs2</code>\nFormat: <code>fence</code>\nFormat: <code>fence.i</code>\nAn iterator over the variants of IInstruction\nAn iterator over the variants of Instruction\nFormat: <code>jal rd,imm</code>\nFormat: <code>jalr rd, rs1, imm</code>\nFormat: <code>lb rd, offset(rs1)</code>\nFormat: <code>lbu rd, offset(rs1)</code>\nFormat: <code>lh rd, offset(rs1)</code>\nFormat: <code>lhu rd, offset(rs1)</code>\nFormat: <code>lui rd,imm</code>\nFormat: <code>lw rd, offset(rs1)</code>\nM extension instructions Following …\nAn iterator over the variants of MInstruction\nFormat: <code>mul rd, rs1, rs2</code>\nFormat: <code>mulh rd, rs1, rs2</code>\nFormat: <code>mulhsu rd, rs1, rs2</code>\nFormat: <code>mulhu rd, rs1, rs2</code>\nFormat: <code>or rd, rs1, rs2</code>\nFormat: <code>ori rd, rs1, imm</code>\nA position can be seen as an indexed variable\nAn iterator over the variants of RInstruction\nFormat: <code>rem rd, rs1, rs2</code>\nFormat: <code>remu rd, rs1, rs2</code>\nAn iterator over the variants of SBInstruction\nAn iterator over the variants of SInstruction\nFormat: <code>slt rd, rs1, rs2</code>\nFormat: <code>slti rd, rs1, imm</code>\nFormat: <code>sltiu rd, rs1, imm</code>\nFormat: <code>sltu rd, rs1, rs2</code>\nFormat: <code>sll rd, rs1, rs2</code>\nFormat: <code>slli rd, rs1, shamt</code>\nFormat: <code>sra rd, rs1, rs2</code>\nFormat: <code>srai rd, rs1, shamt</code>\nFormat: <code>srl rd, rs1, rs2</code>\nFormat: <code>srli rd, rs1, shamt</code>\nFormat: <code>sb rs2, offset(rs1)</code>\nFormat: <code>sh rs2, offset(rs1)</code>\nFormat: <code>sw rs2, offset(rs1)</code>\nFormat: <code>sub rd, rs1, rs2</code>\nAn iterator over the variants of SyscallInstruction\nAn iterator over the variants of UInstruction\nAn iterator over the variants of UJInstruction\nFormat: <code>xor rd, rs1, rs2</code>\nFormat: <code>xori rd, rs1, imm</code>\nAccess the memory address <code>addr</code>, adding constraints …\nAccess the general purpose register with index <code>idx</code>, adding …\nAccess the general purpose register with index <code>idx</code>, adding …\nActivate the selector for the given instruction.\nAdd a constraint to the proof system, asserting that …\nReturns <code>x + y</code> and the overflow bit, storing the results in …\nAllocate a new abstract variable for the current step. The …\nReturns <code>x or y</code>, storing the result in <code>position</code>.\nAssert that the value <code>x</code> is boolean, and add a constraint …\nAssert that the values <code>x</code> and <code>y</code> are equal, and add a …\nAssert that the value <code>assert_equals_zero</code> is 0, and add a …\nExtract the bits from the variable <code>x</code> between <code>highest_bit</code> …\nCheck that the witness values in <code>x</code> and <code>y</code> are equal; …\nCheck that the witness value in <code>assert_equals_zero</code> is 0; …\nReturns the number of leading 1s in <code>x</code>, storing the result …\nReturns the number of leading 0s in <code>x</code>, storing the result …\nReturns <code>x / y</code>, storing the results in <code>position</code>.\nReturns <code>x / y</code>, storing the results in <code>position</code>.\nReturns 1 if <code>x</code> is equal to <code>y</code>, or 0 otherwise, storing the …\nFetch the memory value at address <code>addr</code> and store it in …\nFetch the last ‘access index’ that the memory at …\nFetch the value of the general purpose register with index …\nFetch the last ‘access index’ for the general purpose …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncreases the heap pointer by <code>by_amount</code> if <code>if_is_true</code> is <code>1</code>…\nInterpret an I-type instruction. The encoding of an I-type …\nInterpret an M-type instruction. The encoding of an M-type …\nInterpret an R-type instruction. The encoding of an R-type …\nInterpret an SB-type instruction. The encoding of an …\nInterpret an S-type instruction. The encoding of an S-type …\nInterpret an UJ-type instruction. The encoding of an …\nInterpret an U-type instruction. The encoding of an U-type …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds a lookup to the RangeCheck16Lookup table\nAdds a lookup to the AtMost4Lookup table\nAdds a lookup to the ByteLookup table\nReturns <code>x % y</code>, storing the results in <code>position</code>.\nReturns <code>x % y</code>, storing the results in <code>position</code>.\nReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.\nReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.\nReturns <code>((x * y) &gt;&gt; 32</code>, storing the results in <code>position</code>.\nReturns <code>(x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, storing the results in …\nReturns <code>(x * y) &amp; ((1 &lt;&lt; 32) - 1))</code>, storing the results in …\nReturns <code>x * y</code>, where <code>x</code> and <code>y</code> are treated as integers, …\nReturns <code>x nor y</code>, storing the result in <code>position</code>.\nReturns <code>x or y</code>, storing the result in <code>position</code>.\nSet the memory value at address <code>addr</code> to <code>value</code>.\nSet the last ‘access index’ for the memory at address …\nSet the general purpose register with index <code>idx</code> to <code>value</code>.\nSet the last ‘access index’ for the general purpose …\nSet the last ‘access index’ for the general purpose …\nSet the general purpose register with index <code>idx</code> to <code>value</code> …\nRange checks with 2 lookups to the RangeCheck16Lookup …\nRange checks with 2 lookups to the ByteLookup table that a …\nReturn the result of shifting <code>x</code> by <code>by</code>, storing the result …\nReturn the result of shifting <code>x</code> by <code>by</code>, storing the result …\nReturn the result of shifting <code>x</code> by <code>by</code>, storing the result …\nGiven a variable <code>x</code>, this function extends it to a signed …\nReturns <code>x + y</code> and the underflow bit, storing the results …\nReturns 1 if <code>x &lt; y</code> as unsigned integers, or 0 otherwise, …\nReturns 1 if <code>x &lt; y</code> as signed integers, or 0 otherwise, …\nReturns 1 if <code>x</code> is 0, or 0 otherwise, storing the result in …\nReturns <code>x xor y</code>, storing the result in <code>position</code>.\nFunction arguments/results\nFrame pointer/saved register. This is the same register.\nGlobal pointer\nCurrent instruction pointer\nNext instruction pointer\nReturn address\nThis enum provides aliases for the registers. This is …\nThis represents the internal state of the virtual machine.\nSaved registers\nStack pointer\nTemporary/alternate register\nTemporaries\nThread pointer\nReturns the argument unchanged.\nReturns the argument unchanged.\nThere are 32 general purpose registers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis structure represents the environment the virtual …\nMaximum number of memory or register accesses per …\nMaximum number of memory accesses per instruction (based …\nMaximum number of register accesses per instruction (based …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe actual number of instructions executed results from …\nExecute a single step in the RISCV32i program\nValues from 0 to 4 to check the number of bytes read from …\nAll values that can be stored in a byte (amortized table, …\nInput/Output of Keccak steps\nAll of the possible lookup table IDs used in the zkVM\nAll [1..136] values of possible padding lengths, the value …\nSingle-column table of all values in the range [0, 2^16)\nDual-column table of all values in the range [0, 2^16) and …\n24-row table with all possible values for round and their …\nSingle-column table of 2^16 entries with the sparse …\nSyscalls communication channel\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDegree of the quotient polynomial. Used to keep track of …\nTotal number of constraints for all instructions, …\nThe collection of polynomials (all in evaluation form) and …\nChallenges from the IOP.\nConstant values required\nThe domains used in the PLONK argument.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe value <code>prod_{j != 1} (1 - ω^j)</code>, used for efficiently …\nThe witness column polynomials. Includes relation columns …\nThe challenge to combine constraints\nThe challenge to compute 1/(beta + lookupvalue)\nThe challenge to combine tuple sum gamma^i lookupvalue_i\nThe collection of polynomials (all in evaluation form) and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is what the prover needs to remember while doing …\nTake a prover environment, a multiplicities, and returns a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nmultiplicities\nfixed tables pre-existing the protocol\nThis prover takes one Public Input and one Public Output …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIPA opening proof\nErrors that can arise when creating a proof\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMake a PlonKish proof for the given circuit. As inputs, we …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnum representing the two different modes of a RAMLookup\nStruct containing a RAMLookup\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransforms the current RAMLookup into an equivalent Logup\nCreates a new RAMLookup from a mode, a table ID, a …\nReturns the numerator corresponding to this lookup in the …\nReads one value when <code>if_is_true</code> is 1.\nReads one value from a table.\nWrites one value when <code>if_is_true</code> is 1.\nWrites one value to a table.")