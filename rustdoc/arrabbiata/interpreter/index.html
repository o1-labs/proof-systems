<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains the implementation of the IVC scheme in addition to running an arbitrary function that can use up to crate::NUMBER_OF_COLUMNS columns. At the moment, all constraints must be of maximum degree crate::MAX_DEGREE, but it might change in the future."><title>arrabbiata::interpreter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="arrabbiata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../arrabbiata/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../arrabbiata/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module interpreter</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">arrabbiata</a>::<wbr><a class="mod" href="#">interpreter</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/arrabbiata/interpreter.rs.html#1-1174">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains the implementation of the IVC scheme in addition to
running an arbitrary function that can use up to <a href="../constant.NUMBER_OF_COLUMNS.html" title="constant arrabbiata::NUMBER_OF_COLUMNS">crate::NUMBER_OF_COLUMNS</a>
columns.
At the moment, all constraints must be of maximum degree
<a href="../constant.MAX_DEGREE.html" title="constant arrabbiata::MAX_DEGREE">crate::MAX_DEGREE</a>, but it might change in the future.</p>
<p>The implementation relies on a representation of the circuit as a 2D array
of “data points” the interpreter can use.</p>
<p>An interpreter defines what a “position” is in the circuit and allow to
perform operations using these positions.
Some of these positions will be considered as public inputs and might be
fixed at setup time while making a proof, when other will be considered as
private inputs.</p>
<p>On top of these abstraction, gadgets are implemented.
For the Nova-like IVC schemes, we describe below the different gadgets and
how they are implemented with this abstraction.</p>
<p><strong>Table of contents</strong>:</p>
<ul>
<li><a href="#gadgets-implemented">Gadgets implemented</a>
<ul>
<li><a href="#elliptic-curve-addition">Elliptic curve addition</a>
<ul>
<li><a href="#gadget-layout">Gadget layout</a></li>
</ul>
</li>
<li><a href="#hash---poseidon">Hash - Poseidon</a>
<ul>
<li><a href="#gadget-layout-1">Gadget layout</a></li>
</ul>
</li>
<li><a href="#elliptic-curve-scalar-multiplication">Elliptic curve scalar multiplication</a>
<ul>
<li><a href="#gadget-layout-2">Gadget layout</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#handle-the-combinaison-of-constraints">Handle the combinaison of constraints</a></li>
<li><a href="#permutation-argument">Permutation argument</a></li>
<li><a href="#fiat-shamir-challenges">Fiat-Shamir challenges</a></li>
<li><a href="#folding">Folding</a></li>
<li><a href="#message-passing">Message passing</a></li>
</ul>
<h3 id="gadgets-implemented"><a href="#gadgets-implemented">Gadgets implemented</a></h3><h4 id="elliptic-curve-addition"><a href="#elliptic-curve-addition">Elliptic curve addition</a></h4>
<p>The Nova augmented circuit requires to perform elliptic curve operations, in
particular additions and scalar multiplications.</p>
<p>To reduce the number of operations, we consider the affine coordinates.
As a reminder, here are the equations to compute the addition of two
different points <code>P1 = (X1, Y1)</code> and <code>P2 = (X2, Y2)</code>. Let define <code>P3 = (X3, Y3) = P1 + P2</code>.</p>
<div class="example-wrap"><pre class="language-text"><code>- λ = (Y1 - Y2) / (X1 - X2)
- X3 = λ^2 - X1 - X2
- Y3 = λ (X1 - X3) - Y1
</code></pre></div>
<p>Therefore, the addition of elliptic curve points can be computed using the
following degree-2 constraints</p>
<div class="example-wrap"><pre class="language-text"><code>- Constraint 1: λ (X1 - X2) - Y1 + Y2 = 0
- Constraint 2: X3 + X1 + X2 - λ^2 = 0
- Constraint 3: Y3 - λ (X1 - X3) + Y1 = 0
</code></pre></div>
<p>If the points are the same, the λ is computed as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>- λ = (3 X1^2 + a) / (2Y1)
</code></pre></div><h5 id="gadget-layout"><a href="#gadget-layout">Gadget layout</a></h5>
<p>For given inputs (x1, y1) and (x2, y2), the layout will be as follow:</p>
<div class="example-wrap"><pre class="language-text"><code>| C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 | C15 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | --- | --- | --- | --- | --- | --- |
| x1 | y1 | x2 | y2 | b0 | λ  | x3 | y3 |    |     |     |     |     |     |     |
</code></pre></div>
<p>where <code>b0</code> is equal two <code>1</code> if the points are the same, and <code>0</code> otherwise.</p>
<p>TBD/FIXME: supports negation and the infinity point.</p>
<p>TBD/FIXME: the gadget layout might change when we will implement the
permutation argument. The values <code>(x1, y1)</code> can be public inputs.
The values <code>(x2, y2)</code> can be fetched from the permutation argument, and must
be the output of the elliptic curve scaling.</p>
<p>The gadget requires therefore 7 columns.</p>
<h4 id="hash---poseidon"><a href="#hash---poseidon">Hash - Poseidon</a></h4>
<p>Hashing is a crucial part of the IVC scheme. The hash function the
interpreter does use for the moment is an instance of the Poseidon hash
function with a fixed state size of
<a href="../curve/struct.PlonkSpongeConstants.html#associatedconstant.SPONGE_WIDTH" title="associated constant arrabbiata::curve::PlonkSpongeConstants::SPONGE_WIDTH">crate::curve::PlonkSpongeConstants::SPONGE_WIDTH</a>. Increasing the
state size can be considered as it would potentially optimize the
number of rounds, and allow hashing more data on one row. We leave this for
future works.</p>
<p>A direct optimisation would be to use
<a href="https://eprint.iacr.org/2023/323">Poseidon2</a> as its performance on CPU is
better, for the same security level and the same cost in circuit. We leave
this for future works.</p>
<p>For a first version, we consider an instance of the Poseidon hash function
that is suitable for curves whose field size is around 256 bits.
A security analysis for these curves give us a recommandation of 60 full
rounds if we consider a 128-bit security level and a low-degree
exponentiation of <code>5</code>, with only full rounds.
In the near future, we will consider the partial rounds strategy to reduce
the CPU cost. For a first version, we keep the full rounds strategy to keep
the design simple.</p>
<p>When applying the full/partial round strategy, an optimisation can be used,
see <a href="https://eprint.iacr.org/2022/462">New Optimization techniques for PlonK’s
arithmetisation</a>. The techniques described
in the paper can also be generalized to other constraints used in the
interpreter, but we leave this for future works.</p>
<h5 id="gadget-layout-1"><a href="#gadget-layout-1">Gadget layout</a></h5>
<p>We start with the assumption that <a href="../constant.NUMBER_OF_COLUMNS.html" title="constant arrabbiata::NUMBER_OF_COLUMNS">crate::NUMBER_OF_COLUMNS</a> columns are
available for the whole circuit, and we can support constraints up to degree
<a href="../constant.MAX_DEGREE.html" title="constant arrabbiata::MAX_DEGREE">crate::MAX_DEGREE</a>.
Therefore, we can compute 5 full rounds per row by using the “next row”
(i.e. adding an evaluation point at ζω). An implementation is provided in
the gadget <a href="../columns/enum.Gadget.html#variant.Poseidon" title="variant arrabbiata::columns::Gadget::Poseidon">crate::columns::Gadget::Poseidon</a>.</p>
<p>The layout for the one using the “next row” is as follow (5 full rounds):</p>
<div class="example-wrap"><pre class="language-text"><code>| C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 | C15 |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | --- | --- | --- | --- | --- | --- |
| x  | y  | z  | a1 | a2 | a3 | b1 | b2 | b3 | c1  | c2  | c3  | d1  | d2  | d3  |
| o1 | o2 | o2
</code></pre></div>
<p>where (x, y, z) is the input of the current step, (o1, o2, o3) is the
output, and the other values are intermediary values. And we have the
following equalities:</p>
<div class="example-wrap"><pre class="language-text"><code>(a1, a2, a3) = PoseidonRound(x, y, z)
(b1, b2, b3) = PoseidonRound(a1, a2, a3)
(c1, c2, c3) = PoseidonRound(b1, b2, b3)
(d1, d2, d3) = PoseidonRound(c1, c2, c3)
(o1, o2, o3) = PoseidonRound(d1, d2, d3)
</code></pre></div>
<p>Round constants are passed as public inputs. As a
reminder, public inputs are simply additional columns known by the prover
and verifier.
Also, the elements to absorb are added to the initial state at the beginning
of the call of the Poseidon full hash. The elements to absorb are supposed
to be passed as public inputs.</p>
<h4 id="elliptic-curve-scalar-multiplication"><a href="#elliptic-curve-scalar-multiplication">Elliptic curve scalar multiplication</a></h4>
<p>The Nova-based IVC schemes require to perform scalar multiplications on
elliptic curve points. The scalar multiplication is computed using the
double-and-add algorithm.</p>
<p>We will consider a basic implementation using the “next row”. The
accumulators will be saved on the “next row”. The decomposition of the
scalar will be incremental on each row.
The scalar used for the scalar multiplication will be fetched using the
permutation argument (FIXME: to be implemented).
More than one bit can be decomposed at the same time, and we could reduce
the number of rows.
We leave this for future work.</p>
<h5 id="gadget-layout-2"><a href="#gadget-layout-2">Gadget layout</a></h5>
<p>For a (x, y) point and a scalar, we apply the double-and-add algorithm, one step per row.
Therefore, we have 255 rows to compute the scalar multiplication.
For a given step <code>i</code>, we have the following values:</p>
<ul>
<li><code>tmp_x</code>, <code>tmp_y</code>: the temporary values used to keep the double.</li>
<li><code>res_x</code>, <code>res_y</code>: the result of the scalar multiplication i.e. the accumulator.</li>
<li><code>b</code>: the i-th bit of the scalar.</li>
<li><code>r_i</code> and <code>r_(i+1)</code>: scalars such that r_(i+1) = b + 2 * r_i.</li>
<li><code>λ'</code> and <code>λ</code>: the coefficients</li>
<li>o’_x and o’_y equal to <code>res_plus_tmp_x</code> and <code>res_plus_tmp_y</code> if <code>b == 1</code>,
otherwise equal to <code>o_x</code> and <code>o_y</code>.</li>
</ul>
<p>We have the following layout:</p>
<div class="example-wrap"><pre class="language-text"><code>| C1   |   C2   |      C3       |      C4       |    C5     | C7 |       C7       |       C8       | C9 | C10 |   C11    | C12 | C13 | C14 | C15 |
| --   | -----  | ------------- | ------------- | --------- | -- | -------------- | -------------- | -- | --- | -------- | --- | --- | --- | --- |
| o_x  |  o_y   | double_tmp_x  | double_tmp_y  |    r_i    | λ  | res_plus_tmp_x | res_plus_tmp_y | λ&#39; |  b  |
| o&#39;_x |  o&#39;_y  | double_tmp&#39;_x | double_tmp&#39;_y |  r_(i+1)  |
</code></pre></div>
<p>FIXME: an optimisation can be implemented using “a bucket” style algorithm,
as described in <a href="https://github.com/o1-labs/rfcs/blob/main/0013-efficient-msms-for-non-native-pickles-verification.md">Efficient MSMs in Kimchi
Circuits</a>.
We leave this for future work.</p>
<h3 id="handle-the-combinaison-of-constraints"><a href="#handle-the-combinaison-of-constraints">Handle the combinaison of constraints</a></h3>
<p>The prover will have to combine the constraints to generate the
full circuit at the end. The constraints will be combined using a
challenge (often called α) that will be generated in the verifier circuit by
simulating the Fiat-Shamir transformation.
The challenges will then be accumulated over time using the random coin used
by the folding argument.
The verifier circuit must be carefully implemented to ensure that all the
messages that the prover would have sent before coining the random combiner
for the constraints has been absorbed properly in the verifier circuit.</p>
<p>Using this technique requires us a folding scheme that handles degree
<code>5 + 1</code> constraints, as the challenge will be considered as a variable.
The reader can refer to this <a href="https://hackmd.io/@dannywillems/Syo5MBq90">HackMD
document</a> for more details.</p>
<h3 id="permutation-argument"><a href="#permutation-argument">Permutation argument</a></h3>
<p>Communication between rows must be done using a permutation argument. The
argument we use will be a generalisation of the one used in the <a href="https://eprint.iacr.org/2019/953">PlonK
paper</a>.</p>
<p>The construction of the permutations will be done using the methods prefixed
<code>save</code> and <code>load</code>. The index of the current row and the index of the
time the value has been written will be used to generate the permutation on
the fly.</p>
<p>The permutation argument described in the PlonK paper is a kind of “inverse
lookup” protocol, like Plookup. The polynomials are defined as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>           Can be seen as T[f(X)] = Χ
         --------
         |      |
f&#39;(X) = f(X) + β X + γ
                     |--- Can be seen as the evaluation point.
                        |
                        |
g&#39;(X) = g(X) + β σ(X) + γ
         |      |
         --------
         Can be seen as T[g(X)] = σ(X)
</code></pre></div>
<p>And from this, we build an accumulator, like for Plookup.
The accumulator requires to coin two challenges, β and γ, and it must be
done after the commitments to the columns have been absorbed.
The verifier at the next step will verify that the challenges have been
correctly computed.
In the implementation, the accumulator will be computed after the challenges
and the commitments. Note that the accumulator must also be aggregated, and
the aggregation must be performed by the verifier at the next step.</p>
<p>The methods <code>save</code> and <code>load</code> will accept as arguments only a column that is
included in the permutation argument. For instance, <code>save_poseidon_state</code>
will only accept columns with index 3, 4 and 5, where the
<code>load_poseidon_state</code> will only accepts columns with index 0, 1 and 2.</p>
<p>The permutations values will be saved in public values, and will contain the
index of the row. The permutation values will be encoded with a 32 bits
value (u32) as we can suppose a negligible probability that a user will use
more than 2^32 rows.</p>
<p>The permutation argument also generates constraints that will be
homogenized with the gadget constraints.</p>
<p>Note all rows might require to use the permutation argument. Therefore, a
selector will be added to activate/deactivate the permutation argument.
When a method calls <code>save</code> or <code>load</code>, the selector will be activated. By
default, the selector will be deactivated.</p>
<p>TBD:</p>
<ul>
<li>number of columns</li>
<li>accumulator column</li>
<li>folding of the permutation argument</li>
</ul>
<p>TBD/FIXME: do we use a additive permutation argument to increase the number
of columns we can perform the permutation on?</p>
<p>TBD/FIXME: We can have more than one permutation argument. For instance, we
can have a permutation argument for the columns 0, 1, 2, 3 and one for the
columns 4, 5, 6, 7. It can help to decrease the degree.</p>
<h3 id="fiat-shamir-challenges"><a href="#fiat-shamir-challenges">Fiat-Shamir challenges</a></h3>
<p>The challenges sent by the verifier must also be simulated by the verifier
circuit. It is done by passing “messages” as public inputs to the next
instances. Diagrams recapitulating the messages that must be passed are
available in the section <a href="#message-passing">Message passing</a>.</p>
<p>For a step <code>i + 1</code>, the challenges of the step <code>i</code> must be computed by the
verifier in the circuit, and check that it corresponds to the ones received
as a public input.</p>
<p>TBD/FIXME: specify. Might require foreign field arithmetic.</p>
<p>TBD/FIXME: do we need to aggregate them for the end?</p>
<h3 id="folding"><a href="#folding">Folding</a></h3>
<p>Constraints must be homogenized for the folding scheme.
Homogenising a constraint means that we add a new variable (called “U” in
Nova for instance) that will be used to homogenize the degree of the monomials
forming the constraint.
Next to this, additional information, like the cross-terms and the error
terms must be computed.</p>
<p>This computation depends on the constraints, and in particular on the
monomials describing the constraints.
The computation of the cross-terms and the error terms happen after the
witness has been built and the different arguments like the permutation and
lookups have been done. Therefore, the interpreter must provide a method to
compute it, and the constraints should be passed as an argument.</p>
<p>When computing the cross-terms, we must compute the contribution of each
monomial to it.</p>
<p>The implementation works as follow:</p>
<ul>
<li>Split the constraint in monomials</li>
<li>For the monomials of degree <code>d</code>, compute the contribution when
homogenizing to degree <code>d'</code>.</li>
<li>Sum all the contributions.</li>
</ul>
<p>The library [mvpoly] can be used to compute the cross-terms and to
homogenize the constraints. The constraints can be converted into a type
implementing the trait <a href="mvpoly::MVPoly">MVPoly</a> and the method
<a href="mvpoly::MVPoly::compute_cross_terms">compute_cross_terms</a> can be used from
there.</p>
<h3 id="message-passing"><a href="#message-passing">Message passing</a></h3>
<p>The message passing is a crucial part of the IVC scheme. The messages are
mostly commitments and challenges that must be passed from one step to
another, and by “jumping” between curves. In the implementation,
the messages are kept in an “application environment”, located in the
“witness environment”. The structure <a href="../witness/struct.Env.html" title="struct arrabbiata::witness::Env">crate::witness::Env</a> is used to keep
track of the messages that must be passed.
Each step starts with an “program state” and end with another that is
accumulated. The final state is passed through a “digest” to the next
instance. The digest is performed using a hash function (see <a href="#hash---poseidon">Hash -
Poseidon</a>). We often use the term “sponge” to refer to the
hash function or the state of the hash function.</p>
<p>The sponge state will be forked at different steps, to provide a
consistent state between the different instances and the different curves.
The challenges will be computed using the sponge state after hashing the
appropriate values from the appropriate initial state, and be kept in the
environment.</p>
<p>In the diagram below, each object subscripted by <code>(p, n)</code> (resp. <code>(q, n)</code>)
means that they are related to the instance <code>n</code> whose circuit is defined in
the field <code>Fp</code> (resp. <code>Fq</code>), the scalar field of Vesta (resp. Pallas).</p>
<p>In addition to that, we use</p>
<ul>
<li><code>w_(p, n)</code> for the witness.</li>
<li><code>W_(p, n)</code> for the aggregated witness.</li>
<li><code>C_(p, n)</code> for the commitment to the witness <code>w_(p, n)</code>.</li>
<li><code>acc_(p, n)</code> for the accumulated commitments to the aggregated witness
<code>W_(p, n)</code>.</li>
<li><code>α_(p, n)</code> for the challenge used to combine constraints.</li>
<li><code>β_(p, n)</code> and <code>γ_(p, n)</code> for the challenge used to for the
permutation argument.</li>
<li><code>r_(p, n)</code> for the challenge used for the accumulation of the</li>
<li><code>t_(p, n, i)</code> for the evaluations of the cross-terms of degree <code>i</code>.</li>
<li><code>Ct_(p, n, i)</code> for the commitments to the cross-terms of degree <code>i</code>.
witness/commitments.</li>
<li><code>u_(p, n)</code> for the challenge used to homogenize the constraints.</li>
<li><code>o_(p, n)</code> for the final digest of the sponge state.</li>
</ul>
<p>Here a diagram (FIXME: this is not complete) that shows the messages that
must be passed:</p>
<div class="example-wrap"><pre class="language-text"><code>+------------------------------------------+                      +------------------------+
|            Instance n                    |                      |     Instance n + 2     |
|        (witness w_(p, n))                |                      | (witness W_(p, n + 1)) |
|            ----------                    |                      |     ----------         |
|               Vesta                      |                      |         Vesta          |
|         (scalar field = Fp)              |                      |   (scalar field = Fp)  |
|         (base field   = Fq)              |                      |   (base field   = Fq)  |
|          (Sponge over Fq)                |                      |    (Sponge over Fq)    |
|                                          |                      |                        |
|          Generate as output              |                      |   Generate as output   |
|          ------------------              |                      |   ------------------   |
| Challenges:                              |                      | Challenges:            |
| - α_(p, n)                               |                      | - α_(p, n + 1)         |
| - β_(p, n)                               |                      | - β_(p, n + 1)         |
| - γ_(p, n)                               |                      | - γ_(p, n + 1)         |
| - r_(p, n)                               |                      | - r_(p, n + 1)         |
| - u_(p, n)                               |                      | - u_(p, n + 1)         |
| Commitments:                             |                      |          (...)         |
| - Cross-terms (`Ct_(p, n)`)              |                      +------------------------+
| - Witness columns (`w_(p, n)`)           |                                   ^
| Fiat-Shamir:                             |                                   |
| - digest of all messages read until      |                                   |
| now -&gt; `o_(p, n)`                        |                                   |
|                                          |                                   |
|             Receive in PI                |                                   |
|             --------------               |                                   |
| - Commitments to w_(p, (n - 1))          |                                   |
| - Final digest of the program            |                                   |
| state at instance (n - 1)                |                                   |
| (o_(q, n - 1)).                          |                                   |
| - Final digest of the program            |                                   |
| state at instance (n - 2)                |                                   |
| (o_(p, n - 1)).                          |                                   |
|                                          |                                   |
|             Responsibility               |                                   |
|             --------------               |                                   |
| - Verify FS challenges (α_(q, n - 1),    |                                   |
| β_(q, n - 1), γ_(q, n - 1),              |                                   |
| r_(q, n - 1), u_(q, n - 1)               |                                   |
| (i.e. challenges of instance n - 1)      |                                   |
| from o_(q, n - 1)                        |                                   |
| - Aggregate witness columns w_(p, n)     |                                   |
| into W_(p, n).                           |                                   |
| - Aggregate error terms                  |                                   |
| from instance n - 2 with cross terms of  |                                   |
| instance n - 2                           |                                   |
+------------------------------------------+                                   |
                     |                                                         |
                     |                                                         |
                     |             +----------------------------+              |
                     |             |       Instance n + 1       |              |
                     |             |   (witness w_(q, n))       |              |
                     |             |       --------------       |              |
                     |             |           Pallas           |              |
                     |             |      (scalar field = Fq)   |              |
                     |-----------&gt; |      (base field   = Fp)   |--------------
                                   |       (Sponge over Fp)     |
TODO: define msgs                  |                            |    TODO: define msgs
      format to pass               |            TODO            |     format to pass
        IO                         |                            |          IO
                                   |                            |
                                   |                            |
                                   +----------------------------+
</code></pre></div><h4 id="workflow-example-for-handling-a-challenge"><a href="#workflow-example-for-handling-a-challenge">Workflow example for handling a challenge</a></h4>
<p>Handling challenges is performed in two steps. Let’s take the example of the
verifier coin <code>u</code> used to homogenize the constraints/polynomials in the
accumulation protocol. For the sake of simplicity, we only focus on the work
related to the challenges. In addition to that, a verifier coin <code>r</code> is used
to accumulate the challenges. Therefore, we start with the following
diagram:</p>
<div class="example-wrap"><pre class="language-text"><code>+------------------------------------------+
|            Instance n                    |
|        (witness w_(p, n))                |
|            ----------                    |
|               Vesta                      |
|         (scalar field = Fp)              |
|         (base field   = Fq)              |
|          (Sponge over Fq)                |
|                                          |
| Generate as output:                      |
| - u_(p, n)                               |
| - r                                      |
| - &quot;accumulated u&quot;: u_p + r * u_(p, n)    |
|     (note the operations are over Fp)    |
+------------------------------------------+
</code></pre></div>
<p>The coins <code>u_(p, n)</code> and <code>r</code> are generated after absorbing a few committed
values (i.e. points over Fq). The verifier will have to check the following:</p>
<ul>
<li><code>u_(p, n)</code> has been coined correctly (i.e. check a sponge state).</li>
<li><code>r</code> has been coined correctly (i.e. check a sponge staet).</li>
<li>“accumulated u” has been computed correctly</li>
</ul>
<p>At the next iteration, the verifier is working over the field <code>Fq</code>, i.e. the
field that is used to generate the challenges. Therefore, it can perform the
first two checks. We have then the following diagram.</p>
<div class="example-wrap"><pre class="language-text"><code>+------------------------------------------+
|            Instance n                    |
|        (witness w_(p, n))                |
|            ----------                    |
|               Vesta                      |
|         (scalar field = Fp)              |
|         (base field   = Fq)              |
|          (Sponge over Fq)                |
|                                          |
| Generate as output:                      |
| - u_(p, n)                               |
| - r                                      |
| - &quot;accumulated u&quot;: u_p + r * u_(p, n)    |
|     (note the operations are over Fp)    |
+------------------------------------------+
      |
      |
      |
      |               +-----------------------------+
      |               |       Instance (n + 1)      |
      |               |      (witness w_(q, n))     |
      |-------------&gt; |          ----------         |
                      |          Pallas             |
                      |    (scalar field = Fq)      |
                      |    (base field   = Fp)      |
                      |     (Sponge over Fp)        |
                      |                             |
                      |     Receive as (public)     |
                      |           inputs            |
                      |       ---------------       |
                      | - commitments generated     |
                      | by instance n (Fq elements) |
                      | - u_(p, n)                  |
                      | - r                         |
                      | - (more but unused by       |
                      | the verifier)               |
                      |                             |
                      |      Verifier circuit       |
                      |      ----------------       |
                      | - run the sponge to         |
                      | check the value u_(p, n)    |
                      | and r                       |
                      +-----------------------------+
</code></pre></div>
<p>The last check, i.e. checking the accumulation of <code>u</code>, is “delayed” for the
instance (n + 2), to be able to perform the accumulation over Fp.</p>
<p>Therefore, we end up with the following diagram:</p>
<div class="example-wrap"><pre class="language-text"><code>+------------------------------------------+            +-------------------------------------+
|            Instance n                    |            |            Instance (n + 2)         |
|        (witness w_(p, n))                |            |         (witness w_(p, n + 1))      |
|            ----------                    |            |            ----------               |
|               Vesta                      |            |               Vesta                 |
|         (scalar field = Fp)              |            |         (scalar field = Fp)         |
|         (base field   = Fq)              |            |         (base field   = Fq)         |
|          (Sponge over Fq)                |            |          (Sponge over Fq)           |
|                                          |            |                                     |
           Generate as output:             |            |        Receive as (public inputs)   |
             ---------------               |            |           -------------------       |
| - u_(p, n)                               |            | - `u_(p, n)`                        |
| - r                                      |            | - accumulated u, `acc_u`            |
| - &quot;accumulated u&quot;: u_p + r * u_(p, n)    |            | - random coin `r`                   |
|     (note the operations are over Fp)    |            | - &quot;old accumulated value&quot; u_p       |
+------------------------------------------+            |           Verifier circuit          |
      |                                                 |           ----------------          |
      |                                                 | - check that                        |
      |                                                 | `acc_u = u_p + r * u_(p, n)`        |
      |                                                 +-------------------------------------+
      |                                                                 ^
      |                                                                 |
      |                                                                 |
      |               +-----------------------------+                   |
      |               |       Instance (n + 1)      |                   |
      |               |      (witness w_(q, n))     |                   |
      |-------------&gt; |          ----------         |  ------------------
                      |          Pallas             |
                      |    (scalar field = Fq)      |
                      |    (base field   = Fp)      |
                      |     (Sponge over Fp)        |
                      |                             |
                      |     Receive as (public)     |
                      |           inputs            |
                      |       ---------------       |
                      | - commitments generated     |
                      | by instance n (Fq elements) |
                      | - u_(p, n)                  |
                      | - r                         |
                      | - (more but unused by       |
                      | the verifier)               |
                      |                             |
                      |      Verifier circuit       |
                      |      ----------------       |
                      | - run the sponge to         |
                      | check the value u_(p, n)    |
                      | and r                       |
                      +-----------------------------+
</code></pre></div></div></details><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Instruction.html" title="enum arrabbiata::interpreter::Instruction">Instruction</a></div><div class="desc docblock-short">A list of instruction/gadget implemented in the interpreter.
The control flow can be managed by implementing a function
<code>fetch_next_instruction</code> and <code>fetch_instruction</code> on a witness environnement.
See the <a href="../witness/struct.Env.html" title="struct arrabbiata::witness::Env">Witness environment</a> for more details.</div></li><li><div class="item-name"><a class="enum" href="enum.Side.html" title="enum arrabbiata::interpreter::Side">Side</a></div><div class="desc docblock-short">Define the side of the temporary accumulator.
When computing G1 + G2, the interpreter will load G1 and after that G2.
This enum is used to decide which side fetching into the cells.
In the near future, it can be replaced by an index.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.InterpreterEnv.html" title="trait arrabbiata::interpreter::InterpreterEnv">InterpreterEnv</a></div><div class="desc docblock-short">An abstract interpreter that provides some functionality on the circuit. The
interpreter should be seen as a state machine with some built-in
functionality whose state is a matrix, and whose transitions are described
by polynomial functions.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.run_app.html" title="fn arrabbiata::interpreter::run_app">run_app</a></div><div class="desc docblock-short">Run the application</div></li><li><div class="item-name"><a class="fn" href="fn.run_ivc.html" title="fn arrabbiata::interpreter::run_ivc">run_ivc</a></div><div class="desc docblock-short">Run an iteration of the IVC scheme</div></li></ul></section></div></main></body></html>