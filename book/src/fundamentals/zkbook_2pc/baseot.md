# Base OT

We introduce the [CO15](https://eprint.iacr.org/2015/267.pdf) OT as the base OT.

**Notation**. The protocol is described over an additive group $(\bG,\G,p,+)$ of
prime order $p$ generated by $\G$. Denote
$\sH:(\bG\times \bG)\times\bG\rightarrow \bit^\lambda$ as a key-derivation
function to extract a $\lambda$-bit key from group elements.

Note that $\sH$ here is different from the tweakable hash function in garbled
circuit.

In the CO15 protocol, the sender holds $n$ $128$-bit strings
$\{(\sX^0_i,\sX^1_i)\}_{i\in[n]}$ and the receiver holds $n$-bit string
$b\in\bit^n$. The protocol is as follows.

- The sender samples $y\leftarrow \bF_p$, and computes $\S = y\cdot \G$ and
  $\T = y\cdot \S$.

- The sender sends $\S$ to the receiver, who aborts if $\S\notin\bG$.

- For $i\in[n]$, the receiver samples $x_i\leftarrow \bF_p$, and computes:
  $$\R_i = b_i\S+x_i\G$$

- The receiver sends $\{\R_i\}_{i\in[n]}$ to the sender, who aborts if
  $\R_i\notin\bG$.

- For $i\in[n]$, the sender computes
  $$k_i^0 = \sH(\S,\R_i,y\R_i),~k_i^1 = \sH(\S,\R_i,y\R_i-\T)$$ and sends
  $\{(c_i^0 = k_i^0\oplus \sX^0_i, c_i^1 = k_i^1\oplus\sX^1_i)\}_{i\in[n]}$ to
  the receiver.

- For $i\in[n]$, the receiver computes $k_i = \sH(\S,\R_i,x_i\S)$, and outputs
  $c_i^{b_i}\oplus k_i$

**Correctness**. The receiver always computes the hash of $x_i\S = (x_iy)\G$.
The sender sends the hashes of $y\R_i$ and $y\R_i-\T$. If $b_i = 0$, $k_i^0$ is
the hash of $y\R_i = (yx_i)\G$, then the receive will get $\sX^0_i$. if
$b_i = 1$, $k_i^1$ is the hash of $y\R_i - \T = y(\S+x_i\G)-\T = (yx_i)\G$, then
the receiver will get $\sX_i^1$.

**Security**. We refer the security analysis to
[CO15](https://eprint.iacr.org/2015/267.pdf).
