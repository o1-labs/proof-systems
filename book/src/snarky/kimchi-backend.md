# Kimchi Backend

![](https://i.imgur.com/KmKU5Pl.jpg)

Underneath the snarky wrapper (in `snarky/checked_runner.rs`) lies what we used to call the `plonk_constraint_system` or `kimchi_backend` in `snarky/constraint_systen.rs`.

```admonish
It is good to note that we're planning on removing this abstract separation between the snarky wrapper and the constraint system.
```

The logic in the kimchi backend serves two purposes:

* **Circuit generation**. It is the logic that adds gates to our list of gates (representing the circuit). For most of these gates, the variables used are passed to the backend by the snarky wrapper, but some of them are created by the backend itself (see more in the [variables section](#variables)).
* **Witness generation**. It is the logic that creates the witness

One can also perform two additional operations once the constraint system has been compiled:

* Generate the prover and verifier index for the system.
* Get a hash of the constraint system (this includes the circuit, the number of public input) (TODO: verify that this is true) (TODO: what else should be in that hash? a version of snarky and a version of kimchi?).

## A circuit

A circuit is either being built, or has been constructed during a circuit generation phase:

```rust
enum Circuit<F>
where
    F: PrimeField,
{
    /** A circuit still being written. */
    Unfinalized(Vec<GateSpec<(), F>>),
    /** Once finalized, a circuit is represented as a digest
        and a list of gates that corresponds to the circuit.
    */
    Compiled([u8; 32], Vec<CircuitGate<F>>),
}
```

## State

The state of the kimchi backend looks like this:

```rust
where
    Field: PrimeField,
{
    /// A counter used to track variables
    /// (similar to the one in the snarky wrapper)
    next_internal_var: usize,

    /// Instruction on how to compute each internal variable 
    /// (as a linear combination of other variables).
    /// Used during witness generation.
    internal_vars: HashMap<InternalVar, (Vec<(Field, V)>, Option<Field>)>,

    /// The symbolic execution trace table.
    /// Each cell is a variable that takes a value during witness generation.
    /// (if not set, it will take the value 0).
    rows: Vec<Vec<Option<V>>>,

    /// The circuit once compiled
    gates: Circuit<Field>,

    /// The row to use the next time we add a constraint.
    // TODO: I think we can delete this
    next_row: usize,

    /// The size of the public input
    /// (which fills the first rows of our constraint system.
    public_input_size: Option<usize>,

    // omitted values...
}
```

## Variables

In the backend, there's two types of variables:

```rust
enum V {
    /// An external variable 
    /// (generated by snarky, via [exists]).
    External(usize),

    /// An internal variable is generated to hold an intermediate value,
    /// (e.g. in reducing linear combinations to single PLONK positions).
    Internal(InternalVar),
}
```

Internal variables are basically a `usize` pointing to a hashmap in the state.

That hashmap tells you how to compute the internal variable during witness generation: it is always a linear combination of other variables (and a constant).

## Circuit generation

During circuit generation, the snarky wrapper will make calls to the `add_constraint()` or `add_basic_snarky_constraint` function of the kimchi backend, specifying what gate to use and what variables to use in that gate.

At this point, the snarky wrapper might have some variables that are not yet tracked as such (with a counter).
Rather, they are constants, or they are a combination of other variables.
You can see that as a small AST representing how to compute a variable.
(See the [variables section](./vars.md#circuit-vars) for more details).

For this reason, they can hide a number of operations that haven't been constrained yet.
It is the role of the `add_constrain` logic to enforce that at this point constants, as well as linear combinations or scalings of variables, are encoded in the circuit. 
This is done by adding enough generic gates (using the `reduce_lincom()` or `reduce_to_var()` functions).

```admonish
This is a remnant of an optimization targeting R1CS (in which additions are for free).
An issue with this approach is the following: imagine that two circuit variables are created from the same circuit variable, imagine also that the original circuit variable contained a long AST, then both variables might end up creating the same constraints to convert that AST.
Currently, snarkyjs and pickles expose a `seal()` function that allows you to reduce this issue, at the cost of some manual work and mental tracking on the developer.
We should probably get rid of this, while making sure that we can continue to optimize generic gates 
(in some cases you can merge two generic gates in one (TODO: give an example of where that can happen)).
Another solution is to keep track of what was reduced, and reuse previous reductions (similar to how we handle constants).
```

It is during this "reducing" step that internal variables (known only to the kimchi backend) are created.

```admonish
The process is quite safe, as the kimchi backend cannot use the snarky wrapper variables directly (which are of type `FieldVar`).
Since the expected format (see the [variables section](#variables) is a number (of type `usize`), the only way to convert a non-tracked variable (constant, or scale, or linear combination) is to reduce it (and in the process constraining its value).
```

Depending on the gate being used, several constraints might be added via the `add_row()` function which does three things:

1. figure out if there's any wiring to be done
2. add a gate to our list of gates (representing the circuit)
3. add the variables to our _symbolic_ execution trace table (symbolic in the sense that nothing has values yet)

This process happens as the circuit is "parsed" and the constraint functions of the kimchi backend are called.

This does not lead to a finalized circuit, see the next section to see how that is done.

(TODO: ideally this should happen in the same step)

## Finalization of the circuit.

So far we've only talked about adding specific constraints to the circuit, but not about how public input are handled.

The `finalization()` function of the kimchi backend does the following:

* add as many generic rows as there are public inputs.
* construct the permutation 
* computes a cache of the circuit (TODO: this is so unnecessary)
* and other things that are not that important

## Witness generation

Witness generation happens by taking the finalized state (in the `compute_witness()` function) with a callback that can be used to retrieve the values of external variables (public input and public output).

The algorithm follows these steps using the symbolic execution table we built during circuit generation:

1. it initializes the execution trace table with zeros
2. go through the rows related to the public input and set the most-left column values to the ones obtained by the callback.
3. go through the other rows and compute the value of the variables left in the table

Variables in step 3. should either:

* be absent (`None`) and evaluated to the default value 0
* point to an external variable, in which case the closure passed can be used to retrieve the value
* be an internal variable, in which case the value is computed by evaluating the AST that was used to create it.

## Permutation

The permutation is used to wire cells of the execution trace table (specifically, cells belonging to the first 7 columns).
It is also known as "copy constraints".

```admonish
In snarky, the permutation is represented differently from kimchi, and thus needs to be converted to the kimchi's format before a proof can be created.
TODO: merge the representations
```

We use the permutation in ingenious ways to optimize circuits. 
For example, we use it to encode each constants once, and wire it to places where it is used. 
Another example, is that we use it to assert equality between two cells.

## Implementation details

There's two aspect of the implementation of the permutation, the first one is a hashmap of equivalence classes, which is used to track all the positions of a variable, the second one is making use of a [union find]() data structure to link variables that are equivalent (we'll talk about that after).

The two data structures are in the kimchi backend's state:

```rust
pub struct SnarkyConstraintSystem<Field>
where
    Field: PrimeField,
{
    equivalence_classes: HashMap<V, Vec<Position<Row>>>,
    union_finds: disjoint_set::DisjointSet<V>,
    // omitted fields...
}
```

### equivalence classes

As said previously, during circuit generation a symbolic execution trace table is created. It should look a bit like this (if there were only 3 columns and 4 rows):

|     |  0  |  1  |  2 |
| :-: | :-: | :-: | :-:| 
|  0  |  v1 |  v1 |    |
|  1  |     |  v2 |    |
|  2  |     |  v2 |    |
|  3  |     |     | v1 |

From that, it should be clear that all the cells containing the variable `v1` should be connected, 
and all the cells containing the variable `v2` should be as well.

The format that the permutation expects is a [cycle](https://en.wikipedia.org/wiki/Cyclic_permutation): a list of cells where each cell is linked to the next, the last one wrapping around and linking to the first one.

For example, a cycle for the `v1` variable could be:

```
(0, 0) -> (0, 1)
(0, 1) -> (3, 2)
(3, 2) -> (0, 0)
```

During circuit generation, a hashmap (called `equivalence_classes`) is used to track all the positions (row and column) of each variable.

During finalization, all the different cycles are created by looking at all the variables existing in the hashmap.

### Union finds

Sometimes, we know that two variables will have equivalent values due to an `assert_equal()` being called to link them.
Since we link two variables together, they need to be part of the same cycle, and as such we need to be able to detect that to construct correct cycles.

To do this, we use a [union find]() data structure, which allows us to easily find the unions of equivalent variables.

When an `assert_equal()` is called, we link the two variables together using the `union_finds` data structure.

During finalization, when we create the cycles, we use the `union_finds` data structure to find the equivalent variables.
We then create a new equivalence classes hashmap to merge the keys (variables) that are in the same set.
This is done before using the equivalence classes hashmap to construct the cycles.

## Validation during witness generation

We want to make sure that the program runs to completion, with the given input, before we start computing the proof (which is expensive).

On top of that, we also want to tell the user what line in their circuit has rejected their input. Like a normal program.

This is configurable, via a `eval_constraints` boolean in the state, and is set to `true` by default.

To perform this validation, we do two things:

**Constants**. In functions that assert, we always check if we're dealing with constants first. If we are dealing with constants, we don't create any constraints, and we directly check if the computation is correct. For example:

```rust
pub fn assert_equals(
        &self,
        state: &mut RunState<F>,
        other: &FieldVar<F>,
    ) -> SnarkyResult<()> {
        match (self, other) {
            (FieldVar::Constant(x), FieldVar::Constant(y)) => {
                if x == y {
                    Ok(())
                } else {
                    Err(/* ... */)
                }
            }
            () => state.add_constraint(/* ... */)
        }
    }
```

**Runtime values**. During witness generation, actual values are passed to the circuit and can also not pass an "asserting" function. In these cases, we directly check the computation via the gates. 

What does it mean? For example, when we add a generic constraint during witness generation (which are backing a number of asserting functions), we check that the actual values satisfy the generic gate equation. 

Note that not all gates are behind asserting functions, for example the Poseidon gate does not have "bad" inputs, and as such we don't do any checks on it. If for some reason the inputs are bad, it means that the user did this on purpose, and the proof will fail.
